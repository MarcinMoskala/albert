---
courses:
  - courseId: "course-kotlin_essentials"
    title: "Course Kotlin Essentials"
    lessons:
      - lessonId: "lesson-what-is-kotlin?"
        name: "What is Kotlin?"
        steps:
          - type: "text"
            stepId: "lesson-01_what_is_kotlin-{sample:-true}-text"
            repeatable: false
            text: |-
              # What is Kotlin?
              
              Kotlin is an open-source, multiplatform, multi-paradigm, statically typed, general-purpose programming language. But what does all this mean?
              * Open-source means that the sources of the Kotlin compiler are freely available for modification and redistribution. Kotlin is primarily made by JetBrains, but now there is the Kotlin Foundation, which promotes and advances the development of this language. There is also a public process known as KEEP, which allows anyone to see and comment on official design change propositions.
              * Multiplatform means that a language can be used on more than one platform. For instance, Kotlin can be used both on Android and iOS.
              * Multi-paradigm means that a language has support for more than one programming paradigm. Kotlin has powerful support for both Object-Oriented Programming and Functional Programming.
              * Statically typed means that each variable, object, and function has an associated type that is known at compile time.
              * General-purpose means that a language is designed to be used for building software in a wide variety of application domains across a multitude of hardware configurations and operating systems.
          - type: "question-single-answer"
            stepId: "lesson-01_what_is_kotlin-{sample:-true}-q1"
            question: "In Kotlin, what does “statically typed” mean?"
            explanation: "In a statically typed language, types are known and checked at\
        \ compile time. Kotlin still has type inference, but inferred types are resolved\
        \ at compile time."
            repeatable: true
            answers:
              - "Types are known and checked at compile time"
              - "Types are checked only at runtime"
              - "Variables can change type after assignment"
              - "The language doesn’t support generics"
            correct: "Types are known and checked at compile time"
          - type: "question-multiple-answer"
            stepId: "lesson-01_what_is_kotlin-{sample:-true}-q2"
            question: "Which statements correctly reflect the text about Kotlin?"
            explanation: "The text states Kotlin is open-source (compiler sources available),\
        \ multi-paradigm (OOP and FP), and multiplatform (e.g., Android and iOS).\
        \ It’s not proprietary and not developed solely by Google."
            repeatable: false
            answers:
              - "Kotlin can be used on both Android and iOS"
              - "Kotlin supports both OOP and FP"
              - "Kotlin compiler sources are available for modification and redistribution"
              - "Kotlin is proprietary and closed-source"
              - "Kotlin is developed solely by Google"
            correct:
              - "Kotlin can be used on both Android and iOS"
              - "Kotlin supports both OOP and FP"
              - "Kotlin compiler sources are available for modification and redistribution"
          - type: "text"
            stepId: "lesson-01_what_is_kotlin-kotlin-platforms-text"
            repeatable: false
            text: |-
              Kotlin is a compiled programming language. This means that you can write some code in Kotlin and then use the Kotlin compiler to produce code in a lower-level language. Kotlin can currently be compiled into JVM bytecode (Kotlin/JVM), JavaScript (Kotlin/JS), or machine code (Kotlin/Native).
              
              ![](kotlin_compile_results.png)
              
              I would like to address all these compilation targets and, by default, show code that works on all of them, but I will concentrate on the most popular one: Kotlin/JVM.
              
              Kotlin/JVM is the technology that’s used to compile Kotlin code into JVM bytecode. The result is nearly identical to the result of compiling Java code into JVM bytecode. We also use the term “Kotlin/JVM” to talk about code that will be compiled into JVM bytecode.
              
              ![](Kotlin_Java_compile.png)
              
              Kotlin/JVM and Java are fully interoperable. Any code written in Java can be used in Kotlin/JVM. Any Java library, including those based on annotation processing, can be used in Kotlin/JVM. Kotlin/JVM can use Java classes, modules, libraries, and the Java standard library. Any Kotlin/JVM code can be used in Java (except for suspending functions, which are a support for Kotlin Coroutines).
              
              ![](Java_interoperability.png)
              
              Kotlin and Java can be mixed in a single project. A typical scenario is that a project was initially developed in Java, but then its creators decided to start using Kotlin. To do this, instead of migrating the whole project, these developers decided to add Kotlin to it. So, whenever they add a new file, it will be a Kotlin file; furthermore, when they refactor old Java code, they will migrate it to Kotlin. Over time, there is more and more Kotlin code until it excludes Java completely.
              
              ![](mix_Kotlin_Java.png)
              
              One example of such a project is the Kotlin compiler itself. It was initially written in Java, but more and more files were migrated to Kotlin when it became stable enough. This process has been happening for years now; at the time of writing this course, the Kotlin compiler project still contains around 10% of Java code.
              
              Now that we understand the relationship between Kotlin and Java, it is time to fight some misconceptions. Many see Kotlin as a layer of syntactic sugar on top of Java, but this is not true. Kotlin is a different language than Java. It has its own conventions and practices, and it has features that Java does not have, like multiplatform capabilities and coroutines. You don’t need to know Java to understand Kotlin. In my opinion, Kotlin is a better first language than Java. Junior Kotlin developers do not need to know what the `equals` method is and how to override it. For them, it is enough to know the default class and data class equality. They don’t need to learn to write getters and setters, or how to implement a singleton or a builder pattern. Kotlin has a lower entry threshold than Java and does not need the JVM platform.
          - type: "question-multiple-answer"
            stepId: "lesson-01_what_is_kotlin-kotlin-platforms-q1"
            question: "Which compilation targets are explicitly mentioned as supported by\
        \ Kotlin in this section?"
            explanation: "The section lists three targets: JVM bytecode (Kotlin/JVM), JavaScript\
        \ (Kotlin/JS), and machine code via Kotlin/Native. WebAssembly and Python\
        \ bytecode are not mentioned."
            repeatable: true
            answers:
              - "JVM bytecode (Kotlin/JVM)"
              - "JavaScript (Kotlin/JS)"
              - "Machine code (Kotlin/Native)"
              - "WebAssembly"
              - "Python bytecode"
            correct:
              - "JVM bytecode (Kotlin/JVM)"
              - "JavaScript (Kotlin/JS)"
              - "Machine code (Kotlin/Native)"
          - type: "question-multiple-answer"
            stepId: "lesson-01_what_is_kotlin-kotlin-platforms-q2"
            question: "Which statements about Kotlin/JVM and Java interoperability are correct\
        \ according to the section?"
            explanation: "Kotlin/JVM can use Java classes, the Java standard library, and\
        \ libraries relying on annotation processing. Java can call Kotlin/JVM code\
        \ except for suspending functions. Kotlin and Java can be mixed in one project."
            repeatable: true
            answers:
              - "Kotlin/JVM can directly use Java classes and the Java standard library"
              - "Java code can call Kotlin suspending functions without any extra support"
              - "Kotlin/JVM can use Java libraries that rely on annotation processing"
              - "Kotlin and Java sources can coexist in a single project"
              - "Kotlin code cannot be consumed from Java"
            correct:
              - "Kotlin/JVM can directly use Java classes and the Java standard library"
              - "Kotlin/JVM can use Java libraries that rely on annotation processing"
              - "Kotlin and Java sources can coexist in a single project"
          - type: "text"
            stepId: "lesson-01_what_is_kotlin-the-kotlin-ide-text"
            repeatable: false
            text: "The most popular Kotlin IDEs (integrated development environments) are\
        \ IntelliJ IDEA and Android Studio. However, you can also write programs in\
        \ Kotlin using VS Code, Eclipse, Vim, Emacs, Sublime Text, and many more.\
        \ You can also write Kotlin code online, for instance, using the official\
        \ online IDE that can be found at this link [play.kotlinlang.org](play.kotlinlang.org/)."
          - type: "question-multiple-answer"
            stepId: "lesson-01_what_is_kotlin-the-kotlin-ide-q1"
            question: "Which of the following tools are mentioned in the text as environments\
        \ where you can write Kotlin code?"
            explanation: "The text lists IntelliJ IDEA, Android Studio, VS Code, and Eclipse\
        \ as environments for Kotlin; Xcode is not mentioned."
            repeatable: false
            answers:
              - "IntelliJ IDEA"
              - "Android Studio"
              - "VS Code"
              - "Eclipse"
              - "Xcode"
            correct:
              - "IntelliJ IDEA"
              - "Android Studio"
              - "VS Code"
              - "Eclipse"
          - type: "question-single-answer"
            stepId: "lesson-01_what_is_kotlin-the-kotlin-ide-q2"
            question: "What is the official online Kotlin IDE mentioned in the text?"
            explanation: "The official online IDE is at play.kotlinlang.org."
            repeatable: false
            answers:
              - "play.kotlinlang.org"
              - "try.kotlinlang.org"
              - "kotlinlang.org/play"
              - "kotlinfiddle.com"
            correct: "play.kotlinlang.org"
          - type: "text"
            stepId: "lesson-01_what_is_kotlin-where-do-we-use-kotlin?-text"
            repeatable: false
            text: |-
              Kotlin can be used as an alternative to Java, JavaScript, C++, Objective-C, etc. However, it is most mature on JVM, so it is currently mainly used as an alternative to Java.
              
              Kotlin has become quite popular for backend development. I most often see it used with the Spring framework, but some projects use Kotlin with backend frameworks like Vert.x, Ktor, Micronaut, http4k or Javalin.
              
              Kotlin has also practically become the standard language for Android development. Google has officially suggested that all Android applications should be written in Kotlin and has announced that all their APIs will be designed primarily for Kotlin.
              
              More and more projects are now taking advantage of the fact that Kotlin can be compiled for a few different platforms because this means that teams can write code that runs on both Android and iOS, or on both the backend and the frontend. Moreover, this cross-platform compatibility means that library creators can create one library for multiple platforms at the same time. Kotlin’s multiplatform capabilities are already being used in many companies, and they are getting more and more popular.
              
              It is also worth mentioning Jetpack Compose, which is a toolkit for building native UIs in Kotlin. It was initially developed for Android, but it uses Kotlin’s multiplatform capabilities and can also be used to create views for websites, desktop applications, iOS applications, and other targets.
              
              A lot of developers are using Kotlin for front-end development, mainly using React, and there is also a growing community of data scientists using Kotlin.
              
              As you can see, there is already a lot that you can do in Kotlin, and there are more and more possibilities as each year passes. I am sure you will find good ways to apply your new knowledge.
          - type: "question-multiple-answer"
            stepId: "lesson-01_what_is_kotlin-where-do-we-use-kotlin?-q1"
            question: "Which of the following are commonly used with Kotlin for backend\
        \ development?"
            explanation: "Spring, Ktor, Micronaut, and Javalin are server-side frameworks\
        \ frequently used with Kotlin; React is primarily for frontend (Kotlin/JS)."
            repeatable: true
            answers:
              - "Spring"
              - "Ktor"
              - "React"
              - "Micronaut"
              - "Javalin"
            correct:
              - "Spring"
              - "Ktor"
              - "Micronaut"
              - "Javalin"
          - type: "question-multiple-answer"
            stepId: "lesson-01_what_is_kotlin-where-do-we-use-kotlin?-q2"
            question: "Select all true statements about Kotlin Multiplatform and Jetpack\
        \ Compose."
            explanation: "Kotlin Multiplatform enables sharing code across Android/iOS and\
        \ lets library authors target multiple platforms. Compose started on Android\
        \ and now targets desktop/web/iOS via KMP. Kotlin does not compile only to\
        \ JVM, and KMP is used in production by many companies."
            repeatable: true
            answers:
              - "Kotlin Multiplatform lets teams share code between Android and iOS."
              - "Kotlin compiles only to JVM bytecode, so sharing with iOS isn't possible."
              - "Library authors can publish a single library targeting multiple platforms."
              - "Compose began on Android and now targets desktop/web/iOS via KMP."
              - "Kotlin Multiplatform is only experimental and not used in companies."
            correct:
              - "Kotlin Multiplatform lets teams share code between Android and iOS."
              - "Library authors can publish a single library targeting multiple platforms."
              - "Compose began on Android and now targets desktop/web/iOS via KMP."
      - lessonId: "lesson-your-first-program-in-kotlin"
        name: "Your first program in Kotlin"
        steps:
          - type: "text"
            stepId: "lesson-02_first_program-{sample:-true}-text"
            repeatable: false
            text: |-
              # Your first program in Kotlin
              
              The first step in our Kotlin adventure is to write a minimal program in this language. Yes, it’s the famous "Hello, World!" program. This is what it looks like in Kotlin:
              
              ```kotlin
              fun main() {
                  println("Hello, World")
              }
              ```
              
              This is minimal, isn't it? We need no classes (like we do in Java), no objects (like `console` in JavaScript), and no conditions (like in Python when we start code in the IDE). We need the `main` function and the `println` function call with some text.
              
              This is the most popular (but not the only) variant of the "main" function. If we need arguments, we might include a parameter of type `Array<String>`:
              
              ```kotlin
              fun main(args: Array<String>) {
                  println("Hello, World")
              }
              ```
              
              There are also other forms of the `main` function:
              
              ```kotlin
              fun main(vararg args: String) {
                  println("Hello, World")
              }
              ```
              
              ```kotlin
              class Test {
                  companion object {
                      @JvmStatic
                      fun main(args: Array<String>) {
                          println("Hello, World")
                      }
                  }
              }
              ```
              
              ```kotlin
              suspend fun main() {
                  println("Hello, World")
              }
              ```
              
              Although these are all valid, let's concentrate on the simple `main` function as we will find it most useful. I will use it in nearly every example. Such examples are usually completely executable if you just copy-paste them into IntelliJ or the Online Kotlin Playground.
              
              ```kotlin
              fun main() {
                  println("Hello, World")
              }
              ```
              
              All you need to do to start the `main` function in IntelliJ is click the green triangle which appears on the left side of the `main` function; this is called the "gutter icon", also known as the "Run" button.
              
              ![](main_run.png)
          - type: "question-multiple-answer"
            stepId: "lesson-02_first_program-{sample:-true}-q1"
            question: "Which of the following are valid Kotlin/JVM entry point declarations\
        \ (recognized as the program's main function) as shown in the section?"
            explanation: "Kotlin recognizes top-level `main` with no args, `Array\\<String\\>`,\
        \ or `vararg String`; `suspend fun main()` is also supported. A companion\
        \ object's `@JvmStatic` main is a valid JVM entry point. `List\\<String\\>` is\
        \ not a valid entry point parameter type."
            repeatable: true
            answers:
              - "`fun main()`"
              - "`fun main(args: Array\\<String\\>)`"
              - "`fun main(vararg args: String)`"
              - |-
                ```
                class Test {
                    companion object {
                        @JvmStatic
                        fun main(args: Array<String>) { }
                    }
                }
                ```
              - "`suspend fun main()`"
              - "`fun main(args: List\\<String\\>)`"
            correct:
              - "`fun main()`"
              - "`fun main(args: Array\\<String\\>)`"
              - "`fun main(vararg args: String)`"
              - |-
                ```
                class Test {
                    companion object {
                        @JvmStatic
                        fun main(args: Array<String>) { }
                    }
                }
                ```
              - "`suspend fun main()`"
          - type: "question-single-answer"
            stepId: "lesson-02_first_program-{sample:-true}-q2"
            question: "You decide to place `main` inside a class's companion object. What\
        \ is required for the JVM to recognize it as the entry point?"
            explanation: "Inside a companion object, `main` must be exposed as a static\
        \ JVM method; `@JvmStatic` generates the needed static method."
            repeatable: false
            answers:
              - "Annotate `main` with `@JvmStatic`"
              - "Use `vararg` in the parameter list"
              - "Mark the class as `data class`"
              - "Annotate the companion object with `@Main`"
            correct: "Annotate `main` with `@JvmStatic`"
          - type: "text"
            stepId: "lesson-02_first_program-live-templates-text"
            repeatable: false
            text: |-
              If you decide to test or practice the material from this course, you will likely be writing the `main` function quite often. Here come *live templates* to help us. This is an IntelliJ feature that suggests using a template when you start typing its name in a valid context. So, if you start typing "main" or "maina" (for main with arguments) in a Kotlin file, you will be shown a suggestion that offers the whole `main` function.
              
              ![](main_template.png)
              
              In most my workshops, I’ve used this template hundreds of times. Whenever I want to show something new with live coding, I open a "Playground" file, select all its content (Ctrl/command + A), type "main", confirm the live template with Enter, and I have a perfect space for showing how Kotlin works.
              
              I also recommend you test this now. Open any Kotlin project (it is best if you have a dedicated project for playing with Kotlin), create a new file (you can name it "Test" or "Playground"), and create the `main` function with the live template “maina”. Use the `print` function with some text, and run the code with the Run button.
          - type: "question-single-answer"
            stepId: "lesson-02_first_program-live-templates-q1"
            question: "In IntelliJ IDEA for Kotlin, which live template inserts a `main`\
        \ function that accepts command-line arguments?"
            explanation: "The Kotlin live template “maina” expands to `fun main(args: Array<String>)\
        \ {}`. “main” is the no-arg entry point; “psvm” is a Java template; “kmain”\
        \ doesn’t exist by default."
            repeatable: false
            answers:
              - "main"
              - "maina"
              - "psvm"
              - "kmain"
            correct: "maina"
          - type: "question-single-answer"
            stepId: "lesson-02_first_program-live-templates-q2"
            question: "What IntelliJ IDEA feature lets you type an abbreviation like “main”\
        \ in a Kotlin file and expand it into a full code snippet by pressing Enter?"
            explanation: "Live Templates expand predefined snippets like `main`/`maina`.\
        \ Postfix completion operates on existing expressions (e.g., `.if`), Surround\
        \ With wraps selected code, and Code Generation (Alt+Insert) creates members\
        \ via a dialog."
            repeatable: false
            answers:
              - "Live Templates"
              - "Postfix completion"
              - "Surround With"
              - "Code Generation (Alt+Insert)"
            correct: "Live Templates"
          - type: "text"
            stepId: "lesson-02_first_program-what-is-under-the-hood-on-jvm?-text"
            repeatable: false
            text: |-
              The most important target for Kotlin is JVM (Java Virtual Machine). On JVM, every element needs to be in a class. So, you might be wondering how it is possible that our main function can be started there if it is not in a class. Let's figure it out. On the way, we will learn to find out what our Kotlin code would look like if it were written in Java. This is Java developers’ most powerful tool for learning how Kotlin works.
              
              Let's start by opening or starting a Kotlin project in IntelliJ or Android Studio. Make a new Kotlin file called "Playground". Inside this, use the live template "maina" to create the main function with arguments and add `println("Hello, World")` inside.
              
              ```kotlin
              fun main(args: Array<String>) {
                  println("Hello, World")
              }
              ```
              
              Now, select from the tabs Tools > Kotlin > Show Kotlin Bytecode.
              
              ![](tools_kotlin_show_bytecode.png)
              
              On the right side, a new tool should open. "Show Kotlin Bytecode" shows the JVM bytecode generated from this file.
              
              ![](show_kotlin_bytecode.png)
              
              This is a great place for everyone who likes reading JVM bytecode. Since not everyone is Jake Wharton, most of us might find the "Decompile" button useful. What it does is quite funny. We’ve just compiled our Kotlin code into JVM bytecode, and this button decompiles this bytecode into Java. As a result, we can see what our code would look like if it were written in Java.
              
              ![](hello_world_decompiled.png)
              
              This code reveals that our `main` function on JVM becomes a static function inside a class named `PlaygroundKt`. Where does this name come from? Try to guess. Yes, this is, by default, the file's name with the "Kt" suffix. The same happens to all other functions and properties defined outside of classes on JVM.
              
              If we wanted to call our `main` function from Java code, we can call `PlaygroundKt.main({})`.
              
              The name of `PlaygroundKt` can be changed by adding the `@file:JvmName("NewName")` annotation at the top of the file. However, this does not change how elements defined in this file are used in Kotlin. It only influences how we will use such functions from Java. For example, to call our `main` function from Java now, we would need to call `NewName.main({})`.
              
              If you have experience with Java, remember this tool as it can help you to understand:
              - How Kotlin code works on a low level.
              - How a certain Kotlin feature works under the hood.
              - How to use a Kotlin element in Java.
              
              There are proposals to make a similar tool to show JavaScript generated from Kotlin code when our target is Kotlin/JS. However, at the time of writing this book, the best you can do is to open the generated files yourself.
          - type: "question-single-answer"
            stepId: "lesson-02_first_program-what-is-under-the-hood-on-jvm?-q1"
            question: |-
              Given file name is `Report.kt` and it contains a top-level function:
              
              ```kotlin
              fun generate() { }
              ```
              No packages and no annotations are used. From Java, which call targets this function?
            explanation: "Top-level Kotlin functions on JVM become static methods in a synthetic\
        \ class named `<FileName>Kt`. Without annotations, Java calls `ReportKt.generate()`."
            repeatable: true
            answers:
              - "Report.generate()"
              - "ReportKt.generate()"
              - "KotlinReport.generate()"
              - "NewName.generate()"
            correct: "ReportKt.generate()"
          - type: "question-single-answer"
            stepId: "lesson-02_first_program-what-is-under-the-hood-on-jvm?-q2"
            question: "You have `Playground.kt` with a top-level `main` function. After\
        \ adding `@file:JvmName(\"NewName\")` at the top, what changes?"
            explanation: "`@file:JvmName` changes only the generated JVM class name used\
        \ from Java. Kotlin usage is unchanged."
            repeatable: true
            answers:
              - "In Kotlin, call sites must change to `NewName.main(...)`"
              - "In Java, you call `NewName.main(...)` instead of `PlaygroundKt.main(...)`"
              - "Both Kotlin and Java call sites must change"
              - "It moves functions to a package named `NewName`"
            correct: "In Java, you call `NewName.main(...)` instead of `PlaygroundKt.main(...)`"
          - type: "text"
            stepId: "lesson-02_first_program-packages-and-importing-text"
            repeatable: false
            text: "When our project has more than one file, we need to use packages to organize\
        \ them. Packages are a way to group files together and avoid name conflicts.\
        \ \n\nA file can specify package at the top of the file using the `package`\
        \ keyword.\n\n```kotlin\npackage com.marcinmoskala.domain.model\n\nclass User(val\
        \ name: String)\n```\n\nIf we don't specify a package, the file is in the\
        \ default package. In real projects, it is recommended that package path should\
        \ be the same as the directory path in our source files. Package can also\
        \ include company domain in reverse order, like `com.marcinmoskala`. We name\
        \ package using lowercase characters only. \n\nIf we want to use a function\
        \ or class from another package, we need to import it. Imports are declared\
        \ after the package declaration and before file elements' declaration. They\
        \ first specify the package name, then the name of the element. We can also\
        \ use the `*` character to import all elements from a package.\n\n```kotlin\n\
        package com.marcinmoskala.domain\n\nimport com.marcinmoskala.domain.model.User\n\
        // or \nimport com.marcinmoskala.domain.model.*\n\nfun useUser() {\n    val\
        \ user = User(\"Marcin\")\n    // ...\n}\n```\n\nEssential elements from Kotlin\
        \ and Java strandard libraries are imported by default. For example, we can\
        \ use `println` function without importing it. \n\nKotlin's developers rarely\
        \ think about imports, because IntelliJ manage them automatically. When you\
        \ use an element using IntelliJ suggestion, it will automatically add an import\
        \ for you. If you use an element that is not imported, IntelliJ will suggest\
        \ importing it. If you want to remove unused imports, you can use the \"Remove\
        \ unused imports\" action (Ctrl/command + Alt + O). That is also why I decided\
        \ to not show imports in most of the examples."
          - type: "question-multiple-answer"
            stepId: "lesson-02_first_program-packages-and-importing-q1"
            question: "Assume class `User` is declared in package `com.marcinmoskala.domain.model`.\
        \ You are writing `UseUser.kt` in package `com.marcinmoskala.domain`. Which\
        \ file header(s) let you use `User` without fully qualifying it? (Choose all\
        \ that apply)"
            explanation: "Imports must come after the package declaration and before declarations.\
        \ You can import a single symbol or use a star import. Placing import before\
        \ package is invalid; using the wrong package or no import won’t make `User`\
        \ visible."
            repeatable: true
            answers:
              - |-
                ```kotlin
                package com.marcinmoskala.domain
                
                import com.marcinmoskala.domain.model.User
                ```
              - |-
                ```kotlin
                import com.marcinmoskala.domain.model.User
                
                package com.marcinmoskala.domain
                ```
              - |-
                ```kotlin
                package com.marcinmoskala.domain
                
                import com.marcinmoskala.domain.model.*
                ```
              - |-
                ```kotlin
                package com.marcinmoskala.domain.model
                // no import
                ```
              - |-
                ```kotlin
                package com.marcinmoskala.domain
                // no import
                ```
            correct:
              - |-
                ```kotlin
                package com.marcinmoskala.domain
                
                import com.marcinmoskala.domain.model.User
                ```
              - |-
                ```kotlin
                package com.marcinmoskala.domain
                
                import com.marcinmoskala.domain.model.*
                ```
          - type: "question-single-answer"
            stepId: "lesson-02_first_program-packages-and-importing-q2"
            question: "Which package name follows Kotlin conventions mentioned in the text?"
            explanation: "Package names should be lowercase and typically use reversed domain\
        \ names. Slashes are invalid; mixed-case is discouraged."
            repeatable: false
            answers:
              - "com.Example.App"
              - "com.example.app.domain"
              - "example.com.app"
              - "com/example/app"
            correct: "com.example.app.domain"
          - type: "text"
            stepId: "lesson-02_first_program-summary-text"
            repeatable: false
            text: "We've learned about using `main` functions and creating them easily with\
        \ live templates. We’ve also learned how to find out what our Kotlin code\
        \ would look like if it were written in Java. For me, it seems like we have\
        \ quite a nice toolbox for starting our adventure. So, without further ado,\
        \ let's get on with that."
          - type: "question-multiple-answer"
            stepId: "lesson-02_first_program-summary-q1"
            question: "Which top-level function declarations are valid JVM entry points\
        \ for a Kotlin application? Choose all that apply."
            explanation: "On JVM, Kotlin recognizes `fun main()`, `fun main(args: Array<String>)`,\
        \ and `suspend fun main()` as valid entry points. Using `List<String>` or\
        \ `Array<Any>` does not match the required signature."
            repeatable: true
            answers:
              - "`fun main()`"
              - "`fun main(args: Array<String>)`"
              - "`suspend fun main()`"
              - "`fun main(args: List<String>)`"
              - "`fun main(args: Array<Any>)`"
            correct:
              - "`fun main()`"
              - "`fun main(args: Array<String>)`"
              - "`suspend fun main()`"
          - type: "question-single-answer"
            stepId: "lesson-02_first_program-summary-q2"
            question: "In IntelliJ IDEA, how can you see what your Kotlin code would look\
        \ like as Java?"
            explanation: "Use IntelliJ's Kotlin Bytecode viewer and its built-in decompiler:\
        \ Tools > Kotlin > Show Kotlin Bytecode, then click Decompile."
            repeatable: false
            answers:
              - "Tools > Kotlin > Show Kotlin Bytecode, then Decompile"
              - "Right-click file > Convert to Java"
              - "Build > Recompile as Java"
              - "Analyze > Infer nullity annotations"
            correct: "Tools > Kotlin > Show Kotlin Bytecode, then Decompile"
      - lessonId: "lesson-variables"
        name: "Variables"
        steps:
          - type: "text"
            stepId: "lesson-03_variables-#-variables-text"
            repeatable: false
            text: |-
              To declare a variable in Kotlin, we start with the `val` or `var` keyword, then a variable name, the equality sign, and an initial value.
              * The keyword `var` (which stands for "variable") represents *read-write variables* and is used to define variables whose values can be reassigned after initialization. This means that if you use `var`, you can always assign a new value to this variable.
              * The keyword `val` (which stands for "value") represents *read-only variables* and is used to define values that cannot be reassigned. This means that if you use `val`, you cannot assign a new value to this variable once it is initialized.
              
              ```kotlin
              fun main() {
                  val a = 10
                  var b = "ABC"
                  println(a) // 10
                  println(b) // ABC
                  // a = 12 is not possible, because a is read-only!
                  b = "CDE"
                  println(b) // CDE
              }
              ```
              
              We can name variables using characters, underscore `_`, and numbers (but numbers are not allowed at the first position). By convention, we name variables with the camelCase convention; this means the variable name starts with a lowercase letter, then (instead of using spaces) each next word starts with a capital letter.
              
              {width: 50%}
              ![In Kotlin, we name variables using camelCase.](camelCase.png)
              
              Variables don’t need to specify their type explicitly, but this doesn't mean that variables are not typed. Kotlin is a statically typed language, therefore every variable needs its type specified. The point is that Kotlin is smart enough to infer the type from the value that is set. `10` is of type `Int`, so the type of `a` in the above example is `Int`. `"ABC"` is of type `String`, so the type of `b` is `String`.
              
              {width: 60%}
              ![](104_inference.png)
              
              We can also specify a variable type explicitly using a colon and a type **after** the variable name.
              
              ```kotlin
              fun main() {
                 val a: Int = 10
                 var b: String = "ABC"
                 println(a) // 10
                 println(b) // ABC
                 b = "CDE"
                 println(b) // CDE
              }
              ```
              
              When we initialize a variable, we should give it a value. As in the example below, a variable’s definition and initialization can be separated if Kotlin can be sure that the variable won’t be used before any value is set. I suggest avoiding this practice when it’s not necessary.
              
              ```kotlin
              fun main() {
                  val a: Int
                  a = 10
                  println(a) // 10
              }
              ```
              
              We can assume that a variable should normally be initialized by using an equality sign after its declaration (like in `val a = 10`). So, what can stand on the right side of the assignment? It can be any expression, i.e., a piece of code that returns a value. Here are the most common types of expressions in Kotlin:
              * a basic type literal, like `1` or `"ABC"`,
              * a conditional statement used as an expression, like if-expression, when-expression, or try-catch expression.
              * a constructor call,
              * a function call,
              * an object expression or an object declaration,
              * a function literal, like a lambda expression, an anonymous function, or a function reference,
              * an element reference.
              
              We have a lot to discuss, so let's start with basic type literals.
          - type: "question-single-answer"
            stepId: "lesson-03_variables-#-variables-q1"
            question: "Which declaration uses the correct Kotlin syntax for specifying a\
        \ variable’s explicit type?"
            explanation: "In Kotlin, the type annotation goes after the name using a colon:\
        \ `val a: Int = 10`."
            repeatable: false
            answers:
              - "val a: Int = 10"
              - "Int a = 10"
              - "val: Int a = 10"
              - "val a = 10: Int"
              - "var Int a = 10"
            correct: "val a: Int = 10"
          - type: "question-multiple-answer"
            stepId: "lesson-03_variables-#-variables-q2"
            question: "Which snippets compile successfully?"
            explanation: "- A: `val` cannot be reassigned. - B: Local `var` can be declared\
        \ without init and assigned before use. - C: Using `n` before assignment is\
        \ illegal. - D: Type is inferred as `Int`, cannot assign `String`. - E: Local\
        \ `val` may be assigned exactly once later, before any use."
            repeatable: true
            answers:
              - |-
                ```kotlin
                fun f() {
                    val x = 1
                    x = 2
                }
                ```
              - |-
                ```kotlin
                fun f() {
                    var s: String
                    s = "OK"
                    println(s)
                }
                ```
              - |-
                ```kotlin
                fun f() {
                    val n: Int
                    println(n)
                    n = 10
                }
                ```
              - |-
                ```kotlin
                fun f() {
                    var a = 5
                    a = "5"
                }
                ```
              - |-
                ```kotlin
                fun f() {
                    val y: Int
                    y = 3
                }
                ```
            correct:
              - |-
                ```kotlin
                fun f() {
                    var s: String
                    s = "OK"
                    println(s)
                }
                ```
              - |-
                ```kotlin
                fun f() {
                    val y: Int
                    y = 3
                }
                ```
      - lessonId: "lesson-basic-types,-their-literals-and-operations"
        name: "Basic types, their literals and operations"
        steps:
          - type: "text"
            stepId: "lesson-04_basic_values-#-basic-types,-their-literals-and-operations-text"
            repeatable: false
            text: |-
              Every language needs a convenient way to represent basic kinds of values, like numbers or characters. All languages need to have built-in **types** and **literals**. Types are used to represent certain types of values. Some type examples are `Int`, `Boolean`, or `String`. Literals are built-in notations that are used to create instances. Some literal examples are a string literal, which is text in quotation marks, or an integer literal, which is a bare number.
              
              In this chapter, we’ll learn about the basic Kotlin types and their literals:
              * numbers (`Int`, `Long`, `Double`, `Float`, `Short`, `Byte`),
              * booleans (`Boolean`),
              * characters (`Char`),
              * strings (`String`).
              
              There is also the array primitive type in Kotlin, which will be covered in the chapter *Collections*.
              
              In Kotlin, all values are considered objects (there are no primitive types), so they all have methods, and their types can be used as generic type arguments (this will be covered later). Types that represent numbers, booleans, and characters might be optimized by the Kotlin compiler and used as primitives, but this optimization does not affect Kotlin developers, therefore you don’t need to even think about it.
              
              Let's start discussing the basic types in Kotlin, one by one.
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-#-basic-types,-their-literals-and-operations-q1"
            question: "In Kotlin, which statement about primitives and objects is correct?"
            explanation: "Kotlin has no primitive types at the language level. The compiler\
        \ may optimize numeric/boolean/char types to primitives, but types like Int,\
        \ Boolean, and Char are always used as regular types (e.g., as generic arguments)."
            repeatable: true
            answers:
              - "All values are objects; numeric/boolean/char types may be optimized to platform\
        \ primitives, but this is invisible at the source level."
              - "Kotlin has distinct primitive and reference types like Java, and you must\
        \ choose which to use."
              - "You cannot use Int as a generic type argument because it's a primitive."
              - "Only String and Array are objects; numbers/booleans/chars are primitives."
            correct: "All values are objects; numeric/boolean/char types may be optimized\
        \ to platform primitives, but this is invisible at the source level."
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-#-basic-types,-their-literals-and-operations-q2"
            question: "Which of the following are literals in Kotlin source code?"
            explanation: "Literals are built-in notations that directly create values: integer\
        \ (123), float (1.0f), char ('A'), and string (\"Int\"). Names like Int and\
        \ Boolean are type identifiers, not literals."
            repeatable: true
            answers:
              - "Int"
              - "123"
              - "1.0f"
              - "'A'"
              - "\"Int\""
              - "Boolean"
            correct:
              - "123"
              - "1.0f"
              - "'A'"
              - "\"Int\""
          - type: "text"
            stepId: "lesson-04_basic_values-numbers-text"
            repeatable: false
            text: |-
              In Kotlin, there is a range of different types that are used to represent numbers. They can be divided into those representing integer numbers (without decimal points) and those representing floating-point numbers (with decimal points). In these groups, the difference is in the number of bits used to represent these numbers, which determines the possible number size and precision.
              
              To represent integer numbers, we use `Int`, `Long`, `Byte`, and `Short`.
              
              | Type    | Size (bits) | Min value  | Max value     |
              |---------|-------------|------------|---------------|
              | `Byte`  | 8           | -128       | 127           |
              | `Short` | 16          | -32768     | 32767         |
              | `Int`   | 32          | `-2^{31}`$ | `2^{31} - 1`$ |
              | `Long`  | 64          | `-2^{63}`$ | `2^{63} - 1`$ |
              
              To represent floating-point numbers, we use `Float` and `Double`.
              
              | Type     | Size (bits) | Significant bits | Exponent bits | Decimal digits |
              |----------|-------------|------------------|---------------|----------------|
              | `Float`  | 32          | 24               | 8             | 6-7            |
              | `Double` | 64          | 53               | 11            | 15-16          |
              
              A plain number without a decimal point is interpreted as an `Int`. A plain number with a decimal point is interpreted as a `Double`.
              
              ![](05_int_double.png)
              
              You can create `Long` by using the `L` suffix after the number. `Long` is also used for number literals that are too big for `Int`.
              
              ![](05_long.png)
              
              Similarly, you can create a `Float` by ending a number with the `F` or `f` suffix.
              
              ![](05_float.png)
              
              There is no suffix to create `Byte` or `Short` types. However, a number explicitly typed as one of these types will create an instance of this type. This also works for `Long`.
              
              ```kotlin
              fun main() {
                  val b: Byte = 123
                  val s: Short = 345
                  val l: Long = 345
              }
              ```
              
              This is not a conversion! Kotlin does not support implicit type conversion, so you cannot use `Byte` or `Long` where `Int` is expected.
              
              ![](05_int_long_error.png)
              
              If we need to explicitly convert one number to another type, we use explicit conversion functions like `toInt` or `toLong`.
              
              ```kotlin
              fun main() {
                  val b: Byte = 123
                  val l: Long = 123L
                  val i: Int = 123
              
                  val i1: Int = b.toInt()
                  val i2: Int = l.toInt()
                  val l1: Long = b.toLong()
                  val l2: Long = i.toLong()
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-numbers-q1"
            question: "Which declarations compile in Kotlin without errors (assume each\
        \ is inside a function)?"
            explanation: "Integer literals adapt to the expected type if the value fits\
        \ (e.g., Long, Short). 1.0 is Double by default; Float requires F/f. There\
        \ are no implicit conversions between numeric types (e.g., Long → Int, Float\
        \ → Double)."
            repeatable: true
            answers:
              - "val l: Long = 1"
              - "val f: Float = 1.0"
              - "val d: Double = 1F"
              - "val s: Short = 1000"
              - "val i: Int = 1L"
              - "val f2: Float = 1F"
            correct:
              - "val l: Long = 1"
              - "val s: Short = 1000"
              - "val f2: Float = 1F"
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-numbers-q2"
            question: "In Kotlin, what is the inferred type of the literal 3000000000 (no\
        \ suffix, no decimal point)?"
            explanation: "Plain integer literals are Int unless they don't fit; 3000000000\
        \ exceeds Int's max, so the literal is Long."
            repeatable: true
            answers:
              - "Int"
              - "Long"
              - "Double"
              - "Short"
            correct: "Long"
          - type: "text"
            stepId: "lesson-04_basic_values-underscores-in-numbers-text"
            repeatable: false
            text: |-
              In number literals, we can use the underscore `_` between digits. This character is ignored, but we sometimes use it to format long numbers for better readability.
              
              ```kotlin
              fun main() {
                  val million = 1_000_000
                  println(million) // 1000000
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-underscores-in-numbers-q1"
            question: "Which of the following Kotlin numeric literals are valid?"
            explanation: "Underscores may appear between digits (including in binary/hex\
        \ and the fractional part) but not at the start/end, not directly next to\
        \ a decimal point, and not immediately before a type suffix."
            repeatable: true
            answers:
              - "1_000_000"
              - "0b1101_0010"
              - "3.14_15"
              - "123_.456"
              - "_123"
            correct:
              - "1_000_000"
              - "0b1101_0010"
              - "3.14_15"
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-underscores-in-numbers-q2"
            question: "Which of the following Kotlin integer literal declarations compile?"
            explanation: "Underscores are allowed only between digits. They cannot appear\
        \ at the start or end of the literal, or next to a type suffix (`L`). Hex\
        \ (`0x`) and binary (`0b`) literals also allow underscores between digits."
            repeatable: true
            answers:
              - "val a: Int = 1_000_000"
              - "val b: Int = 1000_"
              - "val c: Long = 1234_L"
              - "val d = 0xFF_EC_DE_5E"
              - "val e = 0b1010_1010"
            correct:
              - "val a: Int = 1_000_000"
              - "val d = 0xFF_EC_DE_5E"
              - "val e = 0b1010_1010"
          - type: "text"
            stepId: "lesson-04_basic_values-other-numeral-systems-text"
            repeatable: false
            text: |-
              To define a number using the hexadecimal numeral system, start it with `0x`. To define a number using the binary numeral system, start it with `0b`. The octal numeral system is not supported.
              
              ```kotlin
              fun main() {
                  val hexBytes = 0xA4_D6_FE_FE
                  println(hexBytes) // 2765553406
                  val bytes = 0b01010010_01101101_11101000_10010010
                  println(bytes) // 1382934674
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-other-numeral-systems-q1"
            question: "Which Kotlin integer literals are valid and will compile?"
            explanation: "Kotlin supports hexadecimal (0x...) and binary (0b...) integer\
        \ literals; underscores are allowed between digits. Octal is not supported\
        \ (no 0o...), hex digits must be 0–9/A–F, binary digits must be 0/1, and a\
        \ prefix must be followed by at least one valid digit."
            repeatable: true
            answers:
              - "val a = 0xA4_D6_FE_FE"
              - "val b = 0b01010010_0110"
              - "val c = 0o77"
              - "val d = 0xFACE_B00K"
              - "val e = 0b1021"
              - "val f = 0x"
            correct:
              - "val a = 0xA4_D6_FE_FE"
              - "val b = 0b01010010_0110"
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-other-numeral-systems-q2"
            question: "Which prefix introduces a hexadecimal numeric literal in Kotlin?"
            explanation: "Hexadecimal literals use the 0x prefix; binary uses 0b; octal\
        \ is not supported."
            repeatable: false
            answers:
              - "0h"
              - "0b"
              - "0x"
              - "0o"
            correct: "0x"
          - type: "text"
            stepId: "lesson-04_basic_values-`number`-and-conversion-functions-text"
            repeatable: false
            text: |-
              All basic types that represent numbers are a subtype of the `Number` type.
              
              ```kotlin
              fun main() {
                  val i: Int = 123
                  val b: Byte = 123
                  val l: Long = 123L
              
                  val n1: Number = i
                  val n2: Number = b
                  val n3: Number = l
              }
              ```
              
              The `Number` type specifies transformation functions: from the current number to any other basic type representing a number.
              
              ```kotlin
              abstract class Number {
                  abstract fun toDouble(): Double
                  abstract fun toFloat(): Float
                  abstract fun toLong(): Long
                  abstract fun toInt(): Int
                  abstract fun toChar(): Char
                  abstract fun toShort(): Short
                  abstract fun toByte(): Byte
              }
              ```
              
              This means that for each basic number you can transform it into a different basic number using the `to{new type}` function. Such functions are known as *conversion functions*.
              
              ```kotlin
              fun main() {
                  val b: Byte = 123
                  val l: Long = b.toLong()
                  val f: Float = l.toFloat()
                  val i: Int = f.toInt()
                  val d: Double = i.toDouble()
                  println(d) // 123.0
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-`number`-and-conversion-functions-q1"
            question: "Which statements about Kotlin's Number and its conversion functions\
        \ are correct?"
            explanation: "All basic numeric types are subtypes of Number; Number declares\
        \ to{Type}() functions (including toChar()); Kotlin does not perform implicit\
        \ numeric widening, so explicit conversion is required."
            repeatable: false
            answers:
              - "Byte, Short, Int, Long, Float, and Double are subtypes of Number."
              - "You can call toInt(), toLong(), toFloat(), toDouble(), toShort(), toByte(),\
        \ and toChar() on any Number."
              - "Kotlin performs implicit widening conversions between numeric types in assignments."
              - "A Number value must be explicitly converted to a specific numeric type before\
        \ assigning to that type."
            correct:
              - "Byte, Short, Int, Long, Float, and Double are subtypes of Number."
              - "You can call toInt(), toLong(), toFloat(), toDouble(), toShort(), toByte(),\
        \ and toChar() on any Number."
              - "A Number value must be explicitly converted to a specific numeric type before\
        \ assigning to that type."
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-`number`-and-conversion-functions-q2"
            question: "Which function is NOT specified by Kotlin's abstract class Number?"
            explanation: "Number declares toDouble(), toFloat(), toLong(), toInt(), toShort(),\
        \ toByte(), and toChar(). Unsigned conversions like toUInt() are not part\
        \ of Number."
            repeatable: true
            answers:
              - "toChar()"
              - "toUInt()"
              - "toLong()"
              - "toDouble()"
            correct: "toUInt()"
          - type: "text"
            stepId: "lesson-04_basic_values-operations-on-numbers-text"
            repeatable: false
            text: "Numbers in Kotlin support the basic mathematical operations:\n* addition\
        \ (`+`),\n* subtraction (`-`),\n* multiplication (`*`),\n* division (`/`).\n\
        \n```kotlin\nfun main() {\n    val i1 = 12\n    val i2 = 34\n    println(i1\
        \ + i2) // 46\n    println(i1 - i2) // -22\n    println(i1 * i2) // 408\n\
        \    println(i1 / i2) // 0\n\n    val d1 = 1.4\n    val d2 = 2.5\n    println(d1\
        \ + d2) // 3.9\n    println(d1 - d2) // -1.1\n    println(d1 * d2) // 3.5\n\
        \    println(d1 / d2) // 0.5599999999999999\n}\n```\n\n> Notice, that the\
        \ correct result of `1.4 / 2.5` should be `0.56`, not `0.5599999999999999`.\
        \ This problem will be addressed soon. \n\nBeware that when we divide an `Int`\
        \ by an `Int`, the result is also `Int`, so the decimal part is lost.\n\n\
        ```kotlin\nfun main() {\n    println(5 / 2) // 2, not 2.5\n}\n```\n\nThe solution\
        \ is first to convert an integer into a floating-point representation and\
        \ then divide it.\n\n```kotlin\nfun main() {\n    println(5.toDouble() / 2)\
        \ // 2.5\n}\n```\n\nThere is also a remainder operator `%`:\n\n```kotlin\n\
        fun main() {\n    println(1 % 3) // 1\n    println(2 % 3) // 2\n    println(3\
        \ % 3) // 0\n    println(4 % 3) // 1\n    println(5 % 3) // 2\n    println(6\
        \ % 3) // 0\n    println(7 % 3) // 1\n    println(0 % 3) // 0\n    println(-1\
        \ % 3) // -1\n    println(-2 % 3) // -2\n    println(-3 % 3) // 0\n}\n```\n\
        \nKotlin also supports operations that modify a read-write variable `var`:\n\
        * `+=`, where `a += b` is the equivalent of `a = a + b`,\n* `-=`, where `a\
        \ -= b` is the equivalent of `a = a - b`,\n* `*=`, where `a *= b` is the equivalent\
        \ of `a = a * b`,\n* `/=`, where `a /= b` is the equivalent of `a = a / b`,\n\
        * `%=`, where `a %= b` is the equivalent of `a = a % b`,\n* post-incrementation\
        \ and pre-incrementation `++`, which increment variables value by `1`,\n*\
        \ post-decrementation and pre-decrementation `--`, which decrement variables\
        \ value by `1`.\n\n```kotlin\nfun main() {\n    var i = 1\n    println(i)\
        \ // 1\n    i += 10\n    println(i) // 11\n    i -= 5\n    println(i) // 6\n\
        \    i *= 3\n    println(i) // 18\n    i /= 2\n    println(i) // 9\n    i\
        \ %= 4\n    println(i) // 1\n\n    // Post-incrementation\n    // increments\
        \ value and returns the previous value\n    println(i++) // 1\n    println(i)\
        \ // 2\n\n    // Pre-incrementation\n    // increments value and returns the\
        \ new value\n    println(++i) // 3\n    println(i) // 3\n\n    // Post-decrementation\n\
        \    // decrements value and returns the previous value\n    println(i--)\
        \ // 3\n    println(i) // 2\n\n    // Pre-decrementation\n    // decrements\
        \ value and returns the new value\n    println(--i) // 1\n    println(i) //\
        \ 1\n}\n```"
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-operations-on-numbers-q1"
            question: "In Kotlin, which of the following print exactly 2?"
            explanation: "When both operands are Int, division is integer division. The\
        \ remainder operator returns the remainder with the same sign as the dividend.\
        \ Division with a Double produces a Double."
            repeatable: true
            answers:
              - "println(5 / 2)"
              - "println(5 / 2.0)"
              - "println(5 % 3)"
              - "println(-1 % 3)"
              - "println(7 / 3 + 1 % 3)"
            correct:
              - "println(5 / 2)"
              - "println(5 % 3)"
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-operations-on-numbers-q2"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  var a = 5
                  val b = 2
                  println(a / b)
                  println(a.toDouble() / b)
                  a += b
                  println(a)
                  a /= b
                  println(a)
              }
              ```
            explanation: "a / b is Int division (2). Converting a to Double yields 2.5.\
        \ After a += b, a is 7. Then a /= b performs Int division: 7 / 2 = 3."
            repeatable: false
            answers:
              - |-
                2
                2.5
                7
                3
              - |-
                2
                2.5
                7
                3.5
              - |-
                2.5
                2.5
                7
                3
              - |-
                2
                2.5
                5
                2
            correct: |-
              2
              2.5
              7
              3
          - type: "text"
            stepId: "lesson-04_basic_values-operations-on-bits-text"
            repeatable: false
            text: |-
              Kotlin also supports operations on bits using the following methods, which can be called using the infix notation (so, between two values):
              * `and` keeps only bits that have `1` in the same binary positions in both numbers.
              * `or` keeps only bits that have `1` in the same binary positions in one or both numbers.
              * `xor` keeps only bits that have exactly one `1` in the same binary positions in both numbers.
              * `shl` shifts the left value left by the right number of bits.
              * `shr` shifts the left value right by the right number of bits, filling the leftmost bits with copies of the sign bit.
              * `ushr` shifts the left value right by the right number of bits, filling the leftmost bits with zeros.
              
              ```kotlin
              fun main() {
                  println(0b0101 and 0b0001) // 1, that is 0b0001
                  println(0b0101 or 0b0001)  // 5, that is 0b0101
                  println(0b0101 xor 0b0001) // 4, that is 0b0100
                  println(0b0101 shl 1) // 10, that is 0b1010
                  println(0b0101 shr 1) // 2,  that is 0b0010
                  println(0b0101 ushr 1) // 2,  that is 0b0010
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-operations-on-bits-q1"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  val x = -0b0100
                  println(x shr 1)
                  println(x ushr 1)
              }
              ```
            explanation: "`shr` is an arithmetic right shift (sign bit is copied), so -4\
        \ shr 1 = -2. `ushr` is a logical right shift (zeros filled), so -4 ushr 1\
        \ = 0x7FFFFFFE = 2147483646."
            repeatable: true
            answers:
              - "First: -2; Second: 2147483646"
              - "First: -2; Second: -2"
              - "First: -2; Second: 2"
              - "First: -1; Second: 2147483647"
            correct: "First: -2; Second: 2147483646"
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-operations-on-bits-q2"
            question: "Which Kotlin expressions evaluate to the Int value 2?"
            explanation: |-
              - `0b0101 shr 1` = 0b0010 = 2
              - `0b1000 ushr 2` = 0b0010 = 2
              - `0b0110 and 0b0011` = 0b0010 = 2
              - `0b0101 and 0b0011` = 0b0001 = 1
              - `0b0011 shl 0` = 0b0011 = 3
            repeatable: false
            answers:
              - "`0b0101 and 0b0011`"
              - "`0b0101 shr 1`"
              - "`0b1000 ushr 2`"
              - "`0b0110 and 0b0011`"
              - "`0b0011 shl 0`"
            correct:
              - "`0b0101 shr 1`"
              - "`0b1000 ushr 2`"
              - "`0b0110 and 0b0011`"
          - type: "text"
            stepId: "lesson-04_basic_values-`bigdecimal`-and-`biginteger`-text"
            repeatable: false
            text: |-
              All basic types in Kotlin have limited size and precision, which can lead to imprecise or incorrect results in some situations.
              
              ```kotlin
              fun main() {
                  println(0.1 + 0.2) // 0.30000000000000004
                  println(2147483647 + 1) // -2147483648
              }
              ```
              
              This is a standard tradeoff in programming, and in most cases we just need to accept it. However, there are cases where we need to have perfect precision and unlimited number size. On JVM, for unlimited number size we should use `BigInteger`, which represents a number without a decimal part. For unlimited size and precision, we should use the `BigDecimal`, which represents a number that has a decimal part. Both can be created using constructors, factory functions (like `valueOf`), or a conversion from basic types that represent numbers (`toBigDecimal` and `toBigInteger` methods).
              
              ```kotlin
              import java.math.BigDecimal
              import java.math.BigInteger
              
              fun main() {
                  val i = 10
                  val l = 10L
                  val d = 10.0
                  val f = 10.0F
              
                  val bd1: BigDecimal = BigDecimal(123)
                  val bd2: BigDecimal = BigDecimal("123.00")
                  val bd3: BigDecimal = i.toBigDecimal()
                  val bd4: BigDecimal = l.toBigDecimal()
                  val bd5: BigDecimal = d.toBigDecimal()
                  val bd6: BigDecimal = f.toBigDecimal()
                  val bi1: BigInteger = BigInteger.valueOf(123)
                  val bi2: BigInteger = BigInteger("123")
                  val bi3: BigInteger = i.toBigInteger()
                  val bi4: BigInteger = l.toBigInteger()
              }
              ```
              
              `BigDecimal` and `BigInteger` also support basic mathematical operators:
              
              ```kotlin
              import java.math.BigDecimal
              import java.math.BigInteger
              
              fun main() {
                  val bd1 = BigDecimal("1.2")
                  val bd2 = BigDecimal("3.4")
                  println(bd1 + bd2) // 4.6
                  println(bd1 - bd2) // -2.2
                  println(bd1 * bd2) // 4.08
                  println(bd1 / bd2) // 0.4
              
                  val bi1 = BigInteger("12")
                  val bi2 = BigInteger("34")
                  println(bi1 + bi2) // 46
                  println(bi1 - bi2) // -22
                  println(bi1 * bi2) // 408
                  println(bi1 / bi2) // 0
              }
              ```
              
              On platforms other than Kotlin/JVM, external libraries are needed to represent numbers with unlimited size and precision.
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-`bigdecimal`-and-`biginteger`-q1"
            question: "On Kotlin/JVM, which snippets print exactly \"0.3\"?"
            explanation: "Using String ctor, BigDecimal.valueOf, or Double.toBigDecimal()\
        \ preserves the decimal 0.1 exactly. Using Double arithmetic or BigDecimal(Double)\
        \ suffers from binary floating-point artifacts."
            repeatable: true
            answers:
              - "println(BigDecimal(\"0.1\") + BigDecimal(\"0.2\"))"
              - "println(0.1.toBigDecimal() + 0.2.toBigDecimal())"
              - "println(BigDecimal.valueOf(0.1) + BigDecimal.valueOf(0.2))"
              - "println(BigDecimal(0.1) + BigDecimal(0.2))"
              - "println(0.1 + 0.2)"
            correct:
              - "println(BigDecimal(\"0.1\") + BigDecimal(\"0.2\"))"
              - "println(0.1.toBigDecimal() + 0.2.toBigDecimal())"
              - "println(BigDecimal.valueOf(0.1) + BigDecimal.valueOf(0.2))"
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-`bigdecimal`-and-`biginteger`-q2"
            question: |-
              What does this print on Kotlin/JVM?
              
              ```kotlin
              import java.math.BigInteger
              
              fun main() {
                  println(BigInteger("12") / BigInteger("34"))
              }
              ```
            explanation: "BigInteger division is integer division; the fractional part is\
        \ discarded, so 12/34 yields 0."
            repeatable: false
            answers:
              - "0"
              - "0.3529..."
              - "0.4"
              - "ArithmeticException"
              - "1"
            correct: "0"
          - type: "text"
            stepId: "lesson-04_basic_values-booleans-text"
            repeatable: false
            text: |-
              Another basic type is `Boolean`, which has two possible values: `true` and `false`.
              
              ```kotlin
              fun main() {
                  val b1: Boolean = true
                  println(b1) // true
                  val b2: Boolean = false
                  println(b2) // false
              }
              ```
              
              We use booleans to express yes/no answers, like:
              * Is the user an admin?
              * Has the user accepted the cookies policy?
              * Are two numbers identical?
              
              In practice, booleans are often a result of some kind of comparison.
          - type: "text"
            stepId: "lesson-04_basic_values-equality-text"
            repeatable: false
            text: |-
              A `Boolean` is often a result of equality comparison. In Kotlin, we compare two objects for equality using the double equality sign `==`. To check if two objects are not equal, we use the non-equality sign `!=`.
              
              ```kotlin
              fun main() {
                  println(10 == 10) // true
                  println(10 == 11) // false
                  println(10 != 10) // false
                  println(10 != 11) // true
              }
              ```
              
              Numbers and all objects that are comparable (i.e., they implement the `Comparable` interface) can also be compared with `>`, `<`, `>=`, and `<=`.
              
              ```kotlin
              fun main() {
                  println(10 > 10) // false
                  println(10 > 11) // false
                  println(11 > 10) // true
              
                  println(10 < 10) // false
                  println(10 < 11) // true
                  println(11 < 10) // false
              
                  println(10 >= 10) // true
                  println(10 >= 11) // false
                  println(11 >= 10) // true
              
                  println(10 <= 10) // true
                  println(10 <= 11) // true
                  println(11 <= 10) // false
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-equality-q1"
            question: |-
              Given:
              
              ```kotlin
              class Point(val x: Int)
              
              val p1 = Point(1)
              val p2 = Point(2)
              ```
              
              Which expressions compile successfully?
            explanation: "`==` and `!=` are available for all types (they rely on structural\
        \ equality). Relational operators (`>`, `<`, `>=`, `<=`) require the type\
        \ to implement `Comparable`, which `Point` does not."
            repeatable: true
            answers:
              - "p1 == p2"
              - "p1 != p2"
              - "p1 > p2"
              - "p1 <= p2"
            correct:
              - "p1 == p2"
              - "p1 != p2"
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-equality-q2"
            question: "Which of the following String comparisons evaluate to true in Kotlin?"
            explanation: |-
              Strings are `Comparable` and use lexicographic (Unicode) ordering: prefix rules and character codes apply.
              - "abc" < "abd" (true, 'c' < 'd')
              - "abc" > "ab" (true, longer after equal prefix)
              - "kotlin" >= "kotlin" (true, equality)
              - "Kotlin" < "Java" (false, 'K' > 'J')
              - "a" <= "A" (false, 'a' > 'A')
            repeatable: false
            answers:
              - "\"abc\" < \"abd\""
              - "\"abc\" > \"ab\""
              - "\"kotlin\" >= \"kotlin\""
              - "\"Kotlin\" < \"Java\""
              - "\"a\" <= \"A\""
            correct:
              - "\"abc\" < \"abd\""
              - "\"abc\" > \"ab\""
              - "\"kotlin\" >= \"kotlin\""
          - type: "text"
            stepId: "lesson-04_basic_values-boolean-operations-text"
            repeatable: false
            text: |-
              There are three basic logical operators in Kotlin:
              * and `&&`, which returns `true` when the value on both its sides is `true`; otherwise, it returns `false`.
              * or `||`, which returns `true` when the value on either of its sides is `true`; otherwise, it returns `false`.
              * not `!`, which turns `true` into `false`, and `false` into `true`.
              
              ```kotlin
              fun main() {
                  println(true && true) // true
                  println(true && false) // false
                  println(false && true) // false
                  println(false && false) // false
              
                  println(true || true) // true
                  println(true || false) // true
                  println(false || true) // true
                  println(false || false) // false
              
                  println(!true) // false
                  println(!false) // true
              }
              ```
              
              Kotlin does not support any kind of automatic conversion to `Boolean` (or any other type), so logical operators should be used only with objects of type `Boolean`.
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-boolean-operations-q1"
            question: "Which of the following Kotlin declarations compile successfully?"
            explanation: "Logical operators (&&, ||, !) work only with Boolean operands.\
        \ Kotlin has no truthy/falsy auto-conversions from Int, String, etc."
            repeatable: true
            answers:
              - "val a = (3 > 1) && (2 == 2)"
              - "val b = \"kotlin\".isNotEmpty() || false"
              - "val c = 1 && (2 == 2)"
              - "val d = !0"
              - "val e = !(5 != 5)"
            correct:
              - "val a = (3 > 1) && (2 == 2)"
              - "val b = \"kotlin\".isNotEmpty() || false"
              - "val e = !(5 != 5)"
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-boolean-operations-q2"
            question: |-
              What does the following Kotlin program print?
              
              ```kotlin
              fun main() {
                  val a = true
                  val b = false
                  val c = true
                  println(!(a && b) || (b || !c) && a)
              }
              ```
            explanation: "a && b = false; !(a && b) = true. c = true so !c = false; b ||\
        \ !c = false; (b || !c) && a = false; finally true || false = true."
            repeatable: false
            answers:
              - "true"
              - "false"
              - "Compilation error"
              - "Throws at runtime"
            correct: "true"
          - type: "text"
            stepId: "lesson-04_basic_values-characters-text"
            repeatable: false
            text: |-
              To represent a single character, we use the `Char` type. We specify a character using apostrophes.
              
              ```kotlin
              fun main() {
                  println('A') // A
                  println('Z') // Z
              }
              ```
              
              Each character is represented as a Unicode number. To find out the Unicode of a character, use the `code` property.
              
              ```kotlin
              fun main() {
                  println('A'.code) // 65
              }
              ```
              
              Kotlin accepts Unicode characters. To describe them by their code, we start with `\u`, and then we need to use hexadecimal format, just like in Java.
              
              ```kotlin
              fun main() {
                  println('\u00A3') // £
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-characters-q1"
            question: "Which of the following Kotlin expressions compile and evaluate to\
        \ the integer 65?"
            explanation: "`'A'.code` is 65 because 'A' has Unicode 65. `\\u0041` is 'A',\
        \ so its `.code` is also 65. `65.toChar()` yields 'A', whose `.code` is 65.\
        \ A String (`\"A\"`) has no `.code`, and `'65'` is not a valid `Char` literal."
            repeatable: true
            answers:
              - "'A'.code"
              - "'\\u0041'.code"
              - "65.toChar().code"
              - "\"A\".code"
              - "'65'.code"
            correct:
              - "'A'.code"
              - "'\\u0041'.code"
              - "65.toChar().code"
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-characters-q2"
            question: "Which literal is the correct Kotlin Char representing the pound sign\
        \ using a Unicode escape?"
            explanation: "Kotlin `Char` literals use single quotes and Unicode escapes with\
        \ `\\u` followed by 4 hex digits: `'\\u00A3'`."
            repeatable: false
            answers:
              - "'\\u00A3'"
              - "\"\\u00A3\""
              - "'U+00A3'"
              - "'\\x00A3'"
            correct: "'\\u00A3'"
          - type: "text"
            stepId: "lesson-04_basic_values-strings-text"
            repeatable: false
            text: "Strings are just sequences of characters that form a piece of text. In\
        \ Kotlin, we create a string using quotation marks `\"` or triple quotation\
        \ marks `\"\"\"`.\n\n```kotlin\nfun main() {\n    val text1 = \"ABC\"\n  \
        \  println(text1) // ABC\n    val text2 = \"\"\"DEF\"\"\"\n    println(text2)\
        \ // DEF\n}\n```\n\nA string wrapped in single quotation marks requires text\
        \ in a single line. If we want to define a newline character, we need to use\
        \ a special character `\\n`. This is not the only thing that needs (or might\
        \ need) a backslash to be expressed in a string.\n\n| Escape Sequence | Meaning\
        \               |\n|-----------------|-----------------------|\n| `\\t`  \
        \          | Tab                   |\n| `\\b`            | Backspace     \
        \        |\n| `\\r`            | Carriage return       |\n| `\\f`        \
        \    | Form feed             |\n| `\\n`            | Newline             \
        \  |\n| `\\'`            | Single quotation mark |\n| `\\\"`            |\
        \ Quotation mark        |\n| `\\\\`            | Backslash             |\n\
        | `\\$`            | Dollar                |\n\nStrings in triple quotation\
        \ marks can be multiline; in these strings, special characters can be used\
        \ directly, and forms prefixed by a backslash don’t work.\n\n```kotlin\nfun\
        \ main() {\n    val text1 = \"Let\\'s say:\\n\\\"Hooray\\\"\"\n    println(text1)\n\
        \    // Let's say:\n    // \"Hooray\"\n    val text2 = \"\"\"Let\\'s say:\\\
        n\\\"Hooray\\\"\"\"\"\n    println(text2)\n    // Let\\'s say:\\n\\\"Hooray\\\
        \"\n    val text3 = \"\"\"Let's say:\n\"Hooray\"\"\"\"\n    println(text3)\n\
        \    // Let's say:\n    // \"Hooray\"\n}\n```\n\nTo better format triple quotation\
        \ mark strings, we use the `trimIndent` function, which ignores a constant\
        \ number of spaces for each line.\n\n```kotlin\nfun main() {\n    val text\
        \ = \"\"\"\n   Let's say:\n   \"Hooray\"\n   \"\"\".trimIndent()\n    println(text)\n\
        \    // Let's say:\n    // \"Hooray\"\n\n    val description = \"\"\"\n  \
        \    A\n      B\n          C\n  \"\"\".trimIndent()\n    println(description)\n\
        \    // A\n    // B\n    //     C\n}\n```\n\nString literals may contain template\
        \ expressions, which are pieces of code that are evaluated and whose results\
        \ are concatenated into a string. A template expression starts with a dollar\
        \ sign (`$`) and consists of either a variable name (like `\"text is $text\"\
        `) or an expression in curly braces (like `\"1 + 2 = ${1 + 2}\"`).\n\n```kotlin\n\
        fun main() {\n    val name = \"Cookie\"\n    val surname = \"DePies\"\n  \
        \  val age = 6\n\n    val fullName = \"$name $surname ($age)\"\n    println(fullName)\
        \ // Cookie DePies (6)\n\n    val fullNameUpper =\n        \"${name.uppercase()}\
        \ ${surname.uppercase()} ($age)\"\n    println(fullNameUpper) // COOKIE DEPIES\
        \ (6)\n\n    val description = \"\"\"\n       Name: $name\n       Surname:\
        \ $surname\n       Age: $age\n   \"\"\".trimIndent()\n    println(description)\n\
        \    // Name: Cookie\n    // Surname: DePies\n    // Age: 6\n}\n```\n\nIf\
        \ you need to use a special character inside a triple quotation mark string,\
        \ the easiest way is to specify it with a regular string and include it using\
        \ template syntax.\n\n```kotlin\nfun main() {\n    val text1 = \"\"\"ABC\\\
        nDEF\"\"\"\n    println(text1) // ABC\\nDEF\n    val text2 = \"\"\"ABC${\"\
        \\n\"}DEF\"\"\"\n    println(text2)\n    // ABC\n    // DEF\n}\n```\n\nIn\
        \ Kotlin strings, we use Unicode, so we can also define a Unicode character\
        \ using a number that starts with `\\u`, and then specifying a Unicode character\
        \ code in hexadecimal syntax.\n\n![](unicode.png)\n\nYou can use `+` operator\
        \ to concatenate two strings, so to create a new string that is a combination\
        \ of two other strings. You can also use this operator to concatenate a string\
        \ with any other object, which will be converted to a string. The result is\
        \ always a string. \n\n```kotlin\nfun main() {\n    val text1 = \"ABC\"\n\
        \    val text2 = \"DEF\"\n    println(text1 + text2) // ABCDEF\n    println(text1\
        \ + 123) // ABC123\n    println(text1 + true) // ABCtrue\n}\n```"
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-strings-q1"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  val s = """\u0041 ${'\u0042'} ${"\u0043"}"""
                  println(s)
              }
              ```
            explanation: "In a raw (triple-quoted) string, backslash escapes are not processed,\
        \ so \\u0041 stays literal. Inside `${'\\u0042'}` the char literal becomes\
        \ B, and inside `${\"\\u0043\"}` the regular string escape becomes C."
            repeatable: true
            answers:
              - "\\u0041 B C"
              - "A B C"
              - "\\u0041 \\u0042 \\u0043"
              - "ABC"
            correct: "\\u0041 B C"
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-strings-q2"
            question: "Select all println calls that print exactly one line: ABC\\nDEF"
            explanation: "Single-line literal with backslash-n requires either escaping\
        \ the backslash in a regular string (\"\\\\n\"), using a raw string where\
        \ \\n is not processed, or injecting \"\\\\n\" via a template. Using \\n as\
        \ an escape (regular string or via ${\"\\n\"}) produces an actual newline."
            repeatable: false
            answers:
              - "println(\"ABC\\\\nDEF\")"
              - "println(\"ABC\\nDEF\")"
              - "println(\"\"\"ABC\\nDEF\"\"\")"
              - "println(\"\"\"ABC${\"\\n\"}DEF\"\"\")"
              - "println(\"ABC${\"\\\\n\"}DEF\")"
            correct:
              - "println(\"ABC\\\\nDEF\")"
              - "println(\"\"\"ABC\\nDEF\"\"\")"
              - "println(\"ABC${\"\\\\n\"}DEF\")"
          - type: "text"
            stepId: "lesson-04_basic_values-summary-text"
            repeatable: false
            text: |-
              In this chapter, we've learned about the basic Kotlin types and the literals we use to create them:
              * Numbers that are represented by types `Int`, `Long`, `Double`, `Float`, `Short`, and `Byte` are created with bare number values with possible suffixes for type customization. We can define negative numbers or decimal parts. We can also use underscores for nicer number formatting.
              * Boolean values `true` and `false` are represented by the `Boolean` type.
              * Characters, which are represented by the `Char` type. We define a character value using single quotation marks.
              * Strings, which are used to represent text, are represented by the `String` type. Each string is just a series of characters. We define strings inside double quotation marks.
              
              So, we have the foundations for using Kotlin. Let's move on to more-complicated control structures that determine how our code behaves.
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values-summary-q1"
            question: "Which of the following Kotlin declarations compile as written?"
            explanation: |-
              - Char uses single quotes; String uses double quotes.
              - Booleans are `true`/`false`.
              - Integers can be negative and use underscores.
              - Long needs the `L` suffix; Float needs the `F` suffix; a bare decimal literal is `Double`.
            repeatable: true
            answers:
              - "val letter: Char = 'k'"
              - "val word: String = 'h'"
              - "val truth: Boolean = true"
              - "val count: Int = -1_000"
              - "val distance: Long = 1_000L"
              - "val ratio: Float = 3.14"
            correct:
              - "val letter: Char = 'k'"
              - "val truth: Boolean = true"
              - "val count: Int = -1_000"
              - "val distance: Long = 1_000L"
          - type: "question-single-answer"
            stepId: "lesson-04_basic_values-summary-q2"
            question: "Which line correctly declares a Float using a literal?"
            explanation: "Float literals use the `F` suffix. A bare decimal is `Double`;\
        \ quotes make a `String`; `L` denotes `Long`."
            repeatable: false
            answers:
              - "val f: Float = 2.5F"
              - "val f: Float = 2.5"
              - "val f: Float = \"2.5F\""
              - "val f: Float = 2.5L"
            correct: "val f: Float = 2.5F"
          - type: "question-multiple-answer"
            stepId: "lesson-04_basic_values- -q1"
            question: "Which of the following Kotlin declarations compile successfully?\
        \ Choose all that apply."
            explanation: "A Boolean can only be `true`/`false` or the result of a comparison\
        \ (e.g., `==`, `<`). Assigning an `Int` or a `String` value to a `Boolean`\
        \ is a type error."
            repeatable: false
            answers:
              - "val b1: Boolean = true"
              - "val b2: Boolean = 1"
              - "val b3: Boolean = 2 == 2"
              - "val b4: Boolean = 5 < 3"
              - "val b5: Boolean = \"false\""
            correct:
              - "val b1: Boolean = true"
              - "val b3: Boolean = 2 == 2"
              - "val b4: Boolean = 5 < 3"
      - lessonId: "lesson-conditional-statements"
        name: "Conditional statements"
        steps:
          - type: "text"
            stepId: "lesson-05_conditional_statements-#-conditional-statements-text"
            repeatable: false
            text: |-
              Most conditional statements, like the if-condition or the while-loop, look the same in Kotlin, Java, C++, JavaScript, and most other modern languages. For instance, the if-statement is indistinguishable in all these languages:
              
              ```kotlin
              if (predicate) {
                  // body
              }
              ```
              
              However, the if-condition in Kotlin is more powerful and has capabilities that Kotlin's predecessors don’t support. I assume that you have general experience in programming, so I will concentrate on the differences that Kotlin has introduced compared to other programming languages.
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-#-conditional-statements-q1"
            question: "Which statement about Kotlin's if is correct compared to languages\
        \ like Java or C++?"
            explanation: "In Kotlin, if is an expression and can produce a value. Parentheses\
        \ are required, there is no ternary operator ?:, and else is only required\
        \ when using if as an expression."
            repeatable: true
            answers:
              - "It is an expression that can return a value."
              - "Parentheses around the condition are optional."
              - "Kotlin provides the ternary operator ?:."
              - "An else block is always required, even when used as a statement."
            correct: "It is an expression that can return a value."
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-#-conditional-statements-q2"
            question: "Which snippet correctly assigns a value using Kotlin's if as an expression?"
            explanation: "Only A uses if as an expression with both branches producing a\
        \ value. Kotlin has no ?: ternary operator, and if used as an expression requires\
        \ an else branch."
            repeatable: true
            answers:
              - "val sign = if (n > 0) 1 else -1"
              - "val sign = if (n > 0) { 1 }"
              - "val sign = n > 0 ? 1 : -1"
              - "if (n > 0) val sign = 1 else val sign = -1"
            correct: "val sign = if (n > 0) 1 else -1"
          - type: "text"
            stepId: "lesson-05_conditional_statements-if-statement-text"
            repeatable: false
            text: |-
              Let's start with the aforementioned if-statement. It executes its body when its condition is satisfied (returns `true`). We can additionally add the `else` block, which is executed when the condition is not satisfied (returns `false`).
              
              ```kotlin
              fun main() {
                  val i = 1 // or 5
                  if (i < 3) { // i < 3 is used as a condition
                      // will be executed when condition returns true
                      println("Smaller")
                  } else {
                      // will be executed when condition returns false
                      println("Bigger")
                  }
                  // Prints Smaller if i == 1, or Bigger if i == 5
              }
              ```
              
              One of Kotlin’s superpowers is that an if-else statement can be used as an expression, therefore it produces a value.
              
              ```kotlin
              val value = if (condition) {
                  // body 1
              } else {
                  // body 2
              }
              ```
              
              What value is returned? For each body block, it is the result of the last statement (or `Unit` for an empty body or a statement that is not an expression).
              
              ```kotlin
              fun main() {
                  var isOne = true
                  val number1: Int = if (isOne) 1 else 0
                  println(number1) // 1
                  isOne = false
                  val number2: Int = if (isOne) 1 else 0
                  println(number2) // 0
              
                  val superuser = true
                  val hasAccess: Boolean = if (superuser) {
                      println("Good morning, sir Admin")
                      true
                  } else {
                      false
                  }
                  println(hasAccess) // true
              }
              ```
              
              When a body has only one statement, its result is the result of our if-else expression. In such a case, we don’t need brackets.
              
              ```kotlin
              val r: Int = if (one) 1 else 0
              // a more readable alternative to
              val r: Int = if (one) {
                  1
              } else {
                  0
              }
              ```
              
              This way of using an if-statement is a Kotlin alternative to the Java or JavaScript ternary operator.
              
              ```
              // Java
              final String name = user == null ? "" : user.name
              // JavaScript
              const name = user === null ? "" : user.name
              ```
              
              ```kotlin
              // Kotlin
              val name = if (user == null) "" else user.name
              ```
              
              It should be said that if-else is longer than the ternary operator syntax. I believe this is the main reason why some developers want ternary operator syntax introduced in Kotlin. However, I am against this as if-else is a good replacement that is more readable and can be better formatted. Moreover, we have some additional Kotlin tools, which are also replacements for some ternary-operator use cases: the Elvis operator, extensions on nullable types (like `orEmpty`), or safe-calls. All these will be explained in detail in the chapter *Nullability*.
              
              ```
              // Java
              String name = user == null ? "" : user.name
              
              // Kotlin
              val name = user?.name ?: ""
              // or
              val name = user?.name.orEmpty()
              ```
              
              Notice that if you use the so-called if-else-if statement, it is just multiple connected if-else statements.
              
              ```kotlin
              fun main() {
                  println("Is it going to rain?")
                  val probability = 70
                  if (probability < 40) {
                      println("Na-ha")
                  } else if (probability <= 80) {
                      println("Likely")
                  } else if (probability < 100) {
                      println("Yes")
                  } else {
                      println("Holly Crab")
                  }
              }
              ```
              
              There is actually no such thing as an if-else-if expression: it is just one if-else expression inside another, as can be seen in strange cases where a method is executed on a whole if-else-if expression. Just take a look at the following puzzle and try to predict the result of this code.
              
              ```kotlin
              // Function we can execute on any object, to print it
              // 10.print() prints 10
              // "ABC".print() prints ABC
              fun Any?.print() {
                  print(this)
              }
              
              fun printNumberSign(num: Int) {
                  if (num < 0) {
                      "negative"
                  } else if (num > 0) {
                      "positive"
                  } else {
                      "zero"
                  }.print()
              }
              
              fun main(args: Array<String>) {
                  printNumberSign(-2)
                  print(",")
                  printNumberSign(0)
                  print(",")
                  printNumberSign(2)
              }
              ```
              
              The answer is **not** "negative,zero,positive", because there is no such thing as a single if-else-if expression (just two nested if-else expressions). So, the above `printNumberSign` implementation gives the same result as the following implementation.
              
              ```kotlin
              fun printNumberSign(num: Int) {
                  if (num < 0) {
                      "negative"
                  } else {
                      if (num > 0) {
                          "positive"
                      } else {
                          "zero"
                      }.print()
                  }
              }
              ```
              
              So, when we call `print` on the result, it is called on the result of the second if-else expression only (the one with "positive" and "zero"). This means that the code above will print ",zero,positive". How can we fix this? We might use a bracket, but it is generally suggested that, instead of using if-else-if, we should use a when-statement when there is more than one condition. This can help avoid mistakes like the one in the puzzle above, and it makes code clearer and easier to read.
              
              ```kotlin
              // Function we can execute on any object, to print it
              // 10.print() prints 10
              // "ABC".print() prints ABC
              fun Any?.print() {
                  print(this)
              }
              
              fun printNumberSign(num: Int) {
                  when {
                      num < 0 -> "negative"
                      num > 0 -> "positive"
                      else -> "zero"
                  }.print()
              }
              
              fun main(args: Array<String>) {
                  printNumberSign(-2) // negative
                  print(",") // ,
                  printNumberSign(0) // zero
                  print(",") // ,
                  printNumberSign(2) // positive
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-if-statement-q1"
            question: |-
              What does the following program print?
              
              ```kotlin
              fun Any?.print() { print(this) }
              
              fun printNumberSign(num: Int) {
                  if (num < 0) {
                      "negative"
                  } else if (num > 0) {
                      "positive"
                  } else {
                      "zero"
                  }.print()
              }
              
              fun main() {
                  printNumberSign(-2)
                  print(",")
                  printNumberSign(0)
                  print(",")
                  printNumberSign(2)
              }
              ```
            explanation: "`.print()` is applied only to the second if-else expression (the\
        \ one with \"positive\"/\"zero\"). For -2, nothing is printed; then a comma;\
        \ then \"zero\"; then a comma; then \"positive\"."
            repeatable: false
            answers:
              - "negative,zero,positive"
              - ",zero,positive"
              - "negative,,positive"
              - "negative,zero,"
            correct: ",zero,positive"
          - type: "question-multiple-answer"
            stepId: "lesson-05_conditional_statements-if-statement-q2"
            question: "Which of the following declarations compile in Kotlin, given `val\
        \ flag = true`?"
            explanation: |-
              - `a` compiles: both branches return Int.
              - `b` fails: branches are Unit vs Int; cannot assign to Int.
              - `c` compiles: Unit and Int have common supertype Any.
              - `d` compiles: empty blocks return Unit.
              - `e` fails: first branch's last statement is `println`, so Unit vs String -> common type Any, not String.
            repeatable: true
            answers:
              - "val a: Int = if (flag) 1 else 0"
              - "val b: Int = if (flag) println(\"A\") else 0"
              - "val c: Any = if (flag) println(\"A\") else 0"
              - "val d: Unit = if (flag) {} else {}"
              - "val e: String = if (flag) { \"X\"; println(\"Y\") } else \"Z\""
            correct:
              - "val a: Int = if (flag) 1 else 0"
              - "val c: Any = if (flag) println(\"A\") else 0"
              - "val d: Unit = if (flag) {} else {}"
          - type: "text"
            stepId: "lesson-05_conditional_statements-when-statement-text"
            repeatable: false
            text: |-
              The when-statement is an alternative to if-else-if. In every branch, we specify a predicate and the body that should be executed if this predicate returns `true` (and previous predicates did not). So, it works just like if-else-if but should be preferred because its syntax is better suited for multiple conditions.
              
              ```kotlin
              fun main() {
                  println("Is it going to rain?")
                  val probability = 70
                  when {
                      probability < 40 -> {
                          println("Na-ha")
                      }
                      probability <= 80 -> {
                          println("Likely")
                      }
                      probability < 100 -> {
                          println("Yes")
                      }
                      else -> {
                          println("Holly Crab")
                      }
                  }
              }
              ```
              
              Like in an if-statement, braces are needed only for bodies with more than one statement.
              
              ```kotlin
              fun main() {
                  println("Is it going to rain?")
                  val probability = 70
                  when {
                      probability < 40 -> println("Na-ha")
                      probability <= 80 -> println("Likely")
                      probability < 100 -> println("Yes")
                      else -> println("Holly Crab")
                  }
              }
              ```
              
              The when-statement can also be used as an expression because it can return a value. The result is the last expression of the chosen branch, therefore the following example will print "Likely".
              
              ```kotlin
              fun main() {
                  println("Is it going to rain?")
                  val probability = 70
                  val text = when {
                      probability < 40 -> "Na-ha"
                      probability <= 80 -> "Likely"
                      probability < 100 -> "Yes"
                      else -> "Holly Crab"
                  }
                  println(text)
              }
              ```
              
              The when-statement is often used as an expression body:
              
              ```kotlin
              private fun getEmailErrorId(email: String) = when {
                  email.isEmpty() -> R.string.error_field_required
                  emailInvalid(email) -> R.string.error_invalid_email
                  else -> null
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-when-statement-q1"
            question: |-
              What is the inferred return type of the following function?
              
              ```kotlin
              private fun getEmailErrorId(email: String) = when {
                  email.isEmpty() -> R.string.error_field_required
                  emailInvalid(email) -> R.string.error_invalid_email
                  else -> null
              }
              ```
            explanation: "Two branches return Int and one returns null; the common type\
        \ is Int?. A when used as an expression determines its type from branch results."
            repeatable: true
            answers:
              - "Int"
              - "Int?"
              - "String?"
              - "Unit"
            correct: "Int?"
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-when-statement-q2"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  val msg = when {
                      true -> { print("b"); "X" }
                      else -> { print("c"); "Y" }
                  }
                  print(msg)
              }
              ```
            explanation: "The first branch runs, prints b, and returns the last expression\
        \ \"X\". Then print(msg) prints X, resulting in bX."
            repeatable: false
            answers:
              - "bX"
              - "Xb"
              - "b"
              - "X"
              - "Compile error"
            correct: "bX"
          - type: "text"
            stepId: "lesson-05_conditional_statements-when-statement-with-a-value-text"
            repeatable: false
            text: |-
              There is also another form of the when-statement. If we add a value in brackets after the `when` keyword, then our when-statement becomes an alternative to the switch-case. However, it is a much more powerful alternative because it can not only compare values by equality, but it can also check if an object is of some type (using `is`), or if an object contains this value (using `in`). Each block can have multiple values we compare against, separated with a comma.
              
              ```kotlin
              private val magicNumbers = listOf(7, 13)
              
              fun describe(a: Any?) {
                  when (a) {
                      null -> println("Nothing")
                      1, 2, 3 -> println("Small number")
                      in magicNumbers -> println("Magic number")
                      in 4..100 -> println("Big number")
                      is String -> println("This is just $a")
                      is Long, is Int -> println("This is Int or Long")
                      else -> println("No idea, really")
                  }
              }
              
              fun main() {
                  describe(null) // Nothing
                  describe(1) // Small number
                  describe(3) // Small number
                  describe(7) // Magic number
                  describe(9) // Big number,
                  // because 9 is in range from 4 to 100
                  describe("AAA") // This is just AAA
                  describe(1L) // This is Int or Long
                  describe(-1) // This is Int or Long
                  describe(1.0) // No idea, really,
                  // because 1.0 is Double
              }
              ```
              
              The when-statement with a value can also be used as an expression because it can produce a value:
              
              ```kotlin
              private val magicNumbers = listOf(7, 13)
              
              fun describe(a: Any?): String = when (a) {
                  null -> "Nothing"
                  1, 2, 3 -> "Small number"
                  in magicNumbers -> "Magic number"
                  in 4..100 -> "Big number"
                  is String -> "This is just $a"
                  is Long, is Int -> "This is Int or Long"
                  else -> "No idea, really"
              }
              
              fun main() {
                  println(describe(null)) // Nothing
                  println(describe(1)) // Small number
                  println(describe(3)) // Small number
                  println(describe(7)) // Magic number
                  println(describe(9)) // Big number,
                  // because 9 is in range from 4 to 100
                  println(describe("AAA")) // This is just AAA
                  println(describe(1L)) // This is Int or Long
                  println(describe(-1)) // This is Int or Long
                  println(describe(1.0)) // No idea, really,
                  // because 1.0 is Double
              }
              ```
              
              Note that if we use a when-condition as an expression, its conditions must be exhaustive: it should cover all possible branch conditions or provide an else branch, as in the example above. If not all conditions are covered, a compiler error is shown.
              
              > Kotlin does not support switch-case statements because we use the when-statement instead.
              
              Inside the “when” parentheses, where we specify a value, we can also define a variable, and its value will be used in each condition.
              
              ```kotlin
              fun showUsers() =
                  when (val response = requestUsers()) {
                      is Success -> showUsers(response.body)
                      is HttpError -> showException(response.exception)
                  }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-05_conditional_statements-when-statement-with-a-value-q1"
            question: "Which of the following when-expressions compile (are exhaustive)\
        \ as written?"
            explanation: "A when used as an expression must be exhaustive. For Boolean,\
        \ true/false cover all cases. For Boolean?, you must also handle null or provide\
        \ else. For wide types like Any/Any?, you need else unless all possibilities\
        \ are covered."
            repeatable: true
            answers:
              - |-
                A)
                ```kotlin
                fun f(a: Boolean) = when (a) {
                    true -> "T"
                    false -> "F"
                }
                ```
              - |-
                B)
                ```kotlin
                fun f(a: Boolean?) = when (a) {
                    true -> "T"
                    false -> "F"
                }
                ```
              - |-
                C)
                ```kotlin
                fun f(a: Any) = when (a) {
                    is String -> "S"
                    is Int -> "I"
                    else -> "?"
                }
                ```
              - |-
                D)
                ```kotlin
                fun f(a: Any?) = when (a) {
                    null -> "N"
                    is String -> "S"
                }
                ```
            correct:
              - |-
                A)
                ```kotlin
                fun f(a: Boolean) = when (a) {
                    true -> "T"
                    false -> "F"
                }
                ```
              - |-
                C)
                ```kotlin
                fun f(a: Any) = when (a) {
                    is String -> "S"
                    is Int -> "I"
                    else -> "?"
                }
                ```
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-when-statement-with-a-value-q2"
            question: |-
              What does this print for the call categorize(7L)?
              
              ```kotlin
              val magic = listOf(7, 13)
              
              fun categorize(a: Any?) = when (a) {
                  7 -> "Seven"
                  in magic -> "Magic"
                  in 1..10 -> "Range"
                  is Long -> "Long"
                  else -> "Other"
              }
              ```
            explanation: "Equality in when uses equals, so 7L is not equal to Int 7. `in\
        \ magic` fails because List<Int> doesn't contain Long 7L. `in 1..10` checks\
        \ an IntRange and only matches Ints. The first matching branch is `is Long`."
            repeatable: false
            answers:
              - "Seven"
              - "Magic"
              - "Range"
              - "Long"
              - "Other"
            correct: "Long"
          - type: "text"
            stepId: "lesson-05_conditional_statements-is-check-text"
            repeatable: false
            text: |-
              Since we have already mentioned the `is` operator, let's discuss it in a bit more depth. It checks if a value is of a certain type. We know already that `123` is of type `Int`, and `"ABC"` is of type `String`. Certainly, `123` is not of type `String`, and `"ABC"` is not of type `Int`. We can confirm this using the `is` check.
              
              ```kotlin
              fun main() {
                  println(123 is Int) // true
                  println("ABC" is String) // true
                  println(123 is String) // false
                  println("ABC" is Int) // false
              }
              ```
              
              Notice that `123` is an `Int`, but it is also a `Number`; the `is` check returns `true` for both these types.
              
              ```kotlin
              fun main() {
                  println(123 is Int) // true
                  println(123 is Number) // true
                  println(3.14 is Double) // true
                  println(3.14 is Number) // true
              
                  println(123 is Double) // false
                  println(3.14 is Int) // false
              }
              ```
              
              When we want to check if a value **is not** of a certain type, we can use `!is`; this is an equivalent of is-check, but its result value is negated.
              
              ```kotlin
              fun main() {
                  println(123 !is Int) // false
                  println("ABC" !is String) // false
                  println(123 !is String) // true
                  println("ABC" !is Int) // true
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-05_conditional_statements-is-check-q1"
            question: "Which Kotlin expressions evaluate to true?"
            explanation: "`Int` and `Double` are subtypes of `Number`, so `0 is Int`, `0\
        \ is Number`, and `3.14 is Number` are true. An `Int` is not a `Double`, and\
        \ `String` is not a `Number`."
            repeatable: true
            answers:
              - "0 is Int"
              - "0 is Number"
              - "0 is Double"
              - "\"0\" is Number"
              - "3.14 is Number"
            correct:
              - "0 is Int"
              - "0 is Number"
              - "3.14 is Number"
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-is-check-q2"
            question: |-
              Given:
              
              ```kotlin
              val x: Number = 42
              val a = x is Int
              val b = x is Double
              val c = x !is Number
              ```
              Which option is correct?
            explanation: "Runtime type of `x` is `Int`, so `a` is true. `x` is not a `Double`,\
        \ so `b` is false. `x` is a `Number`, so `x !is Number` is false."
            repeatable: false
            answers:
              - "Only a is true"
              - "Only b is true"
              - "a and b are true"
              - "b and c are true"
              - "All are false"
            correct: "Only a is true"
          - type: "text"
            stepId: "lesson-05_conditional_statements-explicit-casting-text"
            repeatable: false
            text: |-
              You can always use a value whose type is `Int` as a `Number` because every `Int` is a `Number`. This process is known as *up-casting* because we change the value type from lower (more specific) to higher (less specific).
              
              ```kotlin
              fun main() {
                  val i: Int = 123
                  val l: Long = 123L
                  val d: Double = 3.14
              
                  var number: Number = i // up-casting from Int to Number
                  number = l // up-casting from Long to Number
                  number = d // up-casting from Double to Number
              }
              ```
              
              We can implicitly cast from a lower type to a higher one, but not the other way around. Every `Int` is a `Number`, but not every `Number` is an `Int` because there are more subtypes of `Number`, including `Double` or `Long`. This is why we cannot use `Number` where `Int` is expected. However, sometimes we have a situation where we are certain that a value is of a specified type, even though its supertype is used. Explicitly changing from a higher type to a lower type is called *down-casting* and requires the `as` operator in Kotlin.
              
              ```kotlin
              var i: Number = 123
              
              fun main() {
                  val j = (i as Int) + 10
                  println(j) // 133
              }
              ```
              
              In general, we avoid using `as` when not necessary because we consider it dangerous. Consider the above example. What if someone changes `123` to `3.14`? Both values are of type `Number`, so the code will compile without any problems or warnings. But `3.14` is `Double` not `Int`, and casting is not possible; therefore, the code above will break with a `ClassCastException` exception.
              
              ```kotlin
              var i: Number = 3.14
              
              fun main() {
                  val j = (i as Int) + 10 // RUNTIME ERROR!
                  println(j)
              }
              ```
              
              There are two ways to deal with this. The first is to use one of many Kotlin alternatives to cast our value safely. One example is using smart-casting, which will be described in the next section. Another example is a conversion function, like the `toInt` method, which transforms `Number` to `Int` (and possibly loses the decimal part).
              
              ```kotlin
              var i: Number = 3.14
              
              fun main() {
                  val j = i.toInt() + 10
                  println(j) // 13
              }
              ```
              
              The second option is the `as?` operator, which, instead of throwing an exception, returns `null` when casting is not possible. We will discuss handling nullable values later.
              
              ```kotlin
              var n: Number = 123
              
              fun main() {
                  val i: Int? = n as? Int
                  println(i) // 123
                  val d: Double? = n as? Double
                  println(d) // null
              }
              ```
              
              In Kotlin, we consider `as?` a safer option than `as`, but using both these operators too often is regarded as a code smell. Let's describe smart-casting, which is their popular alternative.
          - type: "question-multiple-answer"
            stepId: "lesson-05_conditional_statements-explicit-casting-q1"
            question: "Which statements about casting Numbers in Kotlin are correct?"
            explanation: |-
              - Up-casting (Int to Number) is implicit.
              - Down-casting with `as` can throw `ClassCastException` at runtime.
              - `as?` returns null on failure (does not throw).
              - `toInt()` converts, truncating the fractional part.
              - `x as Int` compiles but may fail at runtime if `x` isn't an Int.
            repeatable: true
            answers:
              - "Up-casting from Int to Number is implicit."
              - "Down-casting a Number to Int with `as` may throw ClassCastException at runtime."
              - "`as?` throws an exception on failure."
              - "Number.toInt() converts the value, possibly losing the fractional part."
              - "After `val x: Number = 3.14`, `val i = x as Int` is a compilation error."
            correct:
              - "Up-casting from Int to Number is implicit."
              - "Down-casting a Number to Int with `as` may throw ClassCastException at runtime."
              - "Number.toInt() converts the value, possibly losing the fractional part."
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-explicit-casting-q2"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  var n: Number = 3.99
                  val i = n as? Int ?: n.toInt()
                  println(i + 1)
              }
              ```
            explanation: "`n as? Int` returns null because `n` holds a `Double`, so the\
        \ Elvis operator uses `n.toInt()` which is 3; `println(3 + 1)` prints 4."
            repeatable: false
            answers:
              - "4"
              - "5"
              - "ClassCastException at runtime"
              - "Compilation error"
            correct: "4"
          - type: "text"
            stepId: "lesson-05_conditional_statements-smart-casting-text"
            repeatable: false
            text: "Kotlin has a powerful feature called smart-casting, which allows automatic\
        \ type casting when the compiler can be sure that a variable is of a certain\
        \ type. Take a look at the following example:\n\n```kotlin\nfun convertToInt(num:\
        \ Number): Int =\n    if (num is Int) num  // the type of num here is Int\n\
        \    else num.toInt()\n```\n\nThe `convertToInt` function converts an argument\
        \ of type `Number` to `Int` in the following way: if the argument is already\
        \ of type `Int`, it is just returned; otherwise, it is converted using the\
        \ `toInt` method. Notice that for this code to compile, the `num` inside the\
        \ first body needs to be of type `Int`. In most languages, it needs to be\
        \ casted, but this happens automatically in Kotlin. Take a look at another\
        \ example:\n\n```kotlin\nfun lengthIfString(a: Any): Int {\n    if (a is String)\
        \ {\n        return a.length // the type of a here is String\n    }\n    return\
        \ 0\n}\n```\n\nInside the if-condition predicate, we checked if `a` is of\
        \ type `String`. The body of this statement will only be executed if the type\
        \ check is successful. This is why `a` is of type `String` inside this body,\
        \ which is why we can check its length. Such a conversion, from `Any` to `String`,\
        \ is done implicitly by the Kotlin compiler. This can happen only when Kotlin\
        \ is sure that no other thread can change our property, so when it is either\
        \ a constant or a local variable. It will not work for non-local `var` properties\
        \ because, in such cases, there is no guarantee that they have not been modified\
        \ between check and usage (e.g., by another thread).\n\n```kotlin\nvar obj:\
        \ Any = \"AAA\"\n\nfun main() {\n    if (obj is String) {\n        // println(obj.length)\
        \ will not compile,\n        // because `obj` can be modified by some\n  \
        \      // other thread, so Kotlin cannot be sure,\n        // that at this\
        \ point, is it still of type String\n    }\n}\n```\n\nSmart-casting is often\
        \ used together with when-statements. When they are used together, they are\
        \ sometimes referred to as \"Kotlin type-safe pattern matching\" because they\
        \ can nicely cover the different possible types a value can be of. More examples\
        \ will be presented when we discuss the sealed modifier.\n\n```kotlin\nfun\
        \ handleResponse(response: Result<T>) {\n    when (response) {\n        is\
        \ Success<*> -> showMessages(response.data) \n        // response smart-casted\
        \ to Success\n        is Failure -> showError(response.throwable)\n      \
        \  // response smart-casted to Failure\n    }\n}\n```"
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-smart-casting-q1"
            question: |-
              Consider:
              
              ```kotlin
              fun <T> handle(response: Result<T>) {
                  when (response) {
                      is Success<*> -> show(response.data)
                      is Failure -> log(response.throwable)
                  }
              }
              ```
              What is the static type of `response` inside the first `when` branch?
            explanation: "The `is` check narrows `response` to the matched type. Because\
        \ `T` is unknown, Kotlin smart-casts it to `Success<*>` (star-projected),\
        \ not `Success<T>`."
            repeatable: true
            answers:
              - "Success<*>"
              - "Success<T>"
              - "Result<T>"
              - "Any"
            correct: "Success<*>"
          - type: "question-multiple-answer"
            stepId: "lesson-05_conditional_statements-smart-casting-q2"
            question: "Which snippets compile thanks to smart-casting (no explicit casts)?"
            explanation: |-
              - A and E are local (parameter/variable), so they smart-cast after `is String`.
              - C copies the non-local `obj` into a local `val`, which can be smart-cast.
              - B and D use a non-local `var` property directly; Kotlin won’t smart-cast it because it might change between check and use.
            repeatable: true
            answers:
              - |-
                A)
                ```kotlin
                fun f(a: Any) {
                    if (a is String) println(a.length)
                }
                ```
              - |-
                B)
                ```kotlin
                var obj: Any = "AAA"
                fun g() {
                    if (obj is String) println(obj.length)
                }
                ```
              - |-
                C)
                ```kotlin
                var obj: Any = "AAA"
                fun h() {
                    val local = obj
                    if (local is String) println(local.length)
                }
                ```
              - |-
                D)
                ```kotlin
                var obj: Any = "AAA"
                fun i() {
                    when (obj) {
                        is String -> println(obj.length)
                    }
                }
                ```
              - |-
                E)
                ```kotlin
                fun j() {
                    var x: Any = "A"
                    if (x is String) println(x.length)
                }
                ```
            correct:
              - |-
                A)
                ```kotlin
                fun f(a: Any) {
                    if (a is String) println(a.length)
                }
                ```
              - |-
                C)
                ```kotlin
                var obj: Any = "AAA"
                fun h() {
                    val local = obj
                    if (local is String) println(local.length)
                }
                ```
              - |-
                E)
                ```kotlin
                fun j() {
                    var x: Any = "A"
                    if (x is String) println(x.length)
                }
                ```
          - type: "text"
            stepId: "lesson-05_conditional_statements-while-and-do-while-statements-text"
            repeatable: false
            text: |-
              The last important control structures we need to mention are while and do-while statements. Both look and work exactly the same as in Java, C++, and many other languages.
              
              ```kotlin
              fun main() {
                  var i = 1
                  // while-statement
                  while (i < 10) {
                      print(i)
                      i *= 2
                  }
                  // 1248
              
                  var j = 1
                  // do-while statement
                  do {
                      print(j)
                      j *= 2
                  } while (j < 10)
                  // 1248
              }
              ```
              
              I hope they don’t need any more explanation. When-statements and do-while-statements cannot be used as expressions. I will only add that both while and do-while statements are rarely used in Kotlin. Instead, we use collection or sequence processing functions, which is covered in the *Functional Kotlin* book. For instance, the above code can be replaced with the following:
              
              ```kotlin
              fun main() {
                  generateSequence(1) { it * 2 }
                      .takeWhile { it < 10 }
                      .forEach(::print)
                  // 1248
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-while-and-do-while-statements-q1"
            question: |-
              What does the following Kotlin program print?
              
              ```kotlin
              fun main() {
                  var i = 0
                  while (i < 0) {
                      print(i)
                      i++
                  }
                  do {
                      print(i)
                      i++
                  } while (i < 0)
              }
              ```
            explanation: "while checks the condition before the first iteration, so it doesn't\
        \ run. do-while runs the body once before checking, so it prints 0 once."
            repeatable: true
            answers:
              - "'' (prints nothing)"
              - "0"
              - "01"
              - "10"
            correct: "0"
          - type: "question-multiple-answer"
            stepId: "lesson-05_conditional_statements-while-and-do-while-statements-q2"
            question: "Which snippets print exactly `1248`? Choose all that apply."
            explanation: |-
              - generateSequence starting at 1 and doubling yields 1,2,4,8,16,...
              - takeWhile { it < 10 } keeps 1,2,4,8 -> prints 1248.
              - take(4) also takes the first four elements -> 1,2,4,8.
              - The sequenceOf(1) variant has only one element (2) -> prints just 2.
              - Mapping (1..9) doubles to 2,4,6,8 -> missing 1.
              - dropWhile { it < 10 } skips to 16 and continues infinitely.
            repeatable: false
            answers:
              - |-
                ```kotlin
                generateSequence(1) { it * 2 }
                    .takeWhile { it < 10 }
                    .forEach(::print)
                ```
              - |-
                ```kotlin
                sequenceOf(1)
                    .map { it * 2 }
                    .takeWhile { it < 10 }
                    .forEach(::print)
                ```
              - |-
                ```kotlin
                generateSequence(1) { it * 2 }
                    .take(4)
                    .forEach(::print)
                ```
              - |-
                ```kotlin
                (1..9)
                    .map { it * 2 }
                    .takeWhile { it < 10 }
                    .forEach(::print)
                ```
              - |-
                ```kotlin
                generateSequence(1) { it * 2 }
                    .dropWhile { it < 10 }
                    .forEach(::print)
                ```
            correct:
              - |-
                ```kotlin
                generateSequence(1) { it * 2 }
                    .takeWhile { it < 10 }
                    .forEach(::print)
                ```
              - |-
                ```kotlin
                generateSequence(1) { it * 2 }
                    .take(4)
                    .forEach(::print)
                ```
          - type: "text"
            stepId: "lesson-05_conditional_statements-summary-text"
            repeatable: false
            text: "As you can see, Kotlin has introduced many powerful features to conditional\
        \ statements. The if-condition and when-condition can be used as expressions.\
        \ The when-statement is a more powerful alternative to if-else-if or switch-case.\
        \ Type checks with smart-casting are supported. All these features make operating\
        \ on nullable values both safe and pleasant, which makes the `null` value\
        \ our friend, not an enemy. Now, let's see what Kotlin has changed in functions."
          - type: "question-multiple-answer"
            stepId: "lesson-05_conditional_statements-summary-q1"
            question: |-
              Assume the following is in scope:
              
              ```kotlin
              val x: Any?
              ```
              Which snippets compile as-is?
            explanation: |-
              - When used as an expression (assigned to a val), `when` must be exhaustive. Options B and D are missing an `else` (and don't cover all cases), so they don't compile.
              - Smart casts apply in the checked branch (`x is String -> x.length`).
              - Option A is exhaustive (`else` present); option C's `if` is exhaustive with an `else`.
            repeatable: true
            answers:
              - |-
                ```kotlin
                val len: Int = when (x) {
                    is String -> x.length
                    null -> 0
                    else -> -1
                }
                ```
              - |-
                ```kotlin
                val len = when (x) {
                    is String -> x.length
                }
                ```
              - |-
                ```kotlin
                val len = if (x is String) x.length else -1
                ```
              - |-
                ```kotlin
                val len: Int = when {
                    x is String -> x.length
                }
                ```
            correct:
              - |-
                ```kotlin
                val len: Int = when (x) {
                    is String -> x.length
                    null -> 0
                    else -> -1
                }
                ```
              - |-
                ```kotlin
                val len = if (x is String) x.length else -1
                ```
          - type: "question-single-answer"
            stepId: "lesson-05_conditional_statements-summary-q2"
            question: |-
              What is the inferred type of `len`?
              
              ```kotlin
              val s: Any? = ...
              val len = if (s is String) s.length else null
              ```
            explanation: "`if` is an expression; its type is the least common supertype\
        \ of its branches. `s.length` is `Int`, and the other branch is `null`, so\
        \ the result type is `Int?`."
            repeatable: true
            answers:
              - "Int"
              - "Int?"
              - "Any?"
              - "Nothing?"
            correct: "Int?"
      - lessonId: "lesson-functions"
        name: "Functions"
        steps:
          - type: "text"
            stepId: "lesson-06_functions-{sample:-true}-text"
            repeatable: false
            text: |-
              # Functions
              
              When Andrey Breslav, the initial Kotlin creator, was asked about his favourite feature during a discussion panel at KotlinConf Amsterdam, he said it was functions. In the end, functions are our programs' most important building blocks. If you look at real-life applications, most of the code either defines or calls functions.
              
              ![As an example, I used a random class from the APKUpdater open-source project. Notice that nearly every line either defines or calls a function.](06_example_app.png)
              
              In Kotlin, we define functions using the `fun` keyword. This is why we have so much "fun" in Kotlin. With a bit of creativity, a function can consist only of `fun`:
              
              ```kotlin
              fun <Fun> `fun`(`fun`: Fun): Fun = `fun`
              ```
              
              > This is the so-called *identity function*, a function that returns its argument without any modifications. It has a generic type parameter `Fun`, but this will be explained in the chapter *Generics*.
              
              By convention, we name functions using lower camelCase syntax. Formally, we can use characters, underscore `_`, and numbers (but not at the first position), but in general just characters should be used.
              
              {width: 50%}
              ![In Kotlin, we name functions with lowerCamelCase.](camelCase.png)
              
              This is what a typical function looks like:
              
              ```kotlin
              fun square(x: Double): Double {
                  return x * x
              }
              
              fun main() {
                  println(square(10.0)) // 100.0
              }
              ```
              
              Notice that the parameter type is specified after the variable name and a colon, and the result type is specified after a colon inside the parameter brackets. Such notation is typical of languages with powerful support for type inference because it is easier to add or remove explicit type definitions.
              
              ```kotlin
              val a: Int = 123
              // easy to transform from or to
              val a = 123
              
              fun add(a: Int, b: Int): Int = a + b
              
              // easy to transform from or to
              fun add(a: Int, b: Int) = a + b
              ```
              
              To use a reserved keyword as a function name (like `fun` or `when`), use backticks, as in the example below. When a function has an illegal name, both its definition and calls require backticks.
              
              Another use case for backticks is naming unit-test functions so that they can be described in plain English, as in the example below. This is not standard practice, but it is still quite a popular practice that many teams choose to adopt.
              
              ```kotlin
              class CartViewModelTests {
                  @Test
                  fun `should show error dialog when no items loaded`() {
                      ...
                  }
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-{sample:-true}-q1"
            question: "Which of the following Kotlin snippets compile as-is? Assume they\
        \ appear in the same file at top level."
            explanation: "Identifiers cannot start with a digit and cannot be a reserved\
        \ keyword unless wrapped in backticks. Underscores are allowed. Backticked\
        \ names must be used both in declaration and call."
            repeatable: true
            answers:
              - "fun when() {}"
              - "fun `when`(): Unit {} ; fun main() { `when`() }"
              - "fun 2sum(a: Int, b: Int) = a + b"
              - "fun sum_2(a: Int, b: Int): Int { return a + b }"
              - "fun `should show error dialog when no items loaded`() {}"
            correct:
              - "fun `when`(): Unit {} ; fun main() { `when`() }"
              - "fun sum_2(a: Int, b: Int): Int { return a + b }"
              - "fun `should show error dialog when no items loaded`() {}"
          - type: "text"
            stepId: "lesson-06_functions-single-expression-functions-text"
            repeatable: false
            text: |-
              Many functions in real-life projects just have a single expression, so they start and immediately use the `return` keyword. The `square` function defined above is a great example. For such functions, instead of defining the body with braces, we can use the equality sign (`=`) and just specify the expression that calculates the result without specifying `return`. This is *single-expression syntax*, and functions that use it are called *single-expression functions*.
              
              ```kotlin
              fun square(x: Double): Double = x * x
              
              fun main() {
                  println(square(10.0)) // 100.0
              }
              ```
              
              An expression can be more complicated and take multiple lines. This is fine as long as its body is a single statement.
              
              ```kotlin
              fun findUsers(userFilter: UserFilter): List<User> =
                  userRepository
                      .getUsers()
                      .map { it.toDomain() }
                      .filter { userFilter.accepts(it) }
              ```
              
              When we use single-expression function syntax, we can infer the result type. We don’t need to, as explicit result type might still be useful for safety and readability, but we can.
              
              ```kotlin
              fun square(x: Double) = x * x
              
              fun main() {
                  println(square(10.0)) // 100.0
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-single-expression-functions-q1"
            question: "Which of the following are valid single-expression functions that\
        \ compile as written? Choose all that apply."
            explanation: |-
              - A single-expression function uses `=` followed by exactly one expression; it may span multiple lines.
              - 1, 2, and 4 are valid single-expression functions.
              - 3 is invalid because it contains multiple statements after `=`.
              - 5 is invalid because `if` used as an expression requires an `else` branch.
            repeatable: true
            answers:
              - "fun inc(x: Int): Int = x + 1"
              - "fun printHello(): Unit = println(\"Hello\")"
              - |-
                fun sumAndInc(a: Int, b: Int): Int =
                    val s = a + b
                    s + 1
              - |-
                fun filtered() = listOf(1, 2, 3)
                    .filter { it % 2 == 1 }
                    .map { it * it }
              - "fun wrong(): Int = if (true) { 1 }"
            correct:
              - "fun inc(x: Int): Int = x + 1"
              - "fun printHello(): Unit = println(\"Hello\")"
              - |-
                fun filtered() = listOf(1, 2, 3)
                    .filter { it % 2 == 1 }
                    .map { it * it }
          - type: "question-single-answer"
            stepId: "lesson-06_functions-single-expression-functions-q2"
            question: |-
              What is the inferred return type of the following single-expression function?
              
              ```kotlin
              fun oddSquares() = listOf(1, 2, 3, 4)
                  .filter { it % 2 == 1 }
                  .map { it * it }
              ```
            explanation: "`filter` and `map` on a `List<Int>` return a `List<Int>`, and\
        \ the result type is inferred."
            repeatable: false
            answers:
              - "List<Int>"
              - "Sequence<Int>"
              - "IntArray"
              - "Iterable<Int>"
            correct: "List<Int>"
          - type: "text"
            stepId: "lesson-06_functions-functions-on-all-levels-text"
            repeatable: false
            text: |-
              Kotlin allows us to define functions on many levels, but this isn’t very obvious as Java only allows functions inside classes. In Kotlin, we can define:
              * functions in files outside any classes, called **top-level functions**,
              * functions inside classes or objects, called **member functions** (they are also called **methods**),
              * functions inside functions, called **local functions** or **nested functions**.
              
              ```kotlin
              // Top-level function
              fun double(i: Int) = i * 2
              
              class A {
                  // Member function (method)
                  private fun triple(i: Int) = i * 3
              
                  // Member function (method)
                  fun twelveTimes(i: Int): Int {
                      // Local function
                      fun fourTimes() = double(double(i))
                      return triple(fourTimes())
                  }
              }
              
              // Top-level function
              fun main(args: Array<String>) {
                  double(1) // 2
                  A().twelveTimes(2) // 24
              }
              ```
              
              Top-level functions (defined outside classes) are often used to define utils, small but useful functions that help us with development. Top-level functions can be moved and split across files. In many cases, top-level functions in Kotlin are better than static functions in Java. Using them seems intuitive and convenient for developers.
              
              However, it’s a different story with local functions (defined inside functions). I often see that developers lack the imagination to use them (due to lack of exposure to them). Local functions are popular in JavaScript and Python, but there’s nothing like this in Java. The power of local functions is that they can directly access or modify local variables. They are used to extract repetitive code inside a function that operates on local variables. Longer functions should tell a "story", and local subroutines can wrap a block expression in a descriptive name.
              
              Take a look at the below example, which presents a function that validates a form. It checks conditions for the form fields. If a condition is not matched, we should show an error and change the local variable `isValid` to `false`, in which case we should not return from the function because we want to check all the fields (we should not stop at the first one that fails). This is an example of where a local function can help us extract repetitive behavior.
              
              ```kotlin
              fun validateForm() {
                  var isValid = true
                  val errors = mutableListOf<String>()
                  fun addError(view: FormView, error: String) {
                      view.error = error
                      errors += error
                      isValid = false
                  }
              
                  val email = emailView.text
                  if (email.isBlank()) {
                      addError(emailView, "Email cannot be empty or blank")
                  }
              
                  val pass = passView.text.trim()
                  if (pass.length < 3) {
                      addError(passView, "Password too short")
                  }
              
                  if (isValid) {
                      tryLogin(email, pass)
                  } else {
                      showErrors(errors)
                  }
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-06_functions-functions-on-all-levels-q1"
            question: "You refactor `validateForm` by moving the local function `addError`\
        \ out as a top-level function with the same body. Why does this fail to compile?"
            explanation: "Local functions form a closure over the surrounding scope. When\
        \ moved to top-level, `errors` and `isValid` are out of scope (unresolved\
        \ references)."
            repeatable: true
            answers:
              - "Top-level functions cannot access function-local variables like `errors`\
        \ or `isValid`; they’re out of scope."
              - "Top-level functions must be marked `inline` to modify variables."
              - "Kotlin forbids top-level functions from mutating properties on parameters\
        \ (like `view.error`)."
              - "It compiles, but changes to `isValid` won’t be visible after the function\
        \ returns."
            correct: "Top-level functions cannot access function-local variables like `errors`\
        \ or `isValid`; they’re out of scope."
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-functions-on-all-levels-q2"
            question: |-
              Given the code:
              
              ```kotlin
              fun double(i: Int) = i * 2
              
              class A {
                  private fun triple(i: Int) = i * 3
                  fun twelveTimes(i: Int): Int {
                      fun fourTimes() = double(double(i))
                      return triple(fourTimes())
                  }
              }
              ```
              Select all correct statements:
            explanation: |-
              - `twelveTimes(2)` computes `double(double(2)) = 8`, then `triple(8) = 24`.
              - `triple` is `private`, so it’s not accessible from outside `A`.
              - Local function `fourTimes` captures `i` from `twelveTimes` and can call the top-level `double`.
            repeatable: false
            answers:
              - "`A().twelveTimes(2)` returns `24`."
              - "`A().triple(3)` is accessible from outside `A`."
              - "The local function `fourTimes` can access the parameter `i` of `twelveTimes`."
              - "The local function `fourTimes` cannot call the top-level function `double`."
            correct:
              - "`A().twelveTimes(2)` returns `24`."
              - "The local function `fourTimes` can access the parameter `i` of `twelveTimes`."
          - type: "text"
            stepId: "lesson-06_functions-parameters-and-arguments-text"
            repeatable: false
            text: |-
              A variable defined as a part of a function definition is called a **parameter**. The value that is passed when we call a function is called an **argument**.
              
              ```kotlin
              fun square(x: Double) = x * x // x is a parameter
              
              fun main() {
                  println(square(10.0)) // 10.0 is an argument
                  println(square(0.0)) // 0.0 is an argument
              }
              ```
              
              In Kotlin, parameters are read-only, so we cannot reassign their value.
              
              ```kotlin
              fun a(i: Int) {
                  i = i + 10 // ERROR
                  // ...
              }
              ```
              
              If you need to modify a parameter variable, the only way is to shadow it with a local variable that is mutable.
              
              ```kotlin
              fun a(i: Int) {
                  var i = i + 10
                  // ...
              }
              ```
              
              This is possible but discouraged. A parameter holds a value that was used as an argument, and this value should not change. A local read-write variable represents a different concept and should therefore have a different name.
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-parameters-and-arguments-q1"
            question: "Which snippets compile without errors? Select all that apply."
            explanation: "Parameters in Kotlin are read-only and cannot be reassigned. You\
        \ can shadow a parameter with a new local variable (e.g., `var i = i + 10`).\
        \ Reassigning a `val` is illegal."
            repeatable: true
            answers:
              - "fun a(i: Int) { i = i + 10 }"
              - "fun b(i: Int) { var i = i + 10 }"
              - "fun c(x: Int) { val y = x; y = 2 }"
              - "fun d(x: Int) { var y = x; y++ }"
              - "fun e(x: Int) { val z = x * 2 }"
            correct:
              - "fun b(i: Int) { var i = i + 10 }"
              - "fun d(x: Int) { var y = x; y++ }"
              - "fun e(x: Int) { val z = x * 2 }"
          - type: "question-single-answer"
            stepId: "lesson-06_functions-parameters-and-arguments-q2"
            question: "What does this program print? fun f(x: Int): Int { var x = x + 1;\
        \ x += 2; return x } fun main() = println(f(5))"
            explanation: "The parameter `x` (5) is read-only; it’s shadowed by a local `var\
        \ x = x + 1` (becomes 6), then incremented by 2 to 8."
            repeatable: false
            answers:
              - "5"
              - "6"
              - "7"
              - "8"
            correct: "8"
          - type: "text"
            stepId: "lesson-06_functions-`unit`-return-type-text"
            repeatable: false
            text: |-
              In Kotlin, all functions have a result type, so every function call is an expression. When a type is not specified, the default result type is `Unit`, and the default result value is the `Unit` object.
              
              ```kotlin
              fun someFunction() {}
              
              fun main() {
                  val res: Unit = someFunction()
                  println(res) // kotlin.Unit
              }
              ```
              
              `Unit` is just a very simple object that is used as a placeholder when nothing else is returned. When you specify a function without an explicit result type, its result type will implicitly be `Unit`. When you define a function without `return` in the last line, it is the same as using `return` with no value. Using `return` with no value is the same as returning `Unit`.
              
              ```kotlin
              fun a() {}
              
              // the same as
              fun a(): Unit {}
              
              // the same as
              fun a(): Unit {
                  return
              }
              
              // the same as
              fun a(): Unit {
                  return Unit
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-`unit`-return-type-q1"
            question: |-
              Given:
              
              ```kotlin
              fun a() {}
              ```
              Which of the following function definitions are exactly equivalent to `a()` in return type and behavior (ignoring the function name)?
            explanation: "All correct options explicitly or implicitly return `Unit` with\
        \ no extra side effects. The `Any` return type changes the signature, so it\
        \ is not equivalent."
            repeatable: true
            answers:
              - "fun b(): Unit {}"
              - "fun c(): Unit { return }"
              - "fun d(): Unit = Unit"
              - "fun e() = Unit"
              - "fun f(): Any = Unit"
            correct:
              - "fun b(): Unit {}"
              - "fun c(): Unit { return }"
              - "fun d(): Unit = Unit"
              - "fun e() = Unit"
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-`unit`-return-type-q2"
            question: "Inside a function declared as `fun g(): Unit { /* ... */ }`, which\
        \ `return` forms compile?"
            explanation: "`return` with no value, `return Unit`, and returning any expression\
        \ of type `Unit` (e.g., `println(...)`) are valid. `null` and `42` are not\
        \ `Unit`."
            repeatable: false
            answers:
              - "return"
              - "return Unit"
              - "return println(\"OK\")"
              - "return null"
              - "return 42"
            correct:
              - "return"
              - "return Unit"
              - "return println(\"OK\")"
          - type: "text"
            stepId: "lesson-06_functions-vararg-parameters-text"
            repeatable: false
            text: |-
              Each parameter expects one argument, except for parameters marked with the `vararg` modifier. Such parameters accept any number of arguments.
              
              ```kotlin
              fun a(vararg params: Int) {}
              
              fun main() {
                  a()
                  a(1)
                  a(1, 2)
                  a(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
              }
              ```
              
              A good example of such a function is `listOf`, which produces a list from values used as arguments.
              
              ```kotlin
              fun main() {
                  println(listOf(1, 3, 5, 6)) // [1, 3, 5, 6]
                  println(listOf("A", "B", "C")) // [A, B, C]
              }
              ```
              
              This means a vararg parameter holds a collection of values, therefore it cannot have the type of a single object. So the vararg parameter represents an array of the declared type, and we can iterate over arrays using a for loop (which will be explained in more depth in the next chapter).
              
              ```kotlin
              fun concatenate(vararg strings: String): String {
                  // The type of `strings` is Array<String>
                  var accumulator = ""
                  for (s in strings) accumulator += s
                  return accumulator
              }
              
              fun sum(vararg ints: Int): Int {
                  // The type of `ints` is IntArray
                  var accumulator = 0
                  for (i in ints) accumulator += i
                  return accumulator
              }
              
              fun main() {
                  println(concatenate()) //
                  println(concatenate("A", "B")) // AB
                  println(sum()) // 0
                  println(sum(1, 2, 3)) // 6
              }
              ```
              
              We will get back to vararg parameters in the chapter *Collections*, in the section dedicated to arrays.
          - type: "question-single-answer"
            stepId: "lesson-06_functions-vararg-parameters-q1"
            question: "In Kotlin, given `fun sum(vararg ints: Int)`, what is the compile-time\
        \ type of `ints` inside the function body?"
            explanation: "`vararg` parameters are arrays inside the function. For primitive\
        \ element types, Kotlin uses specialized primitive arrays, so `Int` becomes\
        \ `IntArray`."
            repeatable: true
            answers:
              - "IntArray"
              - "Array<Int>"
              - "List<Int>"
              - "Sequence<Int>"
            correct: "IntArray"
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-vararg-parameters-q2"
            question: "Choose all correct statements about `vararg` parameters based on\
        \ the section."
            explanation: |-
              - Vararg accepts any number of arguments, including zero.
              - Inside the function, a `vararg` of reference type becomes `Array<T>`; of primitive type becomes a primitive array.
              - `listOf` is a standard example of a vararg function.
              - You declare a vararg with the element type, not an array type, and you can iterate it with `for`.
            repeatable: true
            answers:
              - "You can call a vararg function with zero arguments."
              - "Inside `fun concatenate(vararg strings: String)`, `strings` has type `Array<String>`."
              - "`listOf` is defined with a vararg parameter."
              - "A vararg parameter must be declared with an array type (e.g., `vararg xs:\
        \ Array<Int>`)."
              - "A vararg parameter cannot be iterated with a for loop."
            correct:
              - "You can call a vararg function with zero arguments."
              - "Inside `fun concatenate(vararg strings: String)`, `strings` has type `Array<String>`."
              - "`listOf` is defined with a vararg parameter."
          - type: "text"
            stepId: "lesson-06_functions-named-parameter-syntax-and-default-arguments-text"
            repeatable: false
            text: |-
              When we declare functions, we often specify optional parameters. A good example is `joinToString`, which transforms an iterable into a `String`. It can be used without any arguments, or we might change its behavior with concrete arguments.
              
              ```kotlin
              fun main() {
                  val list = listOf(1, 2, 3, 4)
                  println(list.joinToString()) // 1, 2, 3, 4
                  println(list.joinToString(separator = "-")) //  1-2-3-4
                  println(list.joinToString(limit = 2)) //  1, 2, ...
              }
              ```
              
              Many more functions in Kotlin use optional parametrization, but how is this done? It is enough to place an equality sign after a parameter and then specify the default value.
              
              ```kotlin
              fun cheer(how: String = "Hello,", who: String = "World") {
                  println("$how $who")
              }
              
              fun main() {
                  cheer() // Hello, World
                  cheer("Hi") // Hi World
              }
              ```
              
              Values specified this way are created on-demand when there is no parameter for their position. This is not Python, therefore they are not stored statically, which is why it’s safe to use mutable values as default arguments.
              
              ```kotlin
              fun addOneAndPrint(list: MutableList<Int> = mutableListOf()) {
                  list.add(1)
                  println(list)
              }
              
              fun main() {
                  addOneAndPrint() // [1]
                  addOneAndPrint() // [1]
                  addOneAndPrint() // [1]
              }
              ```
              
              > In Python, the analogous code would produce `[1]`, `[1, 1]`, and `[1, 1, 1]`.
              
              When we call a function, we can specify an argument’s position by its parameter name, like in the example below. This way, we can specify later optional positions without specifying previous ones. This is called *named parameter syntax*.
              
              ```kotlin
              fun cheer(how: String = "Hello,", who: String = "World") {
                  print("$how $who")
              }
              
              fun main() {
                  cheer(who = "Group") // Hello, Group
              }
              ```
              
              Named parameter syntax is very useful for improving our code’s readability. When an argument's meaning is not clear, it is better to specify a parameter name for it.
              
              ```kotlin
              fun main() {
                  val list = listOf(1, 2, 3, 4)
                  println(list.joinToString("-")) // 1-2-3-4
                  // better
                  println(list.joinToString(separator = "-")) //  1-2-3-4
              }
              ```
              
              Naming arguments also prevents mistakes that are a result of changing parameter positions.
              
              ```kotlin
              class User(
                  val name: String,
                  val surname: String,
              )
              
              val user = User(
                  name = "Norbert",
                  surname = "Moskała",
              )
              ```
              
              In the above example, without named arguments a developer might flip the `name` and `surname` positions; if named arguments were not used here, this would lead to an incorrect name and surname in the object. Named arguments protect us from such situations.
              
              It is considered a good practice to use the named arguments convention when we call functions with many arguments, some of whose meanings might not be obvious to developers reading our code in the future.
          - type: "question-single-answer"
            stepId: "lesson-06_functions-named-parameter-syntax-and-default-arguments-q1"
            question: |-
              Given:
              
              ```kotlin
              fun addOneAndPrint(list: MutableList<Int> = mutableListOf()) {
                  list.add(1)
                  println(list)
              }
              
              fun main() {
                  addOneAndPrint()
                  addOneAndPrint()
                  addOneAndPrint()
              }
              ```
              What is the output?
            explanation: "Default arguments are evaluated on each call in Kotlin. A new\
        \ mutable list is created every time, so the list does not accumulate elements\
        \ across calls."
            repeatable: true
            answers:
              - "Line1: [1], Line2: [1], Line3: [1]"
              - "Line1: [1], Line2: [1, 1], Line3: [1, 1, 1]"
              - "Line1: [1, 1, 1], Line2: [1, 1, 1], Line3: [1, 1, 1]"
              - "Compilation error: default value must be constant"
            correct: "Line1: [1], Line2: [1], Line3: [1]"
          - type: "question-single-answer"
            stepId: "lesson-06_functions-named-parameter-syntax-and-default-arguments-q2"
            question: |-
              Given:
              
              ```kotlin
              fun cheer(how: String = "Hello,", who: String = "World") {
                  print("$how $who")
              }
              ```
              Which call sets only the `who` parameter to "Group" while leaving `how` at its default?
            explanation: "Named arguments let you specify a later parameter without providing\
        \ earlier ones. Positional \"Group\" would target `how`; other options set\
        \ both parameters."
            repeatable: false
            answers:
              - "cheer(\"Group\")"
              - "cheer(who = \"Group\")"
              - "cheer(how = \"Hello,\", who = \"Group\")"
              - "cheer(\"Hello,\", who = \"Group\")"
            correct: "cheer(who = \"Group\")"
          - type: "text"
            stepId: "lesson-06_functions-function-overloading-text"
            repeatable: false
            text: |-
              In Kotlin, we can define functions with the same name in the same scope (file or class) as long as they have different parameter types or a different number of parameters. This is known as function **overloading**. Kotlin decides which function to execute based on the types of the specified arguments.
              
              ```kotlin
              fun a(a: Any) = "Any"
              fun a(i: Int) = "Int"
              fun a(l: Long) = "Long"
              
              fun main() {
                  println(a(1)) // Int
                  println(a(18L)) // Long
                  println(a("ABC")) // Any
              }
              ```
              
              A practical example of function overloading is providing multiple function variants for user convenience.
              
              ```kotlin
              import java.math.BigDecimal
              
              class Money(val amount: BigDecimal, val currency: String)
              
              fun pln(amount: BigDecimal) = Money(amount, "PLN")
              fun pln(amount: Int) = pln(amount.toBigDecimal())
              fun pln(amount: Double) = pln(amount.toBigDecimal())
              ```
          - type: "question-single-answer"
            stepId: "lesson-06_functions-function-overloading-q1"
            question: |-
              Given the overloads:
              
              ```kotlin
              fun a(x: Any) = "Any"
              fun a(x: Number) = "Number"
              fun a(x: Int) = "Int"
              ```
              What does `println(a(1L))` print?
            explanation: "The argument `1L` is a Long. There is no `Long` overload, so Kotlin\
        \ picks the most specific applicable overload among `Any` and `Number`, which\
        \ is `Number`."
            repeatable: false
            answers:
              - "Int"
              - "Number"
              - "Any"
              - "Compilation error"
            correct: "Number"
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-function-overloading-q2"
            question: "Given `fun a(x: Int) {}`, which of the following are valid overloads\
        \ in the same scope?"
            explanation: "Overloads must differ by parameter types or number of parameters.\
        \ Changing return type or only parameter names does not create a distinct\
        \ overload."
            repeatable: true
            answers:
              - "fun a(x: Long) {}"
              - "fun a(x: Int): String"
              - "fun a(x: Int, y: Int) {}"
              - "fun a(y: Int) {}"
              - "fun a(x: Number) {}"
            correct:
              - "fun a(x: Long) {}"
              - "fun a(x: Int, y: Int) {}"
              - "fun a(x: Number) {}"
          - type: "text"
            stepId: "lesson-06_functions-infix-syntax-text"
            repeatable: false
            text: "Methods with a single parameter can use the `infix` modifier, which allows\
        \ a special kind of function call: without the dot and the argument parentheses.\n\
        \n```kotlin\nclass View\nclass ViewInteractor {\n    infix fun clicks(view:\
        \ View) { \n        // ...\n    }\n}\n\nfun main() {\n    val aView = View()\n\
        \    val interactor = ViewInteractor()\n\n    // regular notation\n    interactor.clicks(aView)\n\
        \    // infix notation\n    interactor clicks aView\n}\n```\n\nThis notation\
        \ is used by some functions from Kotlin stdlib (Standard Library), like the\
        \ `and`, `or` and `xor` bitwise operations on numbers (presented in the chapter\
        \ *Basic types, their literals and operations*).\n\n```kotlin\nfun main()\
        \ {\n    // infix notation\n    println(0b011 and 0b001) // 1, that is 0b001\n\
        \    println(0b011 or 0b001) // 3, that is 0b011\n    println(0b011 xor 0b001)\
        \ // 2, that is 0b010\n\n    // regular notation\n    println(0b011.and(0b001))\
        \ // 1, that is 0b001\n    println(0b011.or(0b001)) // 3, that is 0b011\n\
        \    println(0b011.xor(0b001)) // 2, that is 0b010\n}\n```\n\nInfix notation\
        \ is only for our convenience. It is an example of Kotlin syntactic sugar\
        \ - syntax that is designed only to make things easier to read or express.\n\
        \n> Regarding the position of operators or functions in relation to their\
        \ operands or arguments, we use three kinds of position types: prefix, infix,\
        \ and postfix. Prefix notation is when we place the operator or function **before**\
        \ the operands or arguments. A good example is a plus or minus placed before\
        \ a single number (like `+12` or `-3.14`). One might argue that a top-level\
        \ function call also uses prefix notation because the function name comes\
        \ before the arguments (like `maxOf(10, 20)`). Infix notation is when we place\
        \ the operator or function **between** the operands or arguments. A good example\
        \ is a plus or minus between two numbers (like `1 + 2` or `10 - 7`). One might\
        \ argue that a method call with arguments also uses infix notation because\
        \ the function name comes between the receiver (the object we call this method\
        \ on) and arguments (like `account.add(money)`). In Kotlin, we use the term\
        \ \"infix notation\" more restrictively to reference the special notation\
        \ we use for methods with the `infix` modifier. Postfix notation is when we\
        \ place the operator or function **after** the operands or arguments. In modern\
        \ programming, postfix notation is practically not used anymore. One might\
        \ argue that calling a method with no arguments is postfix notation, as in\
        \ `str.uppercase()`."
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-infix-syntax-q1"
            question: |-
              Given:
              
              ```kotlin
              class View
              class ViewInteractor {
                  infix fun clicks(view: View) {}
                  fun taps(view: View) {}
              }
              
              val aView = View()
              val interactor = ViewInteractor()
              ```
              
              Which of the following are valid infix calls that compile?
            explanation: |-
              - Infix calls require a function marked with `infix` and exactly one argument, called without dot/parentheses.
              - `interactor clicks aView` and `0b011 and 0b001` meet these rules.
              - `taps` isn't infix; dotted forms are regular calls, not infix.
            repeatable: false
            answers:
              - "interactor clicks aView"
              - "interactor taps aView"
              - "interactor.clicks(aView)"
              - "0b011 and 0b001"
              - "0b011.and(0b001)"
            correct:
              - "interactor clicks aView"
              - "0b011 and 0b001"
          - type: "question-single-answer"
            stepId: "lesson-06_functions-infix-syntax-q2"
            question: "You want to call `logger log \"Started\"` using infix notation. Which\
        \ declaration enables this?"
            explanation: "An infix function must be a member (or extension) with the `infix`\
        \ modifier and exactly one parameter."
            repeatable: false
            answers:
              - "class Logger { infix fun log(message: String) {} }"
              - "class Logger { fun log(message: String) {} }"
              - "class Logger { infix fun log() {} }"
              - "class Logger { infix fun log(message: String, level: Int) {} }"
            correct: "class Logger { infix fun log(message: String) {} }"
          - type: "text"
            stepId: "lesson-06_functions-function-formatting-text"
            repeatable: false
            text: |-
              When a function declaration (name, parameters, and result type) is too long to fit in a single line, we split it such that every parameter definition is on a different line, and the beginning and end of the function declaration are also on separate lines.
              
              ```kotlin
              fun veryLongFunction(
                  param1: Param1Type,
                  param2: Param2Type,
                  param3: Param3Type,
              ): ResultType {
                  // body
              }
              ```
              
              Classes are formatted in the same way:
              
              ```kotlin
              class VeryLongClass(
                  val property1: Type1,
                  val property2: Type2,
                  val property3: Type3,
              ) : ParentClass(), Interface1, Interface2 {
                  // body
              }
              ```
              
              When a function call is too long, we format it similarly: each argument is on a different line. However, there are exceptions to this rule, such as keeping multiple vararg parameters on the same line.
              
              ```kotlin
              fun makeUser(
                  name: String,
                  surname: String,
              ): User = User(
                  name = name,
                  surname = surname,
              )
              
              class User(
                  val name: String,
                  val surname: String,
              )
              
              fun main() {
                  val user = makeUser(
                      name = "Norbert",
                      surname = "Moskała",
                  )
              
                  val characters = listOf(
                      "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
                      "K", "L", "M", "N", "O", "P", "R", "S", "T", "U",
                      "W", "X", "Y", "Z",
                  )
              }
              ```
              
              Notice that when I specify arguments or parameters, I sometimes add a comma at the end. This is a so-called **trailing comma**. Such notation is optional.
              
              ```kotlin
              fun printName(
                  name: String,
                  surname: String, // <- trailing comma
              ) {
                  println("$name $surname")
              }
              
              fun main() {
                  printName(
                      name = "Norbert",
                      surname = "Moskała", // <- trailing comma
                  )
              }
              ```
              
              I like using trailing comma notation because it makes it easier to add another element in the future. Without it, adding or removing an element requires not only a new line but also an additional comma after the last element. This leads to meaningless line modifications on Git, which makes it harder to read what has actually changed in our project. Some developers don’t like trailing comma notation, which can sometimes lead to a holy war. Decide in your team if you like it or not, and be consistent in your projects.
              
              ![Adding a parameter and an argument on git when a trailing comma is used.](trailing_comma_used.png)
              
              ![Adding a parameter and an argument on git when a trailing comma is not used.](trailing_comma_not_used.png)
          - type: "question-single-answer"
            stepId: "lesson-06_functions-function-formatting-q1"
            question: |-
              Given the function:
              
              ```kotlin
              fun log(tag: String, vararg messages: String, level: Int) {}
              ```
              
              Which call best demonstrates the section's exception for long calls (keeping multiple vararg arguments on the same line, while other arguments are on separate lines)?
            explanation: "For long calls, each argument goes on its own line, with an exception\
        \ allowing multiple vararg arguments to stay on one line. Option A shows exactly\
        \ that. B violates the per-argument line rule; C is not a long/multiline call;\
        \ D is invalid ordering (vararg items after a named argument)."
            repeatable: true
            answers:
              - |-
                ```kotlin
                log(
                    tag = "Auth",
                    "Started", "step1", "done",
                    level = 2,
                )
                ```
              - |-
                ```kotlin
                log(
                    tag = "Auth", level = 2,
                    "Started",
                    "step1",
                    "done",
                )
                ```
              - |-
                ```kotlin
                log(tag = "Auth", "Started", "step1", "done", level = 2)
                ```
              - |-
                ```kotlin
                log(
                    tag = "Auth",
                    "Started",
                    level = 2, "step1", "done",
                )
                ```
            correct: |-
              ```kotlin
              log(
                  tag = "Auth",
                  "Started", "step1", "done",
                  level = 2,
              )
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-function-formatting-q2"
            question: "According to the section, where may a trailing comma be used?"
            explanation: "The section shows trailing commas used after parameters and after\
        \ arguments in multiline calls. Other locations are not covered here."
            repeatable: false
            answers:
              - "After the last parameter in a multiline function declaration"
              - "After the last argument in a multiline function call"
              - "After the last supertype in a class header"
              - "After the last enum entry in an enum class"
              - "After the last character in a string literal"
            correct:
              - "After the last parameter in a multiline function declaration"
              - "After the last argument in a multiline function call"
          - type: "text"
            stepId: "lesson-06_functions-summary-text"
            repeatable: false
            text: "As you can see, functions in Kotlin have a lot of powerful features.\
        \ Single-expression syntax makes simple functions shorter. Named and default\
        \ arguments help us improve safety and readability. The `Unit` result type\
        \ makes every function call an expression. Vararg parameters allow any number\
        \ of arguments to be used for one parameter position. Infix notation introduces\
        \ a more convenient way to call certain kinds of functions. Trailing commas\
        \ minimize the number of changes on git. All this is for our convenience.\
        \ For now though, let's move on to another topic: using a for-loop."
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-summary-q1"
            question: "Which declarations can be called using infix notation (e.g., `a op\
        \ b`)?"
            explanation: "An infix function must be marked `infix`, be a member or extension,\
        \ take exactly one parameter, and that parameter cannot be `vararg` or have\
        \ a default value."
            repeatable: true
            answers:
              - "infix fun Int.add(other: Int) = this + other"
              - "infix fun Int.bar(other: Int = 0) = this + other"
              - "fun Int.baz(other: Int) = this + other"
              - "infix fun Int.qux(vararg xs: Int) = this + xs.sum()"
              - "class Box { infix fun put(item: String) { /*...*/ } }"
            correct:
              - "infix fun Int.add(other: Int) = this + other"
              - "class Box { infix fun put(item: String) { /*...*/ } }"
          - type: "question-multiple-answer"
            stepId: "lesson-06_functions-summary-q2"
            question: |-
              Given the function with trailing commas and a middle vararg:
              
              ```kotlin
              fun join(
                  prefix: String = "[",
                  vararg parts: String,
                  suffix: String = "]",
              ) = prefix + parts.joinToString() + suffix
              ```
              Which calls compile?
            explanation: "When a `vararg` is not last, all arguments that follow must be\
        \ named. Also, once you use a named argument, all subsequent arguments must\
        \ be named. The valid calls either keep all positional args before `suffix`\
        \ or use names appropriately."
            repeatable: true
            answers:
              - "join()"
              - "join(\"(\", \"a\", \"b\", suffix = \")\")"
              - "join(prefix = \"(\", \"a\", \"b\")"
              - "join(\"(\", suffix = \")\")"
              - "join(suffix = \")\", \"a\")"
              - "join(prefix = \"(\", suffix = \")\")"
            correct:
              - "join()"
              - "join(\"(\", \"a\", \"b\", suffix = \")\")"
              - "join(\"(\", suffix = \")\")"
              - "join(prefix = \"(\", suffix = \")\")"
      - lessonId: "lesson-the-power-of-the-for-loop"
        name: "The power of the for-loop"
        steps:
          - type: "text"
            stepId: "lesson-07_for-#-the-power-of-the-for-loop-text"
            repeatable: false
            text: "In Java and other older languages, a for-loop typically has three parts:\
        \ the first initializes the variable before the loop starts; the second contains\
        \ the condition for the execution of the code block; the third is executed\
        \ after the code block.\n\n```    \n// Java\nfor(int i=0; i < 5; i++){\n \
        \  System.out.println(i);\n}\n```\n\nHowever, this is considered complicated\
        \ and error-prone. Just consider a situation in which someone uses `>` or\
        \ `<=` instead of `<`. Such a small difference is not easy to notice, but\
        \ it essentially influences the behavior of this for-loop.\n\nAs an alternative\
        \ to this classic for-loop, many languages have introduced a modern alternative\
        \ for iterating over collections. This is why, in languages like Java or JavaScript,\
        \ there are two completely different kinds of for-loops, both of which are\
        \ defined with the same `for` keyword. Kotlin has simplified this. In Kotlin,\
        \ we have one universal for-loop that can be expressively used to iterate\
        \ over a collection, a map, a range of numbers, and much more.\n\nIn general,\
        \ a for-loop is used in Kotlin to iterate over something that is iterable.\n\
        \n{width: 60%}\n![](for_described.jpg)\n\nWe can iterate over lists or sets.\n\
        \n```kotlin\nfun main() {\n    val list = listOf(\"A\", \"B\", \"C\")\n  \
        \  for (letter in list) {\n        print(letter)\n    }\n\n    // Variable\
        \ type can be explicit\n    for (str: String in setOf(\"D\", \"E\", \"F\"\
        )) {\n        print(str)\n    }\n}\n// ABCDEF\n```\n\nWe can also iterate\
        \ over any other object as long as it contains the `iterator` method with\
        \ no parameters, plus the `Iterator` result type and the `operator` modifier.\
        \ The easiest way to define this operator method is to make your class implement\
        \ the `Iterable` interface (then you do not need to define `operator` modifier\
        \ yourself, as it is inherited from `Iterable`). In the below example, we\
        \ define a `Tree` class that implements `Iterable<String>`, so we must override\
        \ the `iterator` method, and we can iterate over an instance of this class.\n\
        \n```kotlin\nfun main() {\n    val tree = Tree(\n        value = \"B\",\n\
        \        left = Tree(\"A\"),\n        right = Tree(\"D\", left = Tree(\"C\"\
        ))\n    )\n\n    for (value in tree) {\n        print(value) // ABCD\n   \
        \ }\n}\n\nclass Tree(\n    val value: String,\n    val left: Tree? = null,\n\
        \    val right: Tree? = null,\n) : Iterable<String> {\n\n    override fun\
        \ iterator(): Iterator<String> = iterator {\n        if (left != null) yieldAll(left)\n\
        \        yield(value)\n        if (right != null) yieldAll(right)\n    }\n\
        }\n```\n\nThe inferred variable type of the variable defined inside the for-loop\
        \ comes from the `Iterable` type argument. When we iterate over `Iterable<User>`,\
        \ the inferred element type will be `User`. When we iterate over `Iterable<Long?>`,\
        \ the inferred element type will be `Long?`. The same applies to all other\
        \ types.\n\nThis mechanism, which relies on `Iterable`, is really powerful\
        \ and allows us to cover numerous use cases, one of the most notable of which\
        \ is the use of *ranges* to express progressions."
          - type: "question-multiple-answer"
            stepId: "lesson-07_for-#-the-power-of-the-for-loop-q1"
            question: "To make `for (x in myObj)` compile for a custom class in Kotlin,\
        \ which statements are true?"
            explanation: "A Kotlin for-loop lowers to `myObj.iterator()`; it must be an\
        \ operator with no parameters returning `kotlin.collections.Iterator<...>`.\
        \ Implementing `Iterable<T>` satisfies this. `Sequence<T>` is not required."
            repeatable: true
            answers:
              - "Provide an operator function `iterator()` with no parameters."
              - "`iterator()` must return `kotlin.collections.Iterator<...>`."
              - "Implementing `Iterable<T>` is sufficient."
              - "You must implement `Sequence<T>`."
              - "Support for Java-style `for(init; cond; step)` is required."
            correct:
              - "Provide an operator function `iterator()` with no parameters."
              - "`iterator()` must return `kotlin.collections.Iterator<...>`."
              - "Implementing `Iterable<T>` is sufficient."
          - type: "question-multiple-answer"
            stepId: "lesson-07_for-#-the-power-of-the-for-loop-q2"
            question: |-
              Given `val items: Iterable<Long?> = listOf(1L, null)`, which explicit loop variable type annotations compile?
              
              ```
              for (x: ??? in items) { /* ... */ }
              ```
            explanation: "The element type is `Long?`. The loop variable type must be the\
        \ same or a supertype. `Long?` and `Any?` work; `Long` and `Any` do not (nullability\
        \ mismatch)."
            repeatable: false
            answers:
              - "Long"
              - "Long?"
              - "Any"
              - "Any?"
            correct:
              - "Long?"
              - "Any?"
          - type: "text"
            stepId: "lesson-07_for-ranges-text"
            repeatable: false
            text: "In Kotlin, if you place two dots between two numbers, like `1..5`, you\
        \ create an `IntRange`. This class implements `Iterable<Int>`, so we can use\
        \ it in a for-loop:\n\n```kotlin\nfun main() {\n    for (i in 1..5) {\n  \
        \      print(i)\n    }\n}\n// 12345\n```\n\nThis solution is efficient as\
        \ well as convenient because the Kotlin compiler optimizes its performance\
        \ under the hood.\n\nRanges created with `..` include the last value (which\
        \ means they are **closed ranges**). If you want a range that stops before\
        \ the last value, use the `..<` operator or `until` infix function instead.\n\
        \n```kotlin\nfun main() {\n    for (i in 1..<5) {\n        print(i)\n    }\n\
        }\n// 1234\n```\n\n```kotlin\nfun main() {\n    for (i in 1 until 5) {\n \
        \       print(i)\n    }\n}\n// 1234\n```\n\nBoth `..` and `..<` start with\
        \ the value on their left and progress toward the right number in increments\
        \ of one. If you use a bigger number on the left, the result is an empty range.\n\
        \n```kotlin\nfun main() {\n    for (i in 5..1) {\n        print(i)\n    }\n\
        \    for (i in 5..<1) {\n        print(i)\n    }\n}\n// (nothing is printed)\n\
        ```\n\nIf you want to iterate in the other direction, from larger to smaller\
        \ numbers, use the `downTo` function.\n\n```kotlin\nfun main() {\n    for\
        \ (i in 5 downTo 1) {\n        print(i)\n    }\n}\n// 54321\n```\n\nThe default\
        \ step in all those cases is `1`. If you want to use a different step, you\
        \ should use the `step` infix function.\n\n```kotlin\nfun main() {\n    for\
        \ (i in 1..10 step 3) {\n        print(\"$i \")\n    }\n    println()\n  \
        \  for (i in 1..<10 step 3) {\n        print(\"$i \")\n    }\n    println()\n\
        \    for (i in 10 downTo 1 step 3) {\n        print(\"$i \")\n    }\n}\n//\
        \ 1 4 7 10 \n// 1 4 7 \n// 10 7 4 1 \n```"
          - type: "question-multiple-answer"
            stepId: "lesson-07_for-ranges-q1"
            question: "Which of the following for-loops iterate over no elements (print\
        \ nothing)?"
            explanation: "`..` and `..<` progress forward; if start > end, the range/progression\
        \ is empty. `downTo` progresses backward; if start < end, it’s empty. `until`/`..<`\
        \ exclude the end, so `start == end` is empty."
            repeatable: true
            answers:
              - "for (i in 5..1) print(i)"
              - "for (i in 1 until 1) print(i)"
              - "for (i in 1 downTo 5) print(i)"
              - "for (i in 5 downTo 1 step 2) print(i)"
              - "for (i in 1..<2) print(i)"
            correct:
              - "for (i in 5..1) print(i)"
              - "for (i in 1 until 1) print(i)"
              - "for (i in 1 downTo 5) print(i)"
          - type: "question-multiple-answer"
            stepId: "lesson-07_for-ranges-q2"
            question: "Which loops iterate over exactly the values 1, 4, 7 in this order\
        \ (no other values)?"
            explanation: "`1..<10` and `1 until 10` exclude 10; with `step 3` they yield\
        \ 1,4,7. `1..9 step 3` also yields 1,4,7. `1..10 step 3` includes 10, and\
        \ `downTo` reverses order."
            repeatable: true
            answers:
              - "for (i in 1 until 10 step 3) print(i)"
              - "for (i in 1..<10 step 3) print(i)"
              - "for (i in 1..9 step 3) print(i)"
              - "for (i in 1..10 step 3) print(i)"
              - "for (i in 10 downTo 1 step 3) print(i)"
            correct:
              - "for (i in 1 until 10 step 3) print(i)"
              - "for (i in 1..<10 step 3) print(i)"
              - "for (i in 1..9 step 3) print(i)"
          - type: "text"
            stepId: "lesson-07_for-break-and-continue-text"
            repeatable: false
            text: |-
              Inside loops, we can use the `break` and `continue` keywords:
              * `break` - terminates the nearest enclosing loop.
              * `continue` - proceeds to the next step of the nearest enclosing loop.
              
              ```kotlin
              fun main() {
                  for (i in 1..5) {
                      if (i == 3) break
                      print(i)
                  }
                  // 12
              
                  println()
              
                  for (i in 1..5) {
                      if (i == 3) continue
                      print(i)
                  }
                  // 1245
              }
              ```
              
              Both are used rather rarely, and I had trouble finding even one real-life example in the commercial projects I have co-created. I also assume that they are well-known to developers who’ve come to Kotlin from older languages. This is why I present these keywords so briefly.
          - type: "question-single-answer"
            stepId: "lesson-07_for-break-and-continue-q1"
            question: |-
              What does the following Kotlin program print?
              
              ```kotlin
              fun main() {
                  for (i in 1..3) {
                      for (j in 1..3) {
                          if (i * j == 4) break
                          print("$i$j")
                      }
                  }
              }
              ```
            explanation: "break stops only the nearest (inner) loop. For i=2, when j=2,\
        \ i*j==4 triggers break of the inner loop; the outer loop continues with i=3."
            repeatable: false
            answers:
              - "11121321313233"
              - "11121314213233"
              - "111213213233"
              - "1121312231"
            correct: "11121321313233"
          - type: "question-multiple-answer"
            stepId: "lesson-07_for-break-and-continue-q2"
            question: "Which statements about break and continue in Kotlin for-loops are\
        \ true?"
            explanation: "break ends the closest loop entirely; continue skips to the next\
        \ iteration of that loop. break does not just skip the rest of the current\
        \ iteration (that’s continue), and continue does not exit loops."
            repeatable: false
            answers:
              - "break terminates the nearest enclosing loop body"
              - "continue skips the rest of the current iteration of the nearest enclosing\
        \ loop"
              - "break skips only the rest of the current iteration of the loop"
              - "continue exits all enclosing loops"
              - "In a nested loop, a break inside the inner loop does not affect the outer\
        \ loop"
            correct:
              - "break terminates the nearest enclosing loop body"
              - "continue skips the rest of the current iteration of the nearest enclosing\
        \ loop"
              - "In a nested loop, a break inside the inner loop does not affect the outer\
        \ loop"
          - type: "text"
            stepId: "lesson-07_for-use-cases-text"
            repeatable: false
            text: |-
              Developers with experience in older languages often use a for-loop where slightly more-modern alternatives should be used instead. For instance, in some projects I can find a for-loop that is used to iterate over elements with indices.
              
              ```kotlin
              fun main() {
                  val names = listOf("Alex", "Bob", "Celina")
              
                  for (i in 0..<names.size) {
                      val name = names[i]
                      println("[$i] $name")
                  }
              }
              // [0] Alex
              // [1] Bob
              // [2] Celina
              ```
              
              This is not a good solution. There are multiple ways to do this better in Kotlin.
              
              First, instead of explicitly iterating over a range `0..<names.size`, we could use the `indices` property, which returns a range of available indices.
              
              ```kotlin
              fun main() {
                  val names = listOf("Alex", "Bob", "Celina")
              
                  for (i in names.indices) {
                      val name = names[i]
                      println("[$i] $name")
                  }
              }
              // [0] Alex
              // [1] Bob
              // [2] Celina
              ```
              
              Second, instead of iterating over indices and finding an element for each of them, we could instead iterate over indexed values. We can create indexed values using `withIndex` on iterable. Each indexed value includes both an index and a value. Such objects can be destructured in a for-loop.
              
              ```kotlin
              fun main() {
                  val names = listOf("Alex", "Bob", "Celina")
              
                  for ((i, name) in names.withIndex()) {
                      println("[$i] $name")
                  }
              }
              // [0] Alex
              // [1] Bob
              // [2] Celina
              ```
              
              Third, an even better solution is to use `forEachIndexed`, which is explained in the book: *Functional Kotlin*.
              
              ```kotlin
              fun main() {
                  val names = listOf("Alex", "Bob", "Celina")
              
                  names.forEachIndexed { i, name ->
                      println("[$i] $name")
                  }
              }
              // [0] Alex
              // [1] Bob
              // [2] Celina
              ```
              
              Another popular use case is iterating over a map. Developers with a Java background often do it this way:
              
              ```kotlin
              fun main() {
                  val capitals = mapOf(
                      "USA" to "Washington DC",
                      "Poland" to "Warsaw",
                      "Ukraine" to "Kiev"
                  )
              
                  for (entry in capitals.entries) {
                      println("The capital of ${entry.key} is ${entry.value}")
                  }
              }
              // The capital of USA is Washington DC
              // The capital of Poland is Warsaw
              // The capital of Ukraine is Kiev
              ```
              
              This can be improved by directly iterating over a map, so calling `entries` is unnecessary. Also, we can destructure entries to better name the values.
              
              ```kotlin
              fun main() {
                  val capitals = mapOf(
                      "USA" to "Washington DC",
                      "Poland" to "Warsaw",
                      "Ukraine" to "Kiev"
                  )
              
                  for ((country, capital) in capitals) {
                      println("The capital of $country is $capital")
                  }
              }
              // The capital of USA is Washington DC
              // The capital of Poland is Warsaw
              // The capital of Ukraine is Kiev
              ```
              
              We can use `forEach` for a map.
              
              ```kotlin
              fun main() {
                  val capitals = mapOf(
                      "USA" to "Washington DC",
                      "Poland" to "Warsaw",
                      "Ukraine" to "Kiev"
                  )
              
                  capitals.forEach { (country, capital) ->
                      println("The capital of $country is $capital")
                  }
              }
              // The capital of USA is Washington DC
              // The capital of Poland is Warsaw
              // The capital of Ukraine is Kiev
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-07_for-use-cases-q1"
            question: |-
              Given:
              
              ```kotlin
              val names = listOf("Alex", "Bob", "Celina")
              ```
              Which snippets are correct and idiomatic ways to print index and value for each element?
            explanation: |-
              - `names.indices` avoids off-by-one errors and bounds checks remain safe.
              - `withIndex()` provides `(index, value)` pairs for destructuring.
              - `forEachIndexed` is the dedicated functional alternative.
              - `0..names.size` is off-by-one and risks IndexOutOfBoundsException.
              - `forEach { (i, name) -> ... }` is invalid for a List because `forEach` provides only the element (no index).
            repeatable: true
            answers:
              - |-
                ```kotlin
                for (i in 0..names.size) {
                    val name = names[i]
                    println("[$i] $name")
                }
                ```
              - |-
                ```kotlin
                for (i in names.indices) {
                    val name = names[i]
                    println("[$i] $name")
                }
                ```
              - |-
                ```kotlin
                for ((i, name) in names.withIndex()) {
                    println("[$i] $name")
                }
                ```
              - |-
                ```kotlin
                names.forEachIndexed { i, name ->
                    println("[$i] $name")
                }
                ```
              - |-
                ```kotlin
                names.forEach { (i, name) ->
                    println("[$i] $name")
                }
                ```
            correct:
              - |-
                ```kotlin
                for (i in names.indices) {
                    val name = names[i]
                    println("[$i] $name")
                }
                ```
              - |-
                ```kotlin
                for ((i, name) in names.withIndex()) {
                    println("[$i] $name")
                }
                ```
              - |-
                ```kotlin
                names.forEachIndexed { i, name ->
                    println("[$i] $name")
                }
                ```
          - type: "question-multiple-answer"
            stepId: "lesson-07_for-use-cases-q2"
            question: |-
              Given:
              
              ```kotlin
              val capitals = mapOf(
                  "USA" to "Washington DC",
                  "Poland" to "Warsaw",
                  "Ukraine" to "Kiev"
              )
              ```
              Which snippets compile and destructure key and value without explicitly accessing `entries`?
            explanation: |-
              - Iterating a Map directly or using `forEach { (k, v) -> }` both destructure without `entries`.
              - `forEach { country, capital -> }` is invalid; a single parameter must be destructured in parentheses.
              - `forEachIndexed` is not available on Map (only on iterables like `capitals.entries`).
              - The explicit `entries` version compiles but does not meet the condition (it accesses `entries`).
            repeatable: true
            answers:
              - |-
                ```kotlin
                capitals.forEach { (country, capital) ->
                    println("The capital of $country is $capital")
                }
                ```
              - |-
                ```kotlin
                for ((country, capital) in capitals) {
                    println("The capital of $country is $capital")
                }
                ```
              - |-
                ```kotlin
                for (entry in capitals.entries) {
                    println("The capital of ${entry.key} is ${entry.value}")
                }
                ```
              - |-
                ```kotlin
                capitals.forEach { country, capital ->
                    println("The capital of $country is $capital")
                }
                ```
              - |-
                ```kotlin
                capitals.forEachIndexed { i, (country, capital) ->
                    println("[$i] The capital of $country is $capital")
                }
                ```
            correct:
              - |-
                ```kotlin
                capitals.forEach { (country, capital) ->
                    println("The capital of $country is $capital")
                }
                ```
              - |-
                ```kotlin
                for ((country, capital) in capitals) {
                    println("The capital of $country is $capital")
                }
                ```
          - type: "text"
            stepId: "lesson-07_for-summary-text"
            repeatable: false
            text: |-
              In this chapter, we've learned about using the for-loop. It is really simple and powerful in Kotlin, so it’s worth knowing how it works, even though it’s not used very often (due to Kotlin’s amazing functional features, which are often used instead).
              
              Now, let's talk about one of the most important Kotlin improvements over Java: good support for handling nullability.
      - lessonId: "lesson-inheritance"
        name: "Inheritance"
        steps:
          - type: "text"
            stepId: "lesson-10_inheritance-visibility-text"
            repeatable: false
            text: |-
              When we design our classes, we prefer to expose as little as possible. If there is no reason for an element to be visible, we prefer to keep it hidden. This is why if there is no good reason to have a less restrictive visibility type, it is good practice to make the visibility of classes and elements as restrictive as possible. We do this using visibility modifiers.
              
              For class members, these are the 4 visibility modifiers we can use:
              * `public` (default) - visible everywhere for clients which can see the declaring class.
              * `private` - visible inside this class only.
              * `protected` - visible inside this class and in subclasses.
              * `internal` - visible inside this module for clients which can see the declaring class.
              
              Top-level elements have 3 visibility modifiers:
              * `public` (default) - visible everywhere.
              * `private` - visible inside the same file only.
              * `internal` - visible inside this module.
              
              Note that a module is not the same as a package. In Kotlin, a module is defined as a set of Kotlin sources that are compiled together. This might mean:
              * a Gradle source set,
              * a Maven project,
              * an IntelliJ IDEA module,
              * a set of files compiled with one invocation of an Ant task.
              
              Let's see some examples, starting with the default visibility, which makes elements visible everywhere and can be explicitly specified using the `public` modifier.
              
              ```kotlin
              // File1.kt
              open class A {
                 public val a = 10
                 public fun b() {
                     println(a) // Can use it
                 }
              }
              
              public val c = 20
              public fun d() {}
              
              class B: A() {
                 fun e() {
                     println(a) // Can use it
                     println(b()) // Can use it
                 }
              }
              
              fun main() {
                 println(A().a) // Can use it
                 println(A().b()) // Can use it
                 println(c) // Can use it
                 println(d()) // Can use it
              }
              
              // File2.kt in the same or different module as File1.kt
              fun main() {
                 println(A().a) // Can use it
                 println(A().b()) // Can use it
                 println(c) // Can use it
                 println(d()) // Can use it
              }
              ```
              
              The `private` modifier can be interpreted as "visible in the creation scope"; so, if we define an element in a class, it will be visible only in this class; if we define an element in a file, it will be visible only in this file.
              
              ```kotlin
              // File1.kt
              open class A {
                  private val a = 10
                  private fun b() {
                      println(a) // Can use it
                  }
              }
              
              private val c = 20
              private fun d() {}
              
              class B : A() {
                  fun e() {
                      println(a) // Error, cannot use a!
                      println(b()) // Error, cannot use b!
                  }
              }
              
              fun main() {
                  println(A().a) // Error, cannot use a!
                  println(A().b()) // Error, cannot use b!
                  println(c) // Can use it
                  println(d()) // Can use it
              }
              
              // File2.kt in the same or different module as File1.kt
              fun main() {
                  println(A().a) // Error, cannot use a!
                  println(A().b()) // Error, cannot use b!
                  println(c) // Error, cannot use c!
                  println(d()) // Error, cannot use d!
              }
              ```
              
              The `protected` modifier can be interpreted as "visible in the class and its subclasses". `protected` only makes sense for elements defined inside classes. It is similar to `private`, but protected elements are also visible inside subclasses of the class where these elements are defined.
              
              ```kotlin
              // File1.kt
              open class A {
                 protected val a = 10
                 protected fun b() {
                     println(a) // Can use it
                 }
              }
              
              open class B: A() {
                 fun e() {
                     println(a) // Can use it!
                     println(b()) // Can use it!
                 }
              }
              
              class C: A() {
                 fun f() {
                     println(a) // Can use it!
                     println(b()) // Can use it!
                 }
              }
              
              fun main() {
                 println(A().a) // Error, cannot use a!
                 println(A().b()) // Error, cannot use b!
              }
              
              // File2.kt in the same or different module as File1.kt
              fun main() {
                 println(A().a) // Error, cannot use a!
                 println(A().b()) // Error, cannot use b!
              }
              ```
              
              The `internal` modifier makes elements visible in the same module. It is useful for library creators who use the `internal` modifier for elements they want to be visible in their project but don’t want to expose to library users. It is also useful in multi-module projects to limit access to a single module. It's useless in single-module projects.
              
              ```kotlin
              // File1.kt
              open class A {
                 internal val a = 10
                 internal fun b() {
                     println(a) // Can use it
                 }
              }
              
              internal val c = 20
              internal fun d() {}
              
              class B: A() {
                 fun e() {
                     println(a) // Can use it
                     println(b()) // Can use it
                 }
              }
              
              fun main() {
                 println(A().a) // Can use it
                 println(A().b()) // Can use it
                 println(c) // Can use it
                 println(d()) // Can use it
              }
              
              // File2.kt in the same module as File1.kt
              fun main() {
                 println(A().a) // Can use it
                 println(A().b()) // Can use it
                 println(c) // Can use it
                 println(d()) // Can use it
              }
              
              // File3.kt in a different module than File1.kt
              fun main() {
                 println(A().a) // Error, cannot use a!
                 println(A().b()) // Error, cannot use b!
                 println(c) // Error, cannot use c!
                 println(d()) // Error, cannot use d!
              }
              ```
              
              If your module might be used by another module, change the visibility of public elements that you don’t want to expose to `internal`. If an element is designed for inheritance and is only used in a class and subclasses, make it `protected`. If you use an element only in the same file or class, make it `private`.
              
              Changing the visibility of a property means changing the visibility of its accessors. A property's field is always private. To change setter visibility, place the visibility modifier before the `set` keyword. The getter must have the same visibility as the property.
              
              ```kotlin
              class View {
                 var isVisible: Boolean = true
                     private set
              
                 fun hide() {
                     isVisible = false
                 }
              }
              
              fun main() {
                 val view = View()
                 println(view.isVisible) // true
                 view.hide()
                 println(view.isVisible) // false
                 view.isVisible = true // ERROR
                 // Cannot assign to 'isVisible',
                 // the setter is private in 'View'
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-visibility-q1"
            question: "Multi-module visibility: Which calls compile inside C.use()?"
            explanation: "internal members are visible only within the declaring module;\
        \ protected members are visible in subclasses (even across modules). Therefore,\
        \ p() is callable in C, but i() is not."
            repeatable: true
            answers:
              - "Both i() and p() compile"
              - "Only p() compiles"
              - "Only i() compiles"
              - "Neither compiles"
            correct: "Only p() compiles"
          - type: "question-multiple-answer"
            stepId: "lesson-10_inheritance-visibility-q2"
            question: "Which of the following Kotlin declarations compile?"
            explanation: "Rules: getter must have the same visibility as the property (so\
        \ private get is illegal). The setter may be more restrictive than the property\
        \ (e.g., private/internal/protected set). protected is only valid for class\
        \ members, not top-level."
            repeatable: true
            answers:
              - |-
                var clicks: Int = 0
                    private set
              - |-
                open class A {
                    var x: Int = 0
                        protected set
                }
              - |-
                class B {
                    public var y: Int = 0
                        internal set
                }
              - |-
                public var z: Int = 0
                    internal set
              - |-
                class C {
                    var a: Int = 0
                        private get
                }
              - "protected var p: Int = 0"
            correct:
              - |-
                var clicks: Int = 0
                    private set
              - |-
                open class A {
                    var x: Int = 0
                        protected set
                }
              - |-
                class B {
                    public var y: Int = 0
                        internal set
                }
              - |-
                public var z: Int = 0
                    internal set
          - type: "text"
            stepId: "lesson-10_inheritance-`any`-text"
            repeatable: false
            text: |-
              If a class has no explicit parent, its implicit parent is `Any`, which is a superclass of all the classes in Kotlin. This means that when we expect the `Any?` type parameter, we accept all possible objects as arguments.
              
              ```kotlin
              fun consumeAnything(a: Any?) {
                  println("Om nom $a")
              }
              
              fun main() {
                  consumeAnything(null) // Om nom null
                  consumeAnything(123) // Om nom 123
                  consumeAnything("ABC") // Om nom ABC
              }
              ```
              
              You can think of `Any` as an open class with three methods: `toString`, `equals` and `hashCode`. These will be better explained in the next chapter, *Data classes*. Overriding methods defined by `Any` is optional because each is an open function with a default body.
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-`any`-q1"
            question: "In Kotlin, which parameter type should you use to accept any value,\
        \ including null?"
            explanation: "`Any` is the superclass of all classes; adding `?` allows null.\
        \ `Nothing?` can only be null, and `Unit` is a return type."
            repeatable: true
            answers:
              - "Any"
              - "Any?"
              - "Nothing"
              - "Nothing?"
              - "Unit"
            correct: "Any?"
          - type: "question-multiple-answer"
            stepId: "lesson-10_inheritance-`any`-q2"
            question: "Which functions are declared in Kotlin's `Any` and can be optionally\
        \ overridden?"
            explanation: "`Any` defines `equals`, `hashCode`, and `toString` with default\
        \ bodies. `copy` is for data classes; `compareTo` comes from `Comparable`."
            repeatable: true
            answers:
              - "toString()"
              - "equals(other: Any?)"
              - "hashCode()"
              - "copy()"
              - "compareTo(other: Any)"
            correct:
              - "toString()"
              - "equals(other: Any?)"
              - "hashCode()"
          - type: "text"
            stepId: "lesson-10_inheritance-summary-text"
            repeatable: false
            text: |-
              In this chapter, we’ve learned how to use inheritance in Kotlin. We’ve got familiar with open and abstract classes, interfaces, and visibility modifiers. These are useful when we want to represent hierarchies of classes.
              
              Instead of using classes to represent hierarchies, we can also treat them as holders of data; for this we use the `data` modifier, which is presented in the next chapter.
          - type: "question-multiple-answer"
            stepId: "lesson-10_inheritance-summary-q1"
            question: "Which visibility modifiers are valid for top-level (file-level) declarations\
        \ in Kotlin?"
            explanation: "Top-level declarations can be public (default), internal (module-visible),\
        \ or private (file-visible). protected is only for class/interface members."
            repeatable: true
            answers:
              - "public"
              - "internal"
              - "private"
              - "protected"
            correct:
              - "public"
              - "internal"
              - "private"
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-summary-q2"
            question: "Given `class Base` and `class Derived : Base()` fails to compile,\
        \ without making `Base` abstract, which modifier must you add to make inheritance\
        \ work?"
            explanation: "Classes are final by default in Kotlin. To allow subclassing of\
        \ a concrete class, mark the superclass as open (or abstract, but the question\
        \ forbids that)."
            repeatable: true
            answers:
              - "Mark `Base` as `open`"
              - "Mark `Derived` as `open`"
              - "Mark `Base` as `internal`"
              - "Mark `Derived` as `override`"
            correct: "Mark `Base` as `open`"
          - type: "text"
            stepId: "lesson-10_inheritance-#-inheritance-text"
            repeatable: false
            text: |-
              Ancient philosophers observed that many classes of objects share the same characteristics. For instance, all mammals have hair or fur, are warm-blooded, and feed their young with milk. In programming, we represent such relationships using **inheritance**.
              
              When a class inherits from another class, it has all its member functions and properties. The class that inherits is known as a **subclass** of the class it inherits from, which is called a **superclass**. They are also known as **child** and **parent**.
              
              In Kotlin, all classes are closed by default, which means we cannot inherit from them. We need to open a class using the `open` keyword to allow inheritance from it. To inherit from a class, we place a colon after the primary constructor (or after the class name if there is no primary constructor), and then we invoke the superclass constructor. In the example below, the class `Dog` inherits from the class `Mammal`. Since `Mammal` has no constructor specified, we call it without arguments, so with `Mammal()`. This way, `Dog` inherits all the properties and methods from `Mammal`.
              
              ```kotlin
              open class Mammal {
                  val haveHairOrFur = true
                  val warmBlooded = true
                  var canFeed = false
              
                  fun feedYoung() {
                      if (canFeed) {
                          println("Feeding young with milk")
                      }
                  }
              }
              
              class Dog : Mammal() {
                  fun makeVoice() {
                      println("Bark bark")
                  }
              }
              
              fun main() {
                  val dog = Dog()
                  dog.makeVoice() // Bark bark
                  println(dog.haveHairOrFur) // true
                  println(dog.warmBlooded) // true
                  // Dog is Mammal, so we can up-cast it
                  val mammal: Mammal = dog
                  mammal.canFeed = true
                  mammal.feedYoung() // Feeding young with milk
              }
              ```
              
              Conceptually, we treat subclasses as if they *are* their superclasses: so, if `Dog` inherits from `Mammal`, we say that `Dog` **is** a `Mammal`. Likewise, wherever `Mammal` is expected, we can use an instance of `Dog`. Taking this into account, inheritance should only be used if a real "is a" relationship between two classes exists.
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-#-inheritance-q1"
            question: "Given `open class Mammal` with a no-arg primary constructor, which\
        \ Kotlin declaration correctly makes `Dog` inherit from `Mammal`?"
            explanation: "In Kotlin you use a colon to specify the supertype and you must\
        \ call the superclass primary constructor with parentheses, even when it has\
        \ no parameters."
            repeatable: false
            answers:
              - "class Dog(Mammal) {}"
              - "class Dog : Mammal {}"
              - "class Dog extends Mammal {}"
              - "class Dog : Mammal() {}"
            correct: "class Dog : Mammal() {}"
          - type: "question-multiple-answer"
            stepId: "lesson-10_inheritance-#-inheritance-q2"
            question: "Which statements about Kotlin inheritance are correct?"
            explanation: "Kotlin classes are final by default and require `open` to be inherited.\
        \ You call the superclass constructor after the colon. Subclasses inherit\
        \ properties and functions, can be upcast to the superclass, and inheritance\
        \ should model a real “is-a” relation—not just shared attributes."
            repeatable: true
            answers:
              - "Classes are closed to inheritance unless marked with `open`."
              - "You must call the superclass primary constructor after the colon (e.g., `:\
        \ Super()`), even if it takes no arguments."
              - "You cannot assign a `Dog` to a `Mammal` variable."
              - "Inheritance should be used whenever two classes share any property."
              - "A subclass automatically gets access to the superclass’s properties and member\
        \ functions."
            correct:
              - "Classes are closed to inheritance unless marked with `open`."
              - "You must call the superclass primary constructor after the colon (e.g., `:\
        \ Super()`), even if it takes no arguments."
              - "A subclass automatically gets access to the superclass’s properties and member\
        \ functions."
          - type: "text"
            stepId: "lesson-10_inheritance-overriding-elements-text"
            repeatable: false
            text: |-
              By default, subclasses cannot override elements defined in superclasses. To make this possible, these elements need to allow it with the `open` modifier, because in Kotlin all elements are closed by default. Then, subclasses can override their parents' implementation, which looks just like defining the same function in children but with the `override` modifier (this modifier is required in Kotlin).
              
              ```kotlin
              open class Mammal {
                  val haveHairOrFur = true
                  val warmBlooded = true
                  var canFeed = false
              
                  open fun feedYoung() {
                      if (canFeed) {
                          println("Feeding young with milk")
                      }
                  }
              }
              
              class Cat : Mammal() {
                  override fun feedYoung() {
                      if (canFeed) {
                          println("Feeding young with milk")
                      } else {
                          println("Feeding young with milk from bottle")
                      }
                  }
              }
              
              fun main() {
                  val dog = Mammal()
                  dog.feedYoung() // Nothing printed
                  val cat = Cat()
                  cat.feedYoung() // Feeding young with milk from bottle
                  cat.canFeed = true
                  cat.feedYoung() // Feeding young with milk
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-overriding-elements-q1"
            question: |-
              Consider:
              
              ```kotlin
              open class Base {
                  fun f() { println("Base") }
              }
              class Derived : Base() {
                  override fun f() { println("Derived") }
              }
              ```
              This code does not compile. Which single change makes it compile?
            explanation: "Members are final by default. The parent member must be marked\
        \ open, and the child must use override. Making the child method open or the\
        \ class abstract does not fix the issue; removing override is illegal when\
        \ a member with the same signature exists in the parent."
            repeatable: true
            answers:
              - "Mark Base.f as open: change to `open fun f() { ... }`"
              - "Mark Derived.f as open: change to `open override fun f() { ... }`"
              - "Remove `override` in Derived"
              - "Make Base abstract: change to `abstract class Base { fun f() { ... } }`"
            correct: "Mark Base.f as open: change to `open fun f() { ... }`"
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-overriding-elements-q2"
            question: |-
              What is printed by the following code?
              
              ```kotlin
              open class Mammal {
                  var canFeed = false
                  open fun feedYoung() {
                      if (canFeed) println("Feeding young with milk")
                  }
              }
              class Cat : Mammal() {
                  override fun feedYoung() {
                      if (canFeed) println("Feeding young with milk")
                      else println("Feeding young with milk from bottle")
                  }
              }
              fun main() {
                  val m: Mammal = Cat()
                  m.feedYoung()
                  m.canFeed = true
                  m.feedYoung()
              }
              ```
            explanation: "Dynamic dispatch calls Cat.feedYoung(). First call: canFeed=false\
        \ ⇒ prints \"...from bottle\". After setting canFeed to true on m, second\
        \ call prints \"...with milk\"."
            repeatable: false
            answers:
              - |-
                Feeding young with milk from bottle
                Feeding young with milk
              - |-
                Nothing printed
                Feeding young with milk
              - |-
                Feeding young with milk
                Feeding young with milk
              - |-
                Feeding young with milk from bottle
                Feeding young with milk from bottle
            correct: |-
              Feeding young with milk from bottle
              Feeding young with milk
          - type: "text"
            stepId: "lesson-10_inheritance-parents-with-non-empty-constructors-text"
            repeatable: false
            text: |-
              So far, we have inherited only from classes with empty constructors; so, when we were specifying the superclass, we used empty parentheses. However, if the superclass has constructor parameters, we need to define some arguments inside these parentheses.
              
              ```kotlin
              open class Animal(val name: String)
              
              class Dodo : Animal("Dodo")
              ```
              
              We can use primary constructor properties as superclass constructor arguments or to construct these arguments.
              
              ```kotlin
              open class Animal(val name: String)
              
              class Dog(name: String) : Animal(name)
              
              class Cat(name: String) : Animal("Mr $name")
              
              class Human(
                 firstName: String,
                 lastName: String,
              ) : Animal("$firstName $lastName")
              
              fun main() {
                 val dog = Dog("Cookie")
                 println(dog.name) // Cookie
                 val cat = Cat("MiauMiau")
                 println(cat.name) // Mr MiauMiau
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-10_inheritance-parents-with-non-empty-constructors-q1"
            question: |-
              Given:
              
              ```kotlin
              open class Animal(val name: String)
              ```
              Which subclass declarations compile?
            explanation: "If a superclass has constructor parameters, every subclass constructor\
        \ must delegate to it with arguments. You may pass constants or build the\
        \ argument from the subclass's primary constructor parameters."
            repeatable: true
            answers:
              - "class Dodo : Animal()"
              - "class Dog(name: String) : Animal(name)"
              - "class Cat(name: String) : Animal(\"Mr $name\")"
              - "class Human(val firstName: String, val lastName: String) : Animal(\"$firstName\
        \ $lastName\")"
              - "class Virus : Animal(\"SARS\")"
            correct:
              - "class Dog(name: String) : Animal(name)"
              - "class Cat(name: String) : Animal(\"Mr $name\")"
              - "class Human(val firstName: String, val lastName: String) : Animal(\"$firstName\
        \ $lastName\")"
              - "class Virus : Animal(\"SARS\")"
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-parents-with-non-empty-constructors-q2"
            question: |-
              Consider:
              
              ```kotlin
              open class Animal(val name: String)
              class Dog(name: String) : Animal(name)
              ```
              Which statement is correct?
            explanation: "A primary constructor parameter without val/var is not a property.\
        \ Dog still exposes name via inheritance from Animal."
            repeatable: true
            answers:
              - "Dog declares a new property name and hides Animal.name."
              - "Dog inherits name from Animal; the constructor parameter name is not a property."
              - "Dog().name is inaccessible because name is private."
              - "You must write val name: String in Dog to access dog.name."
            correct: "Dog inherits name from Animal; the constructor parameter name is not\
        \ a property."
          - type: "text"
            stepId: "lesson-10_inheritance-super-call-text"
            repeatable: false
            text: |-
              When a class extends another class, it takes the behavior from the superclass but also adds some behavior that is specific to the subclass. This is why overriding methods often need to include the behavior of the methods they override. For this, it is useful to call the superclass implementation in these subclass methods. We do this using the `super` keyword, followed by a dot, and then we call the method we want to override.
              
              Consider the classes `Dog` and `BorderCollie` that are presented in the example below. The default behavior for a dog is to wave its tail when it sees a dog friend. Border Collies should behave the same but additionally lie down. In this case, to call the superclass implementation, we need to use `super.seeFriend()`.
              
              ```kotlin
              open class Dog {
                  open fun seeFriend() {
                      println("Wave its tail")
                  }
              }
              
              class BorderCollie : Dog() {
                  override fun seeFriend() {
                      println("Lie down")
                      super.seeFriend()
                  }
              }
              
              fun main() {
                  val dog = Dog()
                  dog.seeFriend() // Wave its tail
                  val borderCollie = BorderCollie()
                  borderCollie.seeFriend()
                  // Lie down
                  // Wave its tail
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-super-call-q1"
            question: "In Kotlin, how do you include the superclass implementation when\
        \ overriding a method?"
            explanation: "`super.methodName()` invokes the superclass implementation. `Dog.super`\
        \ and `this.super` are invalid in Kotlin, and `super.seeFriend` without `()`\
        \ is a reference, not a call."
            repeatable: true
            answers:
              - "override fun seeFriend() { super.seeFriend() }"
              - "override fun seeFriend() { Dog.super.seeFriend() }"
              - "override fun seeFriend() { this.super.seeFriend() }"
              - "override fun seeFriend() { super.seeFriend }"
            correct: "override fun seeFriend() { super.seeFriend() }"
          - type: "question-multiple-answer"
            stepId: "lesson-10_inheritance-super-call-q2"
            question: "To let `BorderCollie` override `Dog.seeFriend()` in Kotlin, which\
        \ declarations must be marked `open`? Select all that apply."
            explanation: "Classes and members are final by default. The superclass (`Dog`)\
        \ and the overridden member (`seeFriend`) must be `open`. The subclass need\
        \ not be open, and the overriding member is open by default unless marked\
        \ `final`."
            repeatable: false
            answers:
              - "Dog class"
              - "Dog.seeFriend()"
              - "BorderCollie class"
              - "BorderCollie.seeFriend()"
            correct:
              - "Dog class"
              - "Dog.seeFriend()"
          - type: "text"
            stepId: "lesson-10_inheritance-abstract-class-text"
            repeatable: false
            text: |-
              A mammal is a group of animals, not a concrete species. It defines a set of characteristics but might not exist in itself. To define a class that can only be used as a superclass of other classes but cannot produce an object, we use the `abstract` keyword before its class definition. You can interpret the `open` modifier as "one can inherit from this class", whereas `abstract` means "one must inherit from this class to use it".
              
              ```kotlin
              abstract class Mammal {
                 val haveHairOrFur = true
                 val warmBlooded = true
                 var canFeed = false
              
                 fun feedYoung() {
                     if (canFeed) {
                         println("Feeding young with milk")
                     }
                 }
              }
              ```
              
              Abstract classes are open, so there is no need to use the `open` modifier when a class has the `abstract` modifier already.
              
              When a class is abstract, it can have abstract functions and properties. Such functions do not have a body, and each subclass needs to override them. Thanks to that, when we have an object whose type is an abstract class, we can call its abstract functions because whatever the actual class of this object is, it still needs to define these functions.
              
              ```kotlin
              abstract class Mammal {
                  val haveHairOrFur = true
                  val warmBlooded = true
                  var canFeed = false
              
                  abstract fun feedYoung()
              }
              
              class Dog : Mammal() {
                  override fun feedYoung() {
                      if (canFeed) {
                          println("Feeding young with milk")
                      }
                  }
              }
              
              class Human : Mammal() {
                  override fun feedYoung() {
                      if (canFeed) {
                          println("Feeding young with milk")
                      } else {
                          println("Feeding young with milk from bottle")
                      }
                  }
              }
              
              fun feedYoung(mammal: Mammal) {
                  // We can do that, because feedYoung is an abstract
                  // function in Mammal
                  mammal.feedYoung()
              }
              
              fun main() {
                  val dog = Dog()
                  dog.canFeed = true
                  feedYoung(dog) // Feeding young with milk
                  feedYoung(Human()) // Feeding young with milk from bottle
              }
              ```
              
              An abstract class can also have non-abstract methods, which have a body. Such methods can be used by other methods. Therefore, abstract classes can be used as templates with partial implementation for other classes. Consider the `CoffeeMachine` abstract class below, which specifies how latte or doppio can be prepared, but it needs a subclass to override the `prepareEspresso` and `addMilk` methods. This class provides implementation for only some methods, so it is a partial implementation.
              
              ```kotlin
              abstract class CoffeeMachine {
                  abstract fun prepareEspresso()
                  abstract fun addMilk()
              
                  fun prepareLatte() {
                      prepareEspresso()
                      addMilk()
                  }
                  fun prepareDoppio() {
                      prepareEspresso()
                      prepareEspresso()
                  }
              }
              ```
              
              Kotlin does not support multiple inheritance, so a class can inherit only from one open class. I do not find this a problem because inheritance is not so popular nowadays - interfaces are implemented instead.
          - type: "question-multiple-answer"
            stepId: "lesson-10_inheritance-abstract-class-q1"
            question: "Select all true statements about abstract classes in Kotlin."
            explanation: "Abstract classes are implicitly open; they can include concrete\
        \ methods; concrete subclasses must implement all abstract members. Kotlin\
        \ allows only single inheritance and you cannot instantiate an abstract class."
            repeatable: true
            answers:
              - "An abstract class is implicitly open; no 'open' needed on the class."
              - "Abstract classes may contain concrete methods with bodies."
              - "A concrete subclass must implement all inherited abstract members."
              - "Kotlin supports inheriting from multiple abstract classes."
              - "You can instantiate an abstract class directly."
            correct:
              - "An abstract class is implicitly open; no 'open' needed on the class."
              - "Abstract classes may contain concrete methods with bodies."
              - "A concrete subclass must implement all inherited abstract members."
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-abstract-class-q2"
            question: "Which snippet compiles?"
            explanation: "Abstract functions cannot have a body; non-abstract functions\
        \ must have a body; a non-abstract subclass must override all abstract members."
            repeatable: true
            answers:
              - "abstract class A { abstract fun x() {} }"
              - "abstract class A { fun x() }"
              - "abstract class A { abstract fun x() } class B: A()"
              - "abstract class A { abstract fun x() } class B: A() { override fun x() {}\
        \ }"
            correct: "abstract class A { abstract fun x() } class B: A() { override fun\
        \ x() {} }"
          - type: "text"
            stepId: "lesson-10_inheritance-interfaces-text"
            repeatable: false
            text: "An interface defines a set of properties and methods that a class should\
        \ have. We define interfaces with the `interface` keyword, a name, and a body\
        \ with the expected properties and methods.\n\n```kotlin\ninterface CoffeeMaker\
        \ {\n    val type: String\n    fun makeCoffee(size: Size): Coffee\n}\n```\n\
        \nWhen a class implements an interface, this class has to override all the\
        \ elements defined by this interface. Thanks to that, we can treat an instance\
        \ of a class as an instance of an interface. We implement interfaces similarly\
        \ to how we extend classes, but without calling a constructor because interfaces\
        \ cannot have constructors.\n\n```kotlin\nclass User(val id: Int, val name:\
        \ String)\n\ninterface UserRepository {\n    fun findUser(id: Int): User?\n\
        \    fun addUser(user: User)\n}\n\nclass FakeUserRepository : UserRepository\
        \ {\n    private var users = mapOf<Int, User>()\n\n    override fun findUser(id:\
        \ Int): User? = users[id]\n\n    override fun addUser(user: User) {\n    \
        \    users += user.id to user\n    }\n}\n\nfun main() {\n    val repo: UserRepository\
        \ = FakeUserRepository()\n    repo.addUser(User(123, \"Zed\"))\n    val user\
        \ = repo.findUser(123)\n    println(user?.name) // Zed\n}\n```\n\nAs mentioned\
        \ already, interfaces can specify that they expect a class to have a particular\
        \ property. Such properties can either be defined as regular properties, or\
        \ they can be defined by accessors (getter for `val`, or getter and setter\
        \ for `var`).\n\n```kotlin\ninterface Named {\n    val name: String\n    val\
        \ fullName: String\n}\n\nclass User(\n    override val name: String,\n   \
        \ val surname: String,\n) : Named {\n    override val fullName: String\n \
        \       get() = \"$name $surname\"\n}\n```\n\nThe read-only `val` property\
        \ can be overridden with a read-write `var` property. This is because the\
        \ `val` property expects a getter, and the `var` property provides a getter\
        \ as well as an additional setter.\n\n```kotlin\ninterface Named {\n    val\
        \ name: String\n}\n\nclass NameBox : Named {\n    override var name = \"(default)\"\
        \n}\n```\n\nA class can implement multiple interfaces.\n\n```kotlin\ninterface\
        \ Drinkable {\n    fun drink()\n}\n\ninterface Spillable {\n    fun spill()\n\
        }\n\nclass Mug : Drinkable, Spillable {\n    override fun drink() {\n    \
        \    println(\"Ummm\")\n    }\n    override fun spill() {\n        println(\"\
        Ow, ow, OWWW\")\n    }\n}\n```\n\nInterfaces can specify default bodies for\
        \ their methods. Such methods do not need to (but can) be implemented by subclasses.\n\
        \n```kotlin\nclass User(val id: Int, val name: String)\n\ninterface UserRepository\
        \ {\n    fun findUser(id: Int): User? =\n        getUsers().find { it.id ==\
        \ id }\n\n    fun getUsers(): List<User>\n}\n\nclass FakeUserRepository :\
        \ UserRepository {\n    private var users = listOf<User>()\n\n    override\
        \ fun getUsers(): List<User> = users\n\n    fun addUser(user: User) {\n  \
        \      users += user\n    }\n}\n\nfun main() {\n    val repo = FakeUserRepository()\n\
        \    repo.addUser(User(123, \"Zed\"))\n    val user = repo.findUser(123)\n\
        \    println(user?.name) // Zed\n}\n```\n\nWhen we override a method, we can\
        \ still call its default body using the `super` keyword and a regular method\
        \ call.\n\n```kotlin\ninterface NicePerson {\n   fun cheer() {\n       println(\"\
        Hello\")\n   }\n}\n\nclass Alex : NicePerson\n\nclass Ben : NicePerson {\n\
        \   override fun cheer() {\n       super.cheer()\n       println(\"My name\
        \ is Ben\")\n   }\n}\n\nfun main() {\n   val alex = Alex()\n   alex.cheer()\
        \ // Hello\n  \n   val ben = Ben()\n   ben.cheer()\n   // Hello\n   // My\
        \ name is Ben\n}\n```\n\nWhen two interfaces define a method with the same\
        \ name and parameters, the class that implements both these interfaces **must**\
        \ override this method. To call the default bodies of these methods, we need\
        \ to use `super` with the name of the class we want to use in angle brackets.\
        \ So, to call `start` from `Boat` use `super<Boat>.start()`. Or, to call `start`\
        \ from `Car` use `super<Car>.start()`.\n\n```kotlin\ninterface Boat {\n  \
        \ fun start() {\n       println(\"Ready to swim\")\n   }\n}\n\ninterface Car\
        \ {\n   fun start() {\n       println(\"Ready to drive\")\n   }\n}\n\nclass\
        \ Amphibian: Car, Boat {\n   override fun start() {\n       super<Car>.start()\n\
        \       super<Boat>.start()\n   }\n}\n\nfun main() {\n   val vehicle = Amphibian()\n\
        \   vehicle.start()\n   // Ready to drive\n   // Ready to swim\n}\n```"
          - type: "question-single-answer"
            stepId: "lesson-10_inheritance-interfaces-q1"
            question: |-
              Given the interfaces with default implementations below, which override of start in Amphibian compiles and prints both messages exactly once?
              
              ```kotlin
              interface Boat {
                  fun start() { println("Ready to swim") }
              }
              
              interface Car {
                  fun start() { println("Ready to drive") }
              }
              
              class Amphibian : Car, Boat {
                  // choose the correct override
              }
              ```
            explanation: "When two interfaces provide the same method, the class must override\
        \ it and use qualified super calls: super<Interface>.method(). Unqualified\
        \ super is ambiguous; Java-style syntax is invalid; casting and calling would\
        \ recurse into the same override."
            repeatable: true
            answers:
              - "override fun start() { super.start() }"
              - "override fun start() { super<Car>.start(); super<Boat>.start() }"
              - "override fun start() { Car.super.start(); Boat.super.start() }"
              - "override fun start() { (this as Car).start(); (this as Boat).start() }"
            correct: "override fun start() { super<Car>.start(); super<Boat>.start() }"
          - type: "question-multiple-answer"
            stepId: "lesson-10_inheritance-interfaces-q2"
            question: |-
              Which class declarations correctly implement the interface property override rules?
              
              ```kotlin
              interface Named { val name: String }
              ```
              Select all that compile.
            explanation: "The override keyword is required. A val from an interface can\
        \ be overridden with val or var. Declaring properties without override does\
        \ not fulfill the interface contract. Using a constructor property with override\
        \ is valid."
            repeatable: true
            answers:
              - "class A : Named { override val name = \"A\" }"
              - "class B : Named { override var name = \"B\" }"
              - "class C : Named { val name = \"C\" }"
              - "class D : Named { var name = \"D\" }"
              - "class E(override val name: String) : Named"
            correct:
              - "class A : Named { override val name = \"A\" }"
              - "class B : Named { override var name = \"B\" }"
              - "class E(override val name: String) : Named"
      - lessonId: "lesson-data-classes"
        name: "Data classes"
        steps:
          - type: "text"
            stepId: "lesson-11_data_classes-{sample:-true}-text"
            repeatable: false
            text: |-
              # Data classes
              
              In Kotlin, we say that all classes inherit from the `Any` superclass, which is at the top of the class hierarchy. Methods defined in `Any` can be called on all objects. These methods are:
              * `equals` - used when two objects are compared using `==`,
              * `hashCode` - used by collections that use the hash table algorithm,
              * `toString` - used to represent an object as a string, e.g., in a string template or the `print` function.
              
              Thanks to these methods, we can represent any object as a string or check the equality of any two objects.
              
              ```kotlin
              // Any formal definition
              open class Any {
                 open operator fun equals(other: Any?): Boolean
                 open fun hashCode(): Int
                 open fun toString(): String
              }
              
              class A // Implicitly inherits from Any
              
              fun main() {
                 val a = A()
                 a.equals(a)
                 a == a
                 a.hashCode()
                 a.toString()
                 println(a)
              }
              ```
              
              > Truth be told, `Any` is represented as a class, but it should actually be considered the head of the type hierarchy, but with some special functions. Consider the fact that `Any` is also the supertype of all interfaces, even though interfaces cannot inherit from classes.
              
              The default implementations of `equals`, `hashCode`, and `toString` are strongly based on the object’s address in memory. The `equals` method returns `true` only when the address of both objects is the same, which means the same object is on both sides. The `hashCode` method typically transforms an address into a number. `toString` produces a string that starts with the class name, then the at sign "@", then the unsigned hexadecimal representation of the hash code of the object.
              
              ```kotlin
              class A
              
              fun main() {
                 val a1 = A()
                 val a2 = A()
              
                 println(a1.equals(a1)) // true
                 println(a1.equals(a2)) // false
                 // or
                 println(a1 == a1) // true
                 println(a1 == a2) // false
              
                 println(a1.hashCode()) // Example: 149928006
                 println(a2.hashCode()) // Example: 713338599
              
                 println(a1.toString()) // Example: A@8efb846
                 println(a2.toString()) // Example: A@2a84aee7
                 // or
                 println(a1) // Example: A@8efb846
                 println(a2) // Example: A@2a84aee7
              }
              ```
              
              By overriding these methods, we can decide how a class should behave. Consider the following class `A`, which is equal to other instances of the same class and returns a constant hash code and string representation.
              
              ```kotlin
              class A {
                 override fun equals(other: Any?): Boolean = other is A
              
                 override fun hashCode(): Int = 123
              
                 override fun toString(): String = "A()"
              }
              
              fun main() {
                 val a1 = A()
                 val a2 = A()
              
                 println(a1.equals(a1)) // true
                 println(a1.equals(a2)) // true
                 // or
                 println(a1 == a1) // true
                 println(a1 == a2) // true
              
                 println(a1.hashCode()) // 123
                 println(a2.hashCode()) // 123
              
                 println(a1.toString()) // A()
                 println(a2.toString()) // A()
                 // or
                 println(a1) // A()
                 println(a2) // A()
              }
              ```
              
              I've dedicated separate items in the *Effective Kotlin* book to implementing a custom `equals` and `hashCode`, but in practice we rarely need to do that. As it turns out, in modern projects we almost solely operate on only two kinds of objects:
              * Active objects, like services, controllers, repositories, etc. Such classes don’t need to override any methods from `Any` because the default behavior is perfect for them.
              * Data model class objects, which represent bundles of data. For such objects, we use the `data` modifier, which overrides the `toString`, `equals`, and `hashCode` methods. The `data` modifier also implements the methods `copy` and `componentN` (`component1`, `component2`, etc.), which are not inherited and cannot be modified.
              
              ```kotlin
              data class Player(
                 val id: Int,
                 val name: String,
                 val points: Int
              )
              
              val player = Player(0, "Gecko", 9999)
              ```
              
              Let's discuss the aforementioned implicit data class methods and the differences between regular class behavior and data class behavior.
          - type: "question-multiple-answer"
            stepId: "lesson-11_data_classes-{sample:-true}-q1"
            question: "Select all correct statements about Kotlin data classes and Any."
            explanation: "Data classes override equals/hashCode/toString and generate copy/componentN\
        \ that are not inherited and cannot be modified. Methods from Any are available\
        \ on all objects. Regular classes by default use identity-based equals; default\
        \ toString is ClassName@hexHash, not just the name."
            repeatable: true
            answers:
              - "Data classes override equals, hashCode, and toString."
              - "Data classes provide copy and componentN functions that are not inherited\
        \ and cannot be overridden."
              - "The default equals for a regular class compares all primary-constructor properties."
              - "Methods from Any (equals, hashCode, toString) can be called on any object."
              - "The default toString for a regular class prints only the class name, without\
        \ any extra information."
            correct:
              - "Data classes override equals, hashCode, and toString."
              - "Data classes provide copy and componentN functions that are not inherited\
        \ and cannot be overridden."
              - "Methods from Any (equals, hashCode, toString) can be called on any object."
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-{sample:-true}-q2"
            question: |-
              Given:
              
              ```kotlin
              class A
              
              data class Player(val id: Int, val name: String, val points: Int)
              
              val a1 = A(); val a2 = A()
              val p1 = Player(1, "Gecko", 9999)
              val p2 = Player(1, "Gecko", 9999)
              ```
              
              Which statement is guaranteed to be true?
            explanation: "Regular classes use identity-based equals by default, so a1 ==\
        \ a2 is false. Data classes compare property values, so p1 == p2 is true.\
        \ Changing a property in copy makes it unequal. Hash codes of different A\
        \ instances are not guaranteed to differ or be equal."
            repeatable: true
            answers:
              - "a1 == a2"
              - "p1 == p2"
              - "p1.copy(points = 11) == p1"
              - "a1.hashCode() == a2.hashCode()"
            correct: "p1 == p2"
          - type: "text"
            stepId: "lesson-11_data_classes-transforming-to-a-string-text"
            repeatable: false
            text: "The default `toString` transformation produces a string that starts with\
        \ the class name, then the at sign \"@\", and then the unsigned hexadecimal\
        \ representation of the hash code of the object. The purpose of this is to\
        \ display the class name and to determine whether two strings represent the\
        \ same object or not.\n\n```kotlin\nclass FakeUserRepository\n\nfun main()\
        \ {\n   val repository1 = FakeUserRepository()\n   val repository2 = FakeUserRepository()\n\
        \   println(repository1) // e.g. FakeUserRepository@8efb846\n   println(repository1)\
        \ // e.g. FakeUserRepository@8efb846\n   println(repository2) // e.g. FakeUserRepository@2a84aee7\n\
        }\n```\n\nWith the `data` modifier, the compiler generates a `toString` that\
        \ displays the class name and then pairs with the name and value for each\
        \ primary constructor property. We assume that data classes are represented\
        \ by their primary constructor properties, so all these properties, together\
        \ with their values, are displayed during a transformation to a string. This\
        \ is useful for logging and debugging.\n\n```kotlin\ndata class Player(\n\
        \   val id: Int,\n   val name: String,\n   val points: Int\n)\n\nfun main()\
        \ {\n   val player = Player(0, \"Gecko\", 9999)\n   println(player) \n   //\
        \ Player(id=0, name=Gecko, points=9999)\n   println(\"Player: $player\")\n\
        \   // Player: Player(id=0, name=Gecko, points=9999)\n}\n```\n\n{width: 84%}\n\
        ![](data_toString.png)"
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-transforming-to-a-string-q1"
            question: "What is the default string format produced by `println(obj)` for\
        \ a regular (non-data) Kotlin class instance?"
            explanation: "By default, `Any.toString()` returns `ClassName@<unsigned-hex-of-hashCode()>`."
            repeatable: false
            answers:
              - "ClassName@<unsigned-hex-hash-code>"
              - "ClassName#<decimal-hash-code>"
              - "ClassName(hash=<unsigned-hex-hash-code>)"
              - "<ClassName>"
            correct: "ClassName@<unsigned-hex-hash-code>"
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-transforming-to-a-string-q2"
            question: |-
              Given:
              
              ```kotlin
              data class Box(val w: Int) {
                  val h: Int = w * 2
              }
              
              fun main() {
                  println(Box(3))
              }
              ```
              What is the output?
            explanation: "Data class `toString` includes only primary constructor properties,\
        \ in their declaration order."
            repeatable: true
            answers:
              - "Box(w=3, h=6)"
              - "Box(w=3)"
              - "Box(h=6)"
              - "Box(3, 6)"
            correct: "Box(w=3)"
          - type: "text"
            stepId: "lesson-11_data_classes-objects-equality-text"
            repeatable: false
            text: |-
              In Kotlin, we check the equality of two objects using `==`, which uses the `equals` method from `Any`. So, this method decides if two objects should be considered equal or not. By default, two different instances are never equal. This is perfect for active objects, i.e., objects that work independently of other instances of the same class and possibly have a protected mutable state.
              
              ```kotlin
              class FakeUserRepository
              
              fun main() {
                 val repository1 = FakeUserRepository()
                 val repository2 = FakeUserRepository()
                 println(repository1 == repository1) // true
                 println(repository1 == repository2) // false
              }
              ```
              
              Classes with the `data` modifier represent bundles of data; they are considered equal to other instances if:
              * both are of the same class,
              * their primary constructor property values are equal.
              
              ```kotlin
              data class Player(
                 val id: Int,
                 val name: String,
                 val points: Int
              )
              
              fun main() {
                 val player = Player(0, "Gecko", 9999)
                 println(player == Player(0, "Gecko", 9999)) // true
                 println(player == Player(0, "Ross", 9999)) // false
              }
              ```
              
              This is what a simplified implementation of the `equals` method generated by the `data` modifier for the `Player` class looks like:
              
              ```kotlin
              override fun equals(other: Any?): Boolean = other is Player &&
                 other.id == this.id &&
                 other.name == this.name &&
                 other.points == this.points
              ```
              
              > Implementing a custom `equals` is described in *Effective Kotlin*, *Item 42: Respect the contract of `equals`*.
          - type: "question-multiple-answer"
            stepId: "lesson-11_data_classes-objects-equality-q1"
            question: |-
              Given:
              
              ```kotlin
              data class Player(val id: Int, val name: String) { var online: Boolean = false }
              data class Gamer(val id: Int, val name: String)
              class User(val id: Int, val name: String)
              ```
              
              Which comparisons evaluate to true?
            explanation: "`==` calls `equals`. For data classes, `equals` compares only\
        \ primary-constructor properties and also requires the same runtime class.\
        \ Properties declared in the body (like `online`) are ignored. Regular classes\
        \ inherit reference-based `equals` from `Any`, so two distinct instances are\
        \ not equal."
            repeatable: true
            answers:
              - "Player(1, \"A\") == Player(1, \"A\")"
              - "Player(1, \"A\").apply { online = true } == Player(1, \"A\")"
              - "Gamer(1, \"A\") == Player(1, \"A\")"
              - "User(1, \"A\") == User(1, \"A\")"
            correct:
              - "Player(1, \"A\") == Player(1, \"A\")"
              - "Player(1, \"A\").apply { online = true } == Player(1, \"A\")"
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-objects-equality-q2"
            question: "In Kotlin, what does the `==` operator do when comparing two objects?"
            explanation: "`==` delegates to `equals` (from `Any` or overridden). By default,\
        \ `Any.equals` is reference-based; data classes override it to compare primary-constructor\
        \ properties."
            repeatable: false
            answers:
              - "Calls `equals`, which by default is reference-based unless overridden (e.g.,\
        \ by data classes)."
              - "Checks referential identity (`===`) for primitives and `equals` for other\
        \ types."
              - "Always checks referential identity only."
              - "Recursively compares all fields, including non-constructor and private ones."
            correct: "Calls `equals`, which by default is reference-based unless overridden\
        \ (e.g., by data classes)."
          - type: "text"
            stepId: "lesson-11_data_classes-hash-code-text"
            repeatable: false
            text: |-
              Another method from `Any` is `hashCode`, which is used to transform an object into an `Int`. With a `hashCode` method, the object instance can be stored in the hash table data structure implementations that are part of many popular classes, including `HashSet` and `HashMap`. The most important rule of the `hashCode` implementation is that it should:
              * be consistent with `equals`, so it should return the same `Int` for equal objects, and it must always return the same hash code for the same object.
              * spread objects as uniformly as possible in the range of all possible `Int` values.
              
              The default `hashCode` is based on an object's address in memory. The `hashCode` generated by the `data` modifier is based on the hash codes of this object’s primary constructor properties. In both cases, the same number is returned for equal objects.
              
              ```kotlin
              data class Player(
                 val id: Int,
                 val name: String,
                 val points: Int
              )
              
              fun main() {
                 println(Player(0, "Gecko", 9999).hashCode()) // 2129010918
                 println(Player(0, "Gecko", 9999).hashCode()) // 2129010918
                 println(Player(0, "Ross", 9999).hashCode())  // 79159602
              }
              ```
              
              To learn more about the hash table algorithm and implementing a custom `hashCode` method, see *Effective Kotlin*, *Item 43: Respect the contract of `hashCode`*.
          - type: "question-multiple-answer"
            stepId: "lesson-11_data_classes-hash-code-q1"
            question: "Which statements about Kotlin's hashCode are true?"
            explanation: "hashCode must be consistent with equals (equal objects -> same\
        \ hash), must be stable for the same instance, and the default Any.hashCode\
        \ is based on the object's address in memory. Data class hashCode is not based\
        \ on body properties, and different objects can legally collide."
            repeatable: true
            answers:
              - "Equal objects must have the same hash code."
              - "The same object instance must always produce the same hash code during its\
        \ lifetime."
              - "In data classes, hashCode is computed from all properties, including those\
        \ declared in the body."
              - "The default Any.hashCode is based on the object's address in memory."
              - "Different objects must always have different hash codes."
            correct:
              - "Equal objects must have the same hash code."
              - "The same object instance must always produce the same hash code during its\
        \ lifetime."
              - "The default Any.hashCode is based on the object's address in memory."
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-hash-code-q2"
            question: "Given a Kotlin data class, which properties contribute to the generated\
        \ hashCode?"
            explanation: "For data classes, hashCode is derived from the primary constructor\
        \ properties only."
            repeatable: false
            answers:
              - "Only primary constructor properties"
              - "All properties (constructor and body)"
              - "Only val properties anywhere in the class"
              - "Only properties annotated with @JvmField"
            correct: "Only primary constructor properties"
          - type: "text"
            stepId: "lesson-11_data_classes-copying-objects-text"
            repeatable: false
            text: "Another method generated by the `data` modifier is `copy`, which is used\
        \ to create a new instance of a class but with a concrete modification. The\
        \ idea is very simple: it is a function with parameters for each primary constructor\
        \ property, but each of these parameters has a default value, i.e., the current\
        \ value of the associated property.\n\n```kotlin\n// This is how copy generated\
        \ by data modifier\n// for Person class looks like under the hood\nfun copy(\n\
        \   id: Int = this.id,\n   name: String = this.name,\n   points: Int = this.points\n\
        ) = Player(id, name, points)\n```\n\nThis means we can call `copy` with no\
        \ parameters to make a copy of our object with no modifications, but we can\
        \ also specify new values for the properties we want to change.\n\n```kotlin\n\
        data class Player(\n   val id: Int,\n   val name: String,\n   val points:\
        \ Int\n)\n\nfun main() {\n   val p = Player(0, \"Gecko\", 9999)\n\n   println(p.copy())\
        \ // Player(id=0, name=Gecko, points=9999)\n\n   println(p.copy(id = 1, name\
        \ = \"New name\"))\n   // Player(id=1, name=New name, points=9999)\n\n   println(p.copy(points\
        \ = p.points + 1))\n   // Player(id=0, name=Gecko, points=10000)\n}\n```\n\
        \nNote that `copy` creates a shallow copy of an object; so, if our object\
        \ holds a mutable state, a change in one object will be a change in all its\
        \ copies too.\n\n```kotlin\ndata class StudentGrades(\n   val studentId: String,\n\
        \   // Code smell: Avoid using mutable objects in data classes\n   val grades:\
        \ MutableList<Int>\n)\n\nfun main() {\n   val grades1 = StudentGrades(\"1\"\
        , mutableListOf())\n   val grades2 = grades1.copy(studentId = \"2\")\n   println(grades1)\
        \ // Grades(studentId=1, grades=[])\n   println(grades2) // Grades(studentId=2,\
        \ grades=[])\n   grades1.grades.add(5)\n   println(grades1) // Grades(studentId=1,\
        \ grades=[5])\n   println(grades2) // Grades(studentId=2, grades=[5])\n  \
        \ grades2.grades.add(1)\n   println(grades1) // Grades(studentId=1, grades=[5,\
        \ 1])\n   println(grades2) // Grades(studentId=2, grades=[5, 1])\n}\n```\n\
        \nWe do not have this problem when we use `copy` for immutable classes, i.e.,\
        \ classes with only `val` properties that hold immutable values. `copy` was\
        \ introduced as special support for immutability (for details, see *Effective\
        \ Kotlin*, *Item 1: Limit mutability*).\n\n```kotlin\ndata class StudentGrades(\n\
        \   val studentId: String,\n   val grades: List<Int>\n)\n\nfun main() {\n\
        \   var grades1 = StudentGrades(\"1\", listOf())\n   var grades2 = grades1.copy(studentId\
        \ = \"2\")\n   println(grades1) // Grades(studentId=1, grades=[])\n   println(grades2)\
        \ // Grades(studentId=2, grades=[])\n   grades1 = grades1.copy(grades = grades1.grades\
        \ + 5)\n   println(grades1) // Grades(studentId=1, grades=[5])\n   println(grades2)\
        \ // Grades(studentId=2, grades=[])\n   grades2 = grades2.copy(grades = grades2.grades\
        \ + 1)\n   println(grades1) // Grades(studentId=1, grades=[5])\n   println(grades2)\
        \ // Grades(studentId=2, grades=[1])\n}\n```\n\nNotice that data classes are\
        \ unsuitable for objects that must maintain invariant constraints on mutable\
        \ properties. For example, in the `User` example below, the class would not\
        \ be able to guarantee that the `name` and `surname` values are not blank\
        \ if these variables were mutable (so, defined with `var`). Data classes are\
        \ perfectly fit for immutable properties, whose constraints might be checked\
        \ during the creation of these objects. In the example below, we can be sure\
        \ that the `name` and `surname` values are not blank in an instance of `User`.\
        \ \n\n```kotlin\ndata class User(\n   val name: String,\n   val surname: String,\n\
        ) {\n   init {\n       require(name.isNotBlank())\n       // throws exception\
        \ if name is blank\n       require(surname.isNotBlank())\n       // throws\
        \ exception if surname is blank\n   }\n}\n```"
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-copying-objects-q1"
            question: |-
              What does this code print?
              
              ```kotlin
              data class Box(val items: MutableList<Int>)
              
              fun main() {
                  val a = Box(mutableListOf(1))
                  val b = a.copy()
                  b.items.add(2)
                  println(a.items)
              }
              ```
            explanation: "`copy` is shallow: both `a` and `b` reference the same `MutableList`,\
        \ so mutating one is visible in the other."
            repeatable: false
            answers:
              - "[]"
              - "[1]"
              - "[2]"
              - "[1, 2]"
              - "Compilation error"
            correct: "[1, 2]"
          - type: "question-multiple-answer"
            stepId: "lesson-11_data_classes-copying-objects-q2"
            question: "Which statements about `data` class `copy` and invariants are true?"
            explanation: "Generated `copy` calls the primary constructor, so `init/require`\
        \ run. Its parameters default to `this`'s property values. `copy` is shallow\
        \ (not deep). Data classes suit immutable (val) constrained properties; with\
        \ vars, invariants cannot be enforced post-creation."
            repeatable: true
            answers:
              - "`copy` uses the primary constructor and thus runs `init {}` checks (e.g.,\
        \ `require`)."
              - "Each `copy` parameter defaults to the current value of the corresponding\
        \ property."
              - "`copy` performs a deep copy of nested objects/collections."
              - "Using `var` for constrained properties in a data class makes it impossible\
        \ to guarantee invariants after creation."
              - "`copy` allows changing properties that are not in the primary constructor."
            correct:
              - "`copy` uses the primary constructor and thus runs `init {}` checks (e.g.,\
        \ `require`)."
              - "Each `copy` parameter defaults to the current value of the corresponding\
        \ property."
              - "Using `var` for constrained properties in a data class makes it impossible\
        \ to guarantee invariants after creation."
          - type: "text"
            stepId: "lesson-11_data_classes-destructuring-text"
            repeatable: false
            text: |-
              Kotlin supports a feature called position-based destructuring, which lets us assign multiple variables to components of a single object. For that, we place our variable names in round brackets.
              
              ```kotlin
              data class Player(
                 val id: Int,
                 val name: String,
                 val points: Int
              )
              
              fun main() {
                 val player = Player(0, "Gecko", 9999)
                 val (id, name, pts) = player
                 println(id) // 0
                 println(name) // Gecko
                 println(pts) // 9999
              }
              ```
              
              This mechanism relies on position, not names. The object on the right side of the equality sign needs to provide the functions `component1`, `component2`, etc., and the variables are assigned to the results of these methods.
              
              ```kotlin
              val (id, name, pts) = player
              // is compiled to
              val id: Int = player.component1()
              val name: String = player.component2()
              val pts: Int = player.component3()
              ```
              
              This code works because the `data` modifier generates `componentN` functions for each primary constructor parameter, according to their order in the constructor.
              
              These are currently all the functionalities that the `data` modifier provides. Don't use it if you don't need `toString`, `equals`, `hashCode`, `copy` or destructuring. If you need some of these functionalities for a class representing a bundle of data, use the `data` modifier instead of implementing the methods yourself.
          - type: "question-multiple-answer"
            stepId: "lesson-11_data_classes-destructuring-q1"
            question: "Which statements about Kotlin destructuring are true?"
            explanation: "Destructuring calls component1, component2, etc., by position.\
        \ Data classes generate these only for primary constructor parameters. Non-constructor\
        \ properties don’t get componentN; neither data modifier nor copy is required\
        \ for destructuring if componentN exist."
            repeatable: true
            answers:
              - "Destructuring assigns variables based on componentN positions, not variable\
        \ names."
              - "For data classes, componentN functions are generated for all parameters declared\
        \ in the primary constructor, in order."
              - "Destructuring requires the class to be marked as data."
              - "The presence of copy is necessary for destructuring to work."
              - "Adding a property outside the primary constructor does not create an extra\
        \ componentN used in destructuring."
            correct:
              - "Destructuring assigns variables based on componentN positions, not variable\
        \ names."
              - "For data classes, componentN functions are generated for all parameters declared\
        \ in the primary constructor, in order."
              - "Adding a property outside the primary constructor does not create an extra\
        \ componentN used in destructuring."
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-destructuring-q2"
            question: |-
              Given the code:
              
              ```kotlin
              data class Player(val id: Int, val name: String) {
                  val points: Int = 0
              }
              
              fun main() {
                  val (id, name, pts) = Player(1, "Gecko")
              }
              ```
              Why does this fail to compile?
            explanation: "Data classes generate componentN only for primary constructor\
        \ parameters. Here, no component3() exists for points."
            repeatable: false
            answers:
              - "Because properties declared in the class body do not generate componentN\
        \ functions, so component3() is missing."
              - "Because data classes cannot have properties declared in the class body."
              - "Because destructuring requires all variables to be declared as var."
              - "Because the variable name pts must match the property name points."
            correct: "Because properties declared in the class body do not generate componentN\
        \ functions, so component3() is missing."
          - type: "text"
            stepId: "lesson-11_data_classes-when-and-how-should-we-use-destructuring?-text"
            repeatable: false
            text: |-
              Position-based destructuring has pros and cons. Its biggest advantage is that we can name variables however we want, so we can use names like `country` and `city` in the example below. We can also destructure anything we want as long as it provides `componentN` functions. This includes `List` and `Map.Entry`, both of which have `componentN` functions defined as extensions:
              
              ```kotlin
              fun main() {
                 val visited = listOf("Spain", "Morocco", "India")
                 val (first, second, third) = visited
                 println("$first $second $third")
                 // Spain Morocco India
              
                 val trip = mapOf(
                     "Spain" to "Gran Canaria",
                     "Morocco" to "Taghazout",
                     "India" to "Rishikesh"
                 )
                 for ((country, city) in trip) {
                     println("We loved $city in $country")
                     // We loved Gran Canaria in Spain
                     // We loved Taghazout in Morocco
                     // We loved Rishikesh in India
                 }
              }
              ```
              
              On the other hand, position-based destructuring is dangerous. We need to adjust every destructuring when the order or number of elements in a data class changes. When we use this feature, it is very easy to introduce errors into our code by changing the order of the primary constructor’s properties.
              
              ```kotlin
              data class FullName(
                 val firstName: String,
                 val secondName: String,
                 val lastName: String
              )
              
              val elon = FullName("Elon", "Reeve", "Musk")
              val (name, surname) = elon
              print("It is $name $surname!") // It is Elon Reeve!
              ```
              
              We need to be careful with destructuring. It is useful to use the same names as data class primary constructor properties. In the case of an incorrect order, an IntelliJ/Android Studio warning will be shown. It might even be useful to upgrade this warning to an error.
              
              {width: 84%}
              ![](data_fullname.png)
              
              Destructuring a single value in lambda is very confusing, especially since parentheses around arguments in lambda expressions are either optional or required in some languages.
              
              ```kotlin
              data class User(
                 val name: String,
                 val surname: String,
              )
              
              fun main() {
                 val users = listOf(
                     User("Nicola", "Corti")
                 )
                 users.forEach { u -> println(u) }
                 // User(name=Nicola, surname=Corti)
                 users.forEach { (u) -> println(u) }
                 // Nicola
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-when-and-how-should-we-use-destructuring?-q1"
            question: |-
              What does the following code print?
              
              ```kotlin
              data class User(val name: String, val surname: String)
              
              val users = listOf(User("Nicola", "Corti"))
              users.forEach { (u) -> println(u) }
              ```
            explanation: "Parentheses in the lambda parameter trigger destructuring. With\
        \ a single name, it binds to component1 (name), so `u` is \"Nicola\"."
            repeatable: true
            answers:
              - "User(name=Nicola, surname=Corti)"
              - "Nicola"
              - "Corti"
              - "Compilation error"
            correct: "Nicola"
          - type: "question-multiple-answer"
            stepId: "lesson-11_data_classes-when-and-how-should-we-use-destructuring?-q2"
            question: "Which of the following Kotlin types provide componentN extension\
        \ functions in the standard library that enable destructuring?"
            explanation: "`List` and `Map.Entry` have `componentN` defined as extensions\
        \ in the stdlib; `Set`, `Sequence`, and `String` do not."
            repeatable: false
            answers:
              - "List"
              - "Map.Entry"
              - "Set"
              - "Sequence"
              - "String"
            correct:
              - "List"
              - "Map.Entry"
          - type: "text"
            stepId: "lesson-11_data_classes-data-class-limitations-text"
            repeatable: false
            text: |-
              The idea behind data classes is that they represent a bundle of data; their constructors allow us to specify all this data, and we can access it through destructuring or by copying them to another instance with the `copy` method. This is why only primary constructor properties are considered by the methods defined in data classes.
              
              ```kotlin
              data class Dog(
                 val name: String,
              ) {
                 // Bad practice, avoid mutable properties in data classes
                 var trained = false
              }
              
              fun main() {
                 val d1 = Dog("Cookie")
                 d1.trained = true
                 println(d1) // Dog(name=Cookie)
                 // so nothing about trained property
              
                 val d2 = d1.copy()
                 println(d1.trained) // true
                 println(d2.trained) // false
                 // so trained value not copied
              }
              ```
              
              Data classes are supposed to keep all the essential properties in their primary constructor. Inside the body, we should only keep redundant immutable properties, which means properties whose value is distinctly calculated from primary constructor properties, like `fullName`, which is calculated from `name` and `surname`. Such values are also ignored by data class methods, but their value will always be correct because it will be calculated when a new object is created.
              
              ```kotlin
              data class FullName(
                 val name: String,
                 val surname: String,
              ) {
                 val fullName = "$name $surname"
              }
              
              fun main() {
                 val d1 = FullName("Cookie", "Moskała")
                 println(d1.fullName) // Cookie Moskała
                 println(d1) // FullName(name=Cookie, surname=Moskała)
              
                 val d2 = d1.copy()
                 println(d2.fullName) // Cookie Moskała
                 println(d2) // FullName(name=Cookie, surname=Moskała)
              }
              ```
              
              You should also remember that data classes must be **final** and so cannot be used as a super-type for inheritance.
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-data-class-limitations-q1"
            question: |-
              Given the code:
              
              ```kotlin
              data class Dog(val name: String) {
                  var trained = false
                  val label = "Dog:$name"
              }
              
              fun main() {
                  val a = Dog("Cookie")
                  a.trained = true
                  val b = a.copy()
                  println(a == b)
                  println("${b.trained} ${b.label} ${b}")
              }
              ```
              What is the output?
            explanation: "Data class methods (equals/toString/copy/componentN) consider\
        \ only primary constructor properties. `copy()` constructs a new instance\
        \ using only `name`, so `b.trained` resets to default `false`; `label` is\
        \ recomputed; `toString()` prints only `name`."
            repeatable: false
            answers:
              - |-
                true
                false Dog:Cookie Dog(name=Cookie)
              - |-
                true
                true Dog:Cookie Dog(name=Cookie)
              - |-
                false
                false Dog:Cookie Dog(name=Cookie)
              - |-
                true
                false Dog:Cookie Dog(name=Cookie, trained=false)
            correct: |-
              true
              false Dog:Cookie Dog(name=Cookie)
          - type: "question-multiple-answer"
            stepId: "lesson-11_data_classes-data-class-limitations-q2"
            question: "In Kotlin data classes, which of the following are based solely on\
        \ primary constructor properties (i.e., ignore properties declared in the\
        \ class body)? Select all that apply."
            explanation: "Only primary constructor properties are considered by data class-generated\
        \ methods: equals, hashCode, toString, copy, and componentN. Body properties\
        \ (mutable or derived) are ignored by these methods."
            repeatable: true
            answers:
              - "Auto-generated equals/hashCode"
              - "Auto-generated toString"
              - "copy()"
              - "componentN() functions used for destructuring"
              - "Default getters for properties declared in the class body"
            correct:
              - "Auto-generated equals/hashCode"
              - "Auto-generated toString"
              - "copy()"
              - "componentN() functions used for destructuring"
          - type: "text"
            stepId: "lesson-11_data_classes-prefer-data-classes-instead-of-tuples-text"
            repeatable: false
            text: "Data classes offer more than what is generally provided by tuples. Historically,\
        \ they replaced tuples in Kotlin since they are considered better practice.\
        \ The only tuples that are left are `Pair` and `Triple`, but these are data\
        \ classes under the hood:\n\n```kotlin\ndata class Pair<out A, out B>(\n \
        \  val first: A,\n   val second: B\n) : Serializable {\n\n   override fun\
        \ toString(): String =\n       \"($first, $second)\"\n}\n\ndata class Triple<out\
        \ A, out B, out C>(\n   val first: A,\n   val second: B,\n   val third: C\n\
        ) : Serializable {\n\n   override fun toString(): String =\n       \"($first,\
        \ $second, $third)\"\n}\n```\n\nThe easiest way to create a `Pair` is by using\
        \ the `to` function. This is a generic infix extension function, defined as\
        \ follows (we will discuss both generic and extension functions in later chapters).\n\
        \n```kotlin\ninfix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\
        ```\n\nThanks to the infix modifier, a method can be used by placing its name\
        \ between arguments, as the infix name suggests. The result `Pair` is typed,\
        \ so the result type from the `\"ABC\" to 123` expression is `Pair<String,\
        \ Int>`.\n\n```kotlin\nfun main() {\n   val p1: Pair<String, Int> = \"ABC\"\
        \ to 123\n   println(p1) // (ABC, 123)\n   val p2 = 'A' to 3.14 \n   // the\
        \ type of p2 is Pair<Char, Double>\n   println(p2) // (A, 123)\n   val p3\
        \ = true to false\n   // the type of p3 is Pair<Boolean, Boolean>\n   println(p3)\
        \ // (true, false)\n}\n```\n\nThese tuples remain because they are very useful\
        \ for local purposes, like:\n\n* When we immediately name values:\n\n```kotlin\n\
        val (description, color) = when {\n   degrees < 5 -> \"cold\" to Color.BLUE\n\
        \   degrees < 23 -> \"mild\" to Color.YELLOW\n   else -> \"hot\" to Color.RED\n\
        }\n```\n\n* To represent an aggregate that is not known in advance, as is\
        \ commonly the case in standard library functions:\n\n```kotlin\nval (odd,\
        \ even) = numbers.partition { it % 2 == 1 }\nval map = mapOf(1 to \"San Francisco\"\
        , 2 to \"Amsterdam\")\n```\n\nIn other cases, we prefer data classes. Take\
        \ a look at an example: let’s say that we need a function that parses a full\
        \ name into a name and a surname. One might represent this name and surname\
        \ as a `Pair<String, String>`:\n\n```kotlin\nfun String.parseName(): Pair<String,\
        \ String>? {\n   val indexOfLastSpace = this.trim().lastIndexOf(' ')\n   if\
        \ (indexOfLastSpace < 0) return null\n   val firstName = this.take(indexOfLastSpace)\n\
        \   val lastName = this.drop(indexOfLastSpace)\n   return Pair(firstName,\
        \ lastName)\n}\n\n// Usage\nfun main() {\n  val fullName = \"Marcin Moskał\
        a\"\n  val (firstName, lastName) = fullName.parseName() ?: return\n}\n```\n\
        \nThe problem is that when someone reads this code, it is not clear that `Pair<String,\
        \ String>` represents a full name. What is more, it is not clear what the\
        \ order of the values is, therefore someone might think that the surname goes\
        \ first:\n\n```kotlin\nval fullName = \"Marcin Moskała\"\nval (lastName, firstName)\
        \ = fullName.parseName() ?: return\nprint(\"His name is $firstName\") // His\
        \ name is Moskała\n```\n\nTo make usage safer and the function easier to read,\
        \ we should use a data class instead:\n\n```kotlin\ndata class FullName(\n\
        \   val firstName: String,\n   val lastName: String\n)\n\nfun String.parseName():\
        \ FullName? {\n   val indexOfLastSpace = this.trim().lastIndexOf(' ')\n  \
        \ if (indexOfLastSpace < 0) return null\n   val firstName = this.take(indexOfLastSpace)\n\
        \   val lastName = this.drop(indexOfLastSpace)\n   return FullName(firstName,\
        \ lastName)\n}\n\n// Usage\nfun main() {\n  val fullName = \"Marcin Moskał\
        a\"\n  val (firstName, lastName) = fullName.parseName() ?: return\n  print(\"\
        His name is $firstName $lastName\") \n  // His name is Marcin Moskała\n}\n\
        ```\n\nThis costs nearly nothing and improves the function significantly:\n\
        \n* The return type of this function is more clear.\n\n* The return type is\
        \ shorter and easier to pass forward.\n\n* If a user destructures variables\
        \ with correct names but in incorrect positions, a warning will be displayed\
        \ in IntelliJ.\n\nIf you don’t want this class in a wider scope, you can restrict\
        \ its visibility. It can even be private if you only need to use it for some\
        \ local processing in a single file or class. It is worth using data classes\
        \ instead of tuples. Classes are cheap in Kotlin, so don’t be afraid to use\
        \ them in your projects."
          - type: "question-multiple-answer"
            stepId: "lesson-11_data_classes-prefer-data-classes-instead-of-tuples-q1"
            question: "When is using `Pair`/`Triple` preferred over defining a dedicated\
        \ data class?"
            explanation: "Pairs/Triples are fine for short-lived, local grouping and for\
        \ APIs where the aggregate is not known in advance (common in stdlib). For\
        \ domain concepts and public APIs, a named data class is clearer and safer.\
        \ Classes are cheap in Kotlin."
            repeatable: true
            answers:
              - "Immediate local grouping with destructuring (e.g., in when branches)"
              - "Standard library aggregations with unknown shape (e.g., partition, mapOf)"
              - "Returning a domain concept from an API (e.g., FullName)"
              - "Avoiding the cost of creating small classes"
              - "Long-lived, self-documenting types across module boundaries"
            correct:
              - "Immediate local grouping with destructuring (e.g., in when branches)"
              - "Standard library aggregations with unknown shape (e.g., partition, mapOf)"
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-prefer-data-classes-instead-of-tuples-q2"
            question: "Which Kotlin modifier enables calling `\"ABC\" to 123` instead of\
        \ `\"ABC\".to(123)`?"
            explanation: "`to` is declared with the `infix` modifier, which allows calling\
        \ it using infix notation between the receiver and the argument."
            repeatable: false
            answers:
              - "infix"
              - "operator"
              - "inline"
              - "suspend"
            correct: "infix"
          - type: "text"
            stepId: "lesson-11_data_classes-summary-text"
            repeatable: false
            text: |-
              In this chapter, we've learned about `Any`, which is a superclass of all classes. We’ve also learned about methods defined by `Any`: `equals`, `hashCode`, and `toString`. We’ve also learned that there are two primary types of objects. Regular objects are considered unique and do not expose their details. Data class objects, which we made using the `data` modifier, represent bundles of data (we keep them in primary constructor properties). They are equal when they hold the same data. When transformed to a string, they print all their data. They additionally support destructuring and making a copy with the `copy` method. Two generic data classes in Kotlin stdlib are `Pair` and `Triple`, but (apart from certain cases) we prefer to use custom data classes instead of these. Also, for the sake of safety, when we destructure a data class, we prefer to match the variable names with the parameter names.
              
              Now, let's move on to a topic dedicated to special Kotlin syntax that lets us create objects without defining a class.
          - type: "question-multiple-answer"
            stepId: "lesson-11_data_classes-summary-q1"
            question: |-
              Given:
              
              ```kotlin
              data class Customer(val id: Int, val name: String)
              class Order(val id: Int, val name: String) // no overrides
              ```
              
              Which statements are true in Kotlin?
            explanation: "Data classes auto-generate value-based equals/hashCode, a detailed\
        \ toString, copy, and componentN for destructuring. Regular classes use Any's\
        \ defaults (reference equality, non-detailed toString) and have no componentN."
            repeatable: true
            answers:
              - "Customer(1, \"A\") == Customer(1, \"A\")"
              - "Order(1, \"A\") == Order(1, \"A\")"
              - "Customer(1, \"A\").toString() contains \"id\" and \"name\" values"
              - "Order(1, \"A\").component1() returns id by default"
              - "Customer(1, \"A\").copy(name = \"B\").id == 1"
            correct:
              - "Customer(1, \"A\") == Customer(1, \"A\")"
              - "Customer(1, \"A\").toString() contains \"id\" and \"name\" values"
              - "Customer(1, \"A\").copy(name = \"B\").id == 1"
          - type: "question-single-answer"
            stepId: "lesson-11_data_classes-summary-q2"
            question: "When modeling two related values in your domain, what is generally\
        \ preferred?"
            explanation: "Prefer custom data classes to Pair/Triple: they provide meaningful\
        \ names, value-based equality, toString, copy, and safer destructuring."
            repeatable: true
            answers:
              - "Use Pair<A, B> directly for readability"
              - "Define a custom data class with named properties"
              - "Use Triple<A, B, C> with C = Unit"
              - "Use a regular class and rely on reference equality"
            correct: "Define a custom data class with named properties"
      - lessonId: "lesson-nullability"
        name: "Nullability"
        steps:
          - type: "text"
            stepId: "lesson-08_nullability-#-nullability-text"
            repeatable: false
            text: "Kotlin started as a remedy to Java problems, and the biggest problem\
        \ in Java is nullability. In Java, like in many other languages, every variable\
        \ is nullable, so it might have the `null` value. Every call on a `null` value\
        \ leads to the famous `NullPointerException` (NPE). This is the #1 exception\
        \ in most Java projects. It is so common that it is often referred to as “\
        the billion dollar mistake” after the famous speech by Sir Charles Antony\
        \ Richard Hoare, where he said: “I call it my billion-dollar mistake. It was\
        \ the invention of the null reference in 1965… This has led to innumerable\
        \ errors, vulnerabilities, and system crashes, which have probably caused\
        \ a billion dollars of pain and damage in the last forty years”.\n\nOne of\
        \ Kotlin's priorities was to solve this problem finally, and it achieved this\
        \ perfectly. The mechanisms introduced in Kotlin are so effective that seeing\
        \ `NullPointerException` thrown from Kotlin code is extremely rare. The `null`\
        \ value stopped being a problem, and Kotlin developers are no longer scared\
        \ of it. It has become our friend.\n\nSo, how does nullability work in Kotlin?\
        \ Everything is based on a few rules:\n\n1. Every property needs to have an\
        \ explicit value. There is no such thing as an implicit `null` value.\n\n\
        ```kotlin\nvar person: Person // COMPILATION ERROR, \n// the property needs\
        \ to be initialized\n```\n\n2. A regular type does not accept the `null` value.\n\
        \n```kotlin\nvar person: Person = null // COMPILATION ERROR,\n// Person is\
        \ not a nullable type, and cannot be `null`\n```\n\n3. To specify a nullable\
        \ type, you need to end a regular type with a question mark (`?`).\n\n```kotlin\n\
        var person: Person? = null // OK\n```\n\n4. Nullable values cannot be used\
        \ directly. They must be used safely or cast first (using one of the tools\
        \ presented later in this chapter).\n\n```kotlin\nperson.name // COMPILATION\
        \ ERROR,\n// person type is nullable, so we cannot use it directly\n```\n\n\
        Thanks to all these mechanisms, we always know what can be `null` and what\
        \ cannot. We use nullability only when we need it - when there is a reason\
        \ to. In such cases, users are forced to explicitly handle this nullability.\
        \ In all other cases, there is no need to do this. This is a perfect solution,\
        \ but good tools are needed to deal with nullability in a way that’s convenient\
        \ for developers.\n\nKotlin supports a variety of ways of using a nullable\
        \ value, including safe calls, not-null assertions, smart-casting, or the\
        \ Elvis operator. Let's discuss these one by one."
          - type: "question-multiple-answer"
            stepId: "lesson-08_nullability-#-nullability-q1"
            question: "Which of the following Kotlin declarations compile without errors?"
            explanation: "Regular (non-null) types cannot hold null; nullable types are\
        \ marked with `?`. Properties/vals must be initialized when declared."
            repeatable: true
            answers:
              - "val name: String"
              - "var name: String = \"Kotlin\""
              - "var name: String? = null"
              - "val name: String? = null"
              - "var name: String = null"
              - "val name: String?"
            correct:
              - "var name: String = \"Kotlin\""
              - "var name: String? = null"
              - "val name: String? = null"
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-#-nullability-q2"
            question: |-
              Given:
              
              ```kotlin
              data class Person(val name: String)
              val person: Person? = null
              ```
              What happens when evaluating `person.name`?
            explanation: "Nullable receivers cannot be used directly. Use a safe call (`person?.name`),\
        \ not-null assertion (`person!!.name`), or smart-cast after a null check."
            repeatable: true
            answers:
              - "Compilation error: cannot access 'name' on a nullable receiver"
              - "NullPointerException at runtime"
              - "Returns null"
              - "It smart-casts 'person' to non-null and accesses 'name'"
            correct: "Compilation error: cannot access 'name' on a nullable receiver"
          - type: "text"
            stepId: "lesson-08_nullability-safe-calls-text"
            repeatable: false
            text: |-
              The simplest way to call a method or a property on a nullable value is with a safe call, which is a question mark and a dot (`?.`) instead of just a regular dot (`.`). Safe calls work as follows:
              * if a value is `null`, it does nothing and returns `null`,
              * if a value is not `null`, it works like a regular call.
              
              ```kotlin
              class User(val name: String) {
                  fun cheer() {
                      println("Hello, my name is $name")
                  }
              }
              
              var user: User? = null
              
              fun main() {
                  user?.cheer() // (does nothing)
                  println(user?.name) // null
                  user = User("Cookie")
                  user?.cheer() // Hello, my name is Cookie
                  println(user?.name) // Cookie
              }
              ```
              
              Notice that the result of a safe call is always a nullable type because a safe call returns `null` when it is called on a `null`. This means that nullability propagates. If you need to find out the length of a user's name, calling `user?.name.length` will not compile. Even though `name` is not nullable, the result of `user?.name` is `String?`, so we need to use a safe call again: `user?.name?.length`.
              
              ```kotlin
              class User(val name: String) {
                  fun cheer() {
                      println("Hello, my name is $name")
                  }
              }
              
              var user: User? = null
              
              fun main() {
                  // println(user?.name.length) // ILLEGAL
                  println(user?.name?.length) // null
                  user = User("Cookie")
                  // println(user?.name.length) // ILLEGAL
                  println(user?.name?.length) // 6
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-safe-calls-q1"
            question: |-
              Given the code:
              
              ```kotlin
              class User(val name: String) {
                  fun cheer() = println("Hello, my name is $name")
              }
              
              var user: User? = User("Cookie")
              
              val a = user?.name
              val b = user?.name?.length
              val c = user?.cheer()
              ```
              What are the types of `a`, `b`, and `c`?
            explanation: "A safe call (`?.`) makes the result type nullable. `user?.name`\
        \ -> String?, then `?.length` -> Int?, and calling a Unit-returning function\
        \ via `?.` yields `Unit?`."
            repeatable: true
            answers:
              - "a: String?, b: Int?, c: Unit?"
              - "a: String, b: Int, c: Unit?"
              - "a: String?, b: Int, c: Unit"
              - "a: String, b: Int?, c: Unit"
            correct: "a: String?, b: Int?, c: Unit?"
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-safe-calls-q2"
            question: |-
              What is the output of the program?
              
              ```kotlin
              class User(val name: String) {
                  fun cheer() = println("Hello, my name is $name")
              }
              
              fun main() {
                  var user: User? = User("Ann")
                  println(user?.cheer())
                  user = null
                  println(user?.cheer())
              }
              ```
            explanation: "`user?.cheer()` calls `cheer()` and returns `Unit?`. For non-null\
        \ `user`, it prints the greeting, then `println` prints `kotlin.Unit`. For\
        \ null `user`, the safe call returns null, so `println` prints `null`."
            repeatable: false
            answers:
              - |-
                Hello, my name is Ann
                kotlin.Unit
                null
              - |-
                Hello, my name is Ann
                null
              - |-
                kotlin.Unit
                null
              - |-
                Hello, my name is Ann
                kotlin.Unit
                kotlin.Unit
            correct: |-
              Hello, my name is Ann
              kotlin.Unit
              null
          - type: "text"
            stepId: "lesson-08_nullability-not-null-assertion-text"
            repeatable: false
            text: |-
              When we don’t expect a `null` value, and we want to throw an exception if one occurs, we can use the not-null assertion `!!`.
              
              ```kotlin
              class User(val name: String) {
                  fun cheer() {
                      println("Hello, my name is $name")
                  }
              }
              
              var user: User? = User("Cookie")
              
              fun main() {
                  println(user!!.name.length) // 6
                  user = null
                  println(user!!.name.length) // throws NullPointerException
              }
              ```
              
              This is not a very safe option because if we are wrong and a `null` value is where we don't expect it, this leads to a `NullPointerException`. Sometimes we want to throw an exception to ensure that there are no situations where `null` is used, but we generally prefer to throw a more meaningful exception. For this, the most popular options are:
              - `requireNotNull`, which accepts a nullable value as an argument and throws `IllegalArgumentException` if this value is null. Otherwise, it returns this value as non-nullable.
              - `checkNotNull`, which accepts a nullable value as an argument and throws `IllegalStateException` if this value is null. Otherwise, it returns this value as non-nullable.
              
              ```kotlin
              private val connections = ConcurrentHashMap<String, Connection>()
              
              fun sendData(dataWrapped: Wrapper<Data>) {
                  val data = requireNotNull(dataWrapped.data)
                  val connection = checkNotNull(connections["db"])
                  connection.send(data)
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-08_nullability-not-null-assertion-q1"
            question: "Select all correct statements about `!!`, `requireNotNull`, and `checkNotNull`."
            explanation: "`!!` throws NullPointerException on null. `requireNotNull` throws\
        \ IllegalArgumentException and returns a non-null value. `checkNotNull` throws\
        \ IllegalStateException and returns a non-null value."
            repeatable: true
            answers:
              - "`user!!.name` throws NullPointerException if `user` is null"
              - "`requireNotNull(x)` throws IllegalStateException when `x` is null"
              - "`checkNotNull(x)` returns a non-nullable reference when `x` is not null"
              - "`requireNotNull(x)` returns `Unit` when `x` is not null"
              - "`requireNotNull` and `checkNotNull` accept nullable values and return non-null\
        \ on success"
            correct:
              - "`user!!.name` throws NullPointerException if `user` is null"
              - "`checkNotNull(x)` returns a non-nullable reference when `x` is not null"
              - "`requireNotNull` and `checkNotNull` accept nullable values and return non-null\
        \ on success"
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-not-null-assertion-q2"
            question: |-
              Fill `???` so it throws IllegalStateException when missing and `conn` is non-nullable.
              
              ```kotlin
              val connections = ConcurrentHashMap<String, Connection>()
              
              fun send(data: Data) {
                  val conn = ???
                  conn.send(data)
              }
              ```
            explanation: "`checkNotNull(connections[\"db\"])` throws IllegalStateException\
        \ on null and returns a non-null `Connection`. `requireNotNull` throws IllegalArgumentException,\
        \ `!!` throws NullPointerException, and `getValue` throws NoSuchElementException."
            repeatable: true
            answers:
              - "checkNotNull(connections[\"db\"])"
              - "requireNotNull(connections[\"db\"])"
              - "connections[\"db\"]!!"
              - "connections.getValue(\"db\")"
            correct: "checkNotNull(connections[\"db\"])"
          - type: "text"
            stepId: "lesson-08_nullability-smart-casting-text"
            repeatable: false
            text: |-
              Smart-casting also works for nullability. Therefore, in the scope of a non-nullability check, a nullable type is cast to a non-nullable type.
              
              ```kotlin
              fun printLengthIfNotNull(str: String?) {
                  if (str != null) {
                      println(str.length) // str smart-casted to String
                  }
              }
              ```
              
              Smart-casting also works when we use `return` or `throw` if a value is not `null`.
              
              ```kotlin
              fun printLengthIfNotNull(str: String?) {
                  if (str == null) return
                  println(str.length) // str smart-casted to String
              }
              ```
              
              ```kotlin
              fun printLengthIfNotNullOrThrow(str: String?) {
                  if (str == null) throw Error()
                  println(str.length) // str smart-casted to String
              }
              ```
              
              Smart-casting is quite smart and works in different cases, such as after `&&` and `||` in logical expressions.
              
              ```kotlin
              fun printLengthIfNotNull(str: String?) {
                  if (str != null && str.length > 0) {
                      // str in expression above smart-casted to String
                      // ...
                  }
              }
              ```
              
              ```kotlin
              fun printLengthIfNotNull(str: String?) {
                  if (str == null || str.length == 0) {
                      // str in expression above smart-casted to String
                      // ...
                  }
              }
              ```
              
              ```kotlin
              fun printLengthIfNotNullOrThrow(str: String?) {
                  requireNotNull(str) // str smart-casted to String
                  println(str.length)
              }
              ```
              
              > Smart-casting works in the code above thanks to a feature called **contracts**, which is explained in the book *Advanced Kotlin*.
          - type: "question-multiple-answer"
            stepId: "lesson-08_nullability-smart-casting-q1"
            question: "Select ALL snippets where the marked `s` is smart-cast to `String`\
        \ at the marked location."
            explanation: "Kotlin smart-casts a nullable to non-null inside the true branch\
        \ of `s != null`, after early return/throw from the null branch, on the RHS\
        \ of `&&` and `||` when the LHS implies non-null, and after `requireNotNull(s)`\
        \ thanks to contracts."
            repeatable: true
            answers:
              - |-
                A)
                val s: String? = get()
                if (s != null) {
                    println(s.length) // here
                }
              - |-
                B)
                val s: String? = get()
                if (s == null) return
                println(s.length) // here
              - |-
                C)
                val s: String? = get()
                if (s != null && s.length > 0) { } // the s in `s.length` here
              - |-
                D)
                val s: String? = get()
                if (s == null || s.length == 0) { } // the s in `s.length` here
              - |-
                E)
                val s: String? = get()
                requireNotNull(s)
                println(s.length) // here
              - |-
                F)
                val s: String? = get()
                if (s == null) println(s.length) // here
            correct:
              - |-
                A)
                val s: String? = get()
                if (s != null) {
                    println(s.length) // here
                }
              - |-
                B)
                val s: String? = get()
                if (s == null) return
                println(s.length) // here
              - |-
                C)
                val s: String? = get()
                if (s != null && s.length > 0) { } // the s in `s.length` here
              - |-
                D)
                val s: String? = get()
                if (s == null || s.length == 0) { } // the s in `s.length` here
              - |-
                E)
                val s: String? = get()
                requireNotNull(s)
                println(s.length) // here
          - type: "question-exact-text"
            stepId: "lesson-08_nullability-smart-casting-q2"
            question: "What Kotlin language feature enables smart-casting after calls like\
        \ `requireNotNull(s)`?"
            explanation: "Library functions like `requireNotNull` declare contracts that\
        \ inform the compiler about conditions that hold after the call."
            repeatable: false
            correct:
              - "contracts"
              - "kotlin contracts"
              - "contract"
          - type: "text"
            stepId: "lesson-08_nullability-the-elvis-operator-text"
            repeatable: false
            text: |-
              The last special Kotlin feature that is used to support nullability is the Elvis operator `?:`. Yes, it is a question mark and a colon. It is called the Elvis operator because it looks like Elvis Presley (with his characteristic hair), looking at us from behind a wall, so we can only see his hair and eyes.
              
              ![](elvis.png)
              
              It is placed between two values. If the value on the left side of the Elvis operator is not `null`, we use the nullable value that results from the Elvis operator. If the left side is `null`, then the right side is returned.
              
              ```kotlin
              fun main() {
                  println("A" ?: "B") // A
                  println(null ?: "B") // B
                  println("A" ?: null) // A
                  println(null ?: null) // null
              }
              ```
              
              We can use the Elvis operator to provide a default value for nullable values.
              
              ```kotlin
              class User(val name: String)
              
              fun printName(user: User?) {
                  val name: String = user?.name ?: "default"
                  println(name)
              }
              
              fun main() {
                  printName(User("Cookie")) // Cookie
                  printName(null) // default
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-the-elvis-operator-q1"
            question: |-
              Given:
              
              ```kotlin
              fun f(s: String?): String {
                  val v = s ?: "N/A"
                  return v
              }
              ```
              What is the inferred type of `v`?
            explanation: "With `s: String?` and RHS `String`, `s ?: \"N/A\"` has type `String`\
        \ (the common supertype considering nullability)."
            repeatable: true
            answers:
              - "String"
              - "String?"
              - "Any"
              - "Any?"
            correct: "String"
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-the-elvis-operator-q2"
            question: |-
              What does this program print?
              
              ```kotlin
              var calls = 0
              fun side(): String { calls++; return "X" }
              
              fun main() {
                  println("A" ?: side())
                  println(null ?: side())
                  println("B" ?: side())
                  println(calls)
              }
              ```
            explanation: "The RHS of `?:` is evaluated only when the LHS is null. Calls\
        \ occur only for the second line, so outputs are A, X, B, then 1."
            repeatable: false
            answers:
              - |-
                A
                X
                B
                1
              - |-
                A
                X
                B
                2
              - |-
                A
                X
                X
                2
              - |-
                A
                X
                X
                3
            correct: |-
              A
              X
              B
              1
          - type: "text"
            stepId: "lesson-08_nullability-extensions-on-nullable-types-text"
            repeatable: false
            text: |-
              Regular functions cannot be called on nullable variables. However, there is a special kind of function that can be defined such that it can be called on nullable variables. Thanks to this, Kotlin stdlib defines the following functions that can be called on `String?`:
              * `orEmpty` returns the value if it is not `null`. Otherwise it returns an empty string.
              * `isNullOrEmpty` returns `true` if the value is `null` or empty. Otherwise, it returns `false`.
              * `isNullOrBlank` returns `true` if the value is `null` or blank. Otherwise, it returns `false`.
              
              ```kotlin
              fun check(str: String?) {
                  println("The value: \"$str\"")
                  println("The value or empty: \"${str.orEmpty()}\"")
                  println("Is it null or empty? " + str.isNullOrEmpty())
                  println("Is it null or blank? " + str.isNullOrBlank())
              }
              
              fun main() {
                  check("ABC")
                  // The value: "ABC"
                  // The value or empty: "ABC"
                  // Is it null or empty? false
                  // Is it null or blank? false
                  check(null)
                  // The value: "null"
                  // The value or empty: ""
                  // Is it null or empty? true
                  // Is it null or blank? true
                  check("")
                  // The value: ""
                  // The value or empty: ""
                  // Is it null or empty? true
                  // Is it null or blank? true
                  check("       ")
                  // The value: "       "
                  // The value or empty: "       "
                  // Is it null or empty? false
                  // Is it null or blank? true
              }
              ```
              
              Kotlin stdlib also includes similar functions for nullable lists:
              * `orEmpty` returns the value if it is not `null`. Otherwise, it returns an empty list .
              * `isNullOrEmpty` returns `true`, returns `true` if the value is `null` or empty. Otherwise, it returns `false`.
              
              ```kotlin
              fun check(list: List<Int>?) {
                  println("The list: \"$list\"")
                  println("The list or empty: \"${list.orEmpty()}\"")
                  println("Is it null or empty? " + list.isNullOrEmpty())
              }
              
              fun main() {
                  check(listOf(1, 2, 3))
                  // The list: "[1, 2, 3]"
                  // The list or empty: "[1, 2, 3]"
                  // Is it null or empty? false
                  check(null)
                  // The list: "null"
                  // The list or empty: "[]"
                  // Is it null or empty? true
                  check(listOf())
                  // The list: "[]"
                  // The list or empty: "[]"
                  // Is it null or empty? true
              }
              ```
              
              These functions help us operate on nullable values.
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-extensions-on-nullable-types-q1"
            question: |-
              Given the code:
              
              ```kotlin
              val s: String? = null
              val a: String = s.orEmpty()
              val b = s.isNullOrEmpty()
              val c = s.isNullOrBlank()
              
              val list: List<Int>? = null
              val d = list.orEmpty()
              ```
              What are the types of a, b, c, and d?
            explanation: "`orEmpty()` on `String?` returns non-null `String`; on `List<T>?`\
        \ returns non-null `List<T>`. `isNullOrEmpty()` and `isNullOrBlank()` return\
        \ `Boolean`."
            repeatable: true
            answers:
              - "a: String, b: Boolean, c: Boolean, d: List<Int>"
              - "a: String?, b: Boolean, c: Boolean, d: List<Int>?"
              - "a: String, b: Boolean?, c: Boolean, d: List<Int>"
              - "a: String, b: Boolean, c: Boolean, d: List<Int>?"
            correct: "a: String, b: Boolean, c: Boolean, d: List<Int>"
          - type: "question-multiple-answer"
            stepId: "lesson-08_nullability-extensions-on-nullable-types-q2"
            question: |-
              Assume:
              
              ```kotlin
              val sNull: String? = null
              val sEmpty: String? = ""
              val sSpaces: String? = "   "
              ```
              Which expressions evaluate to true?
            explanation: "`isNullOrEmpty()` is true only for null or empty. `isNullOrBlank()`\
        \ is true for null, empty, or only-whitespace. A spaces-only string is not\
        \ empty but is blank."
            repeatable: true
            answers:
              - "sNull.isNullOrEmpty()"
              - "sNull.isNullOrBlank()"
              - "sEmpty.isNullOrEmpty()"
              - "sEmpty.isNullOrBlank()"
              - "sSpaces.isNullOrEmpty()"
              - "sSpaces.isNullOrBlank()"
            correct:
              - "sNull.isNullOrEmpty()"
              - "sNull.isNullOrBlank()"
              - "sEmpty.isNullOrEmpty()"
              - "sEmpty.isNullOrBlank()"
              - "sSpaces.isNullOrBlank()"
          - type: "text"
            stepId: "lesson-08_nullability-`null`-is-our-friend-text"
            repeatable: false
            text: "Nullability was a source of pain in many languages like Java, where every\
        \ object can be nullable. As a result, people started avoiding nullability.\
        \ As a result, you can find suggestions like \"Item 43. Return empty arrays\
        \ or collections, not nulls\" from *Effective Java* 2nd Edition by Joshua\
        \ Bloch. Such practices make literally no sense in Kotlin, where we have a\
        \ proper nullability system and should not be worried about `null` values.\
        \ In Kotlin, we treat `null` as our friend, not as a mistake. Consider the\
        \ `getUsers` function. There is an essential difference between returning\
        \ an empty list and `null`. An empty list should be interpreted as \"the result\
        \ is an empty list of users because none are available\". The `null` result\
        \ should be interpreted as \"could not produce the result, and the list of\
        \ users remains unknown\". Forget about outdated practices regarding nullability.\
        \ The `null` value is our friend in Kotlin."
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-`null`-is-our-friend-q1"
            question: "You need getUsers to communicate either \"no users available\" or\
        \ \"could not produce a result/unknown.\" Which statement best matches Kotlin's\
        \ nullability philosophy?"
            explanation: "In Kotlin, null conveys \"no result/unknown\" while an empty collection\
        \ conveys a known empty result. The Java advice to always return empty collections\
        \ is outdated here."
            repeatable: true
            answers:
              - "Return null to mean \"unknown/unavailable,\" and return emptyList() to mean\
        \ \"known empty.\""
              - "Always return empty collections, never null, to avoid NPEs."
              - "Throw an exception for \"unknown/unavailable\" and return null for \"known\
        \ empty.\""
              - "Use non-null types everywhere and sentinel values to represent missing data."
            correct: "Return null to mean \"unknown/unavailable,\" and return emptyList()\
        \ to mean \"known empty.\""
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-`null`-is-our-friend-q2"
            question: "Which function signature lets getUsers express both \"no users\"\
        \ and \"result unknown\" directly in the type?"
            explanation: "Only a nullable container type (List<User>?) can return null (unknown)\
        \ or a non-null list (possibly empty) to represent a known result."
            repeatable: true
            answers:
              - "fun getUsers(): List<User>?"
              - "fun getUsers(): List<User>"
              - "fun getUsers(): Sequence<User>"
              - "fun getUsers(): Flow<User>"
            correct: "fun getUsers(): List<User>?"
          - type: "text"
            stepId: "lesson-08_nullability-lateinit-text"
            repeatable: false
            text: |-
              There are situations where we want to keep a property type not nullable, and yet we cannot specify its value during object creation. Consider properties whose value is injected by a dependency injection framework, or consider properties that are created for every test in the setup phase. Making such properties nullable would lead to inconvenient usage: you would use a not-null assertion even though you know that the value cannot be `null` because it will surely be initialized before usage. For such situations, Kotlin creators introduced the `lateinit` property. Such properties have non-nullable types, and cannot be initialized during creation.
              
              ```kotlin
              @AndroidEntryPoint
              class MainActivity : AppCompatActivity() {
              
                  @Inject
                  lateinit var presenter: MainPresenter
              
                  override fun onCreate(savedInstanceState: Bundle?) {
                      super.onCreate(savedInstanceState)
                      setContentView(R.layout.activity_main)
                      presenter.onCreate()
                  }
              }
              
              class UserServiceTest {
                  lateinit var userRepository: InMemoryUserRepository
                  lateinit var userService: UserService
              
                  @Before
                  fun setup() {
                      userRepository = InMemoryUserRepository()
                      userService = UserService(userRepository)
                  }
              
                  @Test
                  fun `should register new user`() {
                      // when
                      userService.registerUser(aRegisterUserRequest)
              
                      // then
                      userRepository.hasUserId(aRegisterUserRequest.id)
                      // ...
                  }
              }
              ```
              
              When we use a lateinit property, we must set its value before its first use. If we don't, the program throws an `UninitializedPropertyAccessException` at runtime.
              
              ```kotlin
              lateinit var text: String
              
              fun main() {
                  println(text) // RUNTIME ERROR!
                  // lateinit property text has not been initialized
              }
              ```
              
              You can always check if a property has been initialized using the `isInitialized` property on its reference. To reference a property, use two colons and a property name.
              
              ```kotlin
              lateinit var text: String
              
              private fun printIfInitialized() {
                  if (::text.isInitialized) {
                      println(text)
                  } else {
                      println("Not initialized")
                  }
              }
              
              fun main() {
                  printIfInitialized() // Not initialized
                  text = "ABC"
                  printIfInitialized() // ABC
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-08_nullability-lateinit-q1"
            question: |-
              Given the code:
              
              ```kotlin
              lateinit var text: String
              
              fun main() {
                  println(text)
              }
              ```
              What happens when main runs?
            explanation: "`lateinit var` must be assigned before first use; otherwise Kotlin\
        \ throws UninitializedPropertyAccessException at runtime."
            repeatable: false
            answers:
              - "It throws UninitializedPropertyAccessException at runtime."
              - "It fails to compile because text is not initialized."
              - "It prints null."
              - "It prints an empty string."
            correct: "It throws UninitializedPropertyAccessException at runtime."
          - type: "question-multiple-answer"
            stepId: "lesson-08_nullability-lateinit-q2"
            question: "Which statements about `lateinit` in Kotlin are correct according\
        \ to the section?"
            explanation: "lateinit keeps a property non-null while allowing deferred assignment;\
        \ using it before assignment throws UninitializedPropertyAccessException;\
        \ initialization status can be checked via `::prop.isInitialized`. The compiler\
        \ does not enforce initialization before use, and it does not yield null."
            repeatable: true
            answers:
              - "It lets you declare a non-nullable property whose value is set after object\
        \ creation."
              - "Accessing a `lateinit` property before it's set throws UninitializedPropertyAccessException\
        \ at runtime."
              - "You can check whether a `lateinit` property was set using `::prop.isInitialized`."
              - "The compiler guarantees a `lateinit` property is initialized before any use."
              - "Accessing an uninitialized `lateinit` property yields null."
            correct:
              - "It lets you declare a non-nullable property whose value is set after object\
        \ creation."
              - "Accessing a `lateinit` property before it's set throws UninitializedPropertyAccessException\
        \ at runtime."
              - "You can check whether a `lateinit` property was set using `::prop.isInitialized`."
          - type: "text"
            stepId: "lesson-08_nullability-summary-text"
            repeatable: false
            text: "Kotlin offers powerful nullability support that turns nullability from\
        \ scary and tricky into useful and safe. This is supported by the type system,\
        \ which separates what is nullable or not nullable. Variables that are nullable\
        \ must be used safely; for this, we can use safe-calls, not-null assertions,\
        \ smart-casting, or the Elvis operator. Now, let's finally move on to classes.\
        \ We’ve used them many times already, but we finally have everything we need\
        \ to describe them well."
          - type: "question-multiple-answer"
            stepId: "lesson-08_nullability-summary-q1"
            question: |-
              Given:
              
              ```kotlin
              val s: String? = readLine()
              ```
              Which of the following assignments compile without errors?
            explanation: |-
              - `s.length` is illegal on a nullable receiver.
              - `s?.length` has type `Int?` and compiles when assigned to `Int?`.
              - `s?.length ?: 0` uses Elvis to produce a non-null `Int`.
              - `if (s != null) s.length else 0` smart-casts `s` inside the branch.
              - `s ?: 0` fails due to type mismatch (`String` vs `Int`).
              - `s!!.length` compiles (but may throw at runtime if `s` is null).
            repeatable: true
            answers:
              - "val len: Int = s.length"
              - "val len: Int? = s?.length"
              - "val len: Int = s?.length ?: 0"
              - "val len: Int = if (s != null) s.length else 0"
              - "val len: Int = s ?: 0"
              - "val len: Int = s!!.length"
            correct:
              - "val len: Int? = s?.length"
              - "val len: Int = s?.length ?: 0"
              - "val len: Int = if (s != null) s.length else 0"
              - "val len: Int = s!!.length"
      - lessonId: "lesson-classes"
        name: "Classes"
        steps:
          - type: "text"
            stepId: "lesson-09_classes-#-classes-text"
            repeatable: false
            text: |-
              Take a look at the world around you and you will likely notice plenty of objects. It might be a book, an Ebook reader, a monitor, or a mug of coffee. We are surrounded by objects. This idea leads to the conclusion that we are living in a world of objects, therefore our programs should be constructed in the same way. This is the conceptual basis of the Object-Oriented Programming approach. Not everyone shares this worldview - some prefer to see the world as a place of possible actions, which is the conceptual basis of the Functional Programming approach - but whichever approach we prefer, classes and objects are important structures in Kotlin programming.
              
              A class is a template that is used to create an object with concrete characteristics. To create a class in Kotlin, we use the `class` keyword followed by the name. This is literally all that is needed to create the simplest class because a class body is optional. To create an object, which is an instance of a class, we use the default constructor function, which is the class name and round brackets. Unlike in other languages like C++ or Java, we do not use the `new` keyword in Kotlin.
              
              ```kotlin
              // Simplest class definition
              class A
              
              fun main() {
                  // Object creation from a class
                  val a: A = A()
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-09_classes-#-classes-q1"
            question: |-
              Given the following declaration:
              
              ```kotlin
              class A
              ```
              Which line correctly creates an instance of A in Kotlin?
            explanation: "In Kotlin you instantiate with the class name followed by parentheses\
        \ (default constructor) and do not use `new`. Java-style `A a = A()` is invalid,\
        \ and `A` without `()` refers to the class, not an instance."
            repeatable: true
            answers:
              - "val a: A = A()"
              - "val a = new A()"
              - "A a = A()"
              - "val a = A"
            correct: "val a: A = A()"
          - type: "question-multiple-answer"
            stepId: "lesson-09_classes-#-classes-q2"
            question: "Which statements about Kotlin classes and object creation are true?"
            explanation: "Kotlin allows `class A` with no body, and instances are created\
        \ with `A()` (no `new`). Empty braces are not required, and you need not declare\
        \ a constructor to instantiate an empty class."
            repeatable: false
            answers:
              - "A class body is optional."
              - "Kotlin requires the `new` keyword to instantiate classes."
              - "`ClassName()` calls the default constructor to create an object."
              - "An empty class must be declared as `class A {}` to be valid."
              - "You cannot create an instance without explicitly declaring a constructor."
            correct:
              - "A class body is optional."
              - "`ClassName()` calls the default constructor to create an object."
          - type: "text"
            stepId: "lesson-09_classes-member-functions-text"
            repeatable: false
            text: |-
              Inside classes, we can define functions. To do that, we first need to open braces in the class definition in order to specify the class body.
              
              ```kotlin
              class A {
                  // class body
              }
              ```
              
              There, we can specify functions. Functions defined this way have two important characteristics:
              * Functions need to be called on an instance of this class. This means that to call a method, an object needs to be created first.
              * Inside methods, we can use `this`, which is a reference to the instance of the class we called this function on.
              
              ```kotlin
              class A {
                  fun printMe() {
                      println(this)
                  }
              }
              
              fun main() {
                  val a = A()
                  println(a) // A@ADDRESS
                  a.printMe() // A@ADDRESS (the same address)
              }
              ```
              
              All the elements defined inside a class body are called **members**, so a function defined inside a class body is called a **member function**. Functions that are associated with classes are called **methods**, so all member functions are methods, but extension functions (which will be covered in a later chapter) are methods too.
              
              Conceptually speaking, methods represent what an object can do. For instance, a coffee machine should be able to produce coffee, which we might represent by the method `makeCoffee` in the `CoffeeMachine` class. This is how classes with methods help us model the world.
          - type: "question-single-answer"
            stepId: "lesson-09_classes-member-functions-q1"
            question: |-
              Given:
              
              ```kotlin
              class A {
                  fun printMe() = println(this)
              }
              ```
              Which call compiles?
            explanation: "Member functions must be called on an instance; inside, `this`\
        \ refers to that instance."
            repeatable: true
            answers:
              - "A.printMe()"
              - "A().printMe()"
              - "A.printMe(A())"
              - "printMe(A())"
            correct: "A().printMe()"
          - type: "question-single-answer"
            stepId: "lesson-09_classes-member-functions-q2"
            question: |-
              What does this program print?
              
              ```kotlin
              class A {
                  fun same(other: A) = this === other
              }
              
              fun main() {
                  val a1 = A()
                  val a2 = a1
                  val a3 = A()
                  println(a1.same(a2))
                  println(a1.same(a3))
              }
              ```
            explanation: "`this` is the receiver instance. `===` checks referential equality:\
        \ `a1` and `a2` are the same object; `a1` and `a3` are different."
            repeatable: false
            answers:
              - "true\\nfalse"
              - "false\\ntrue"
              - "true\\ntrue"
              - "false\\nfalse"
            correct: "true\\nfalse"
          - type: "text"
            stepId: "lesson-09_classes-properties-text"
            repeatable: false
            text: "Inside class bodies, we can also define variables. Variables defined\
        \ inside classes are called **fields**. There is an important idea known as\
        \ \"encapsulation\" which means that fields should never be used directly\
        \ from outside the class because if that happens, we lose control over their\
        \ state. Instead, fields should be used through accessors:\n* getter - the\
        \ function that is used to get the current value of this field,\n* setter\
        \ - the function that is used to set new values for this field.\n\nThis pattern\
        \ is highly influential; in Java projects, you can see plenty of getter and\
        \ setter functions, which are mainly used in classes that hold data. They\
        \ are needed to achieve encapsulation, but they are also disturbing boilerplate\
        \ code. So, language creators invented a more powerful concept called \"properties\"\
        . A **property** is a variable in a class that is automatically encapsulated\
        \ so that it uses a getter and a setter under the hood. In Kotlin, all variables\
        \ defined inside classes are properties, not fields.\n\nSome languages, like\
        \ JavaScript, have built-in support for properties, but Java does not. So,\
        \ in Kotlin/JVM, accessor functions are generated for each property: a getter\
        \ for `val`, and a getter and a setter for `var`.\n\n```kotlin\n// Kotlin\
        \ code\nclass User {\n    var name: String = \"\"\n}\n\nfun main(args: Array<String>)\
        \ {\n    val user = User()\n    user.name = \"Alex\" // setter call\n    println(user.name)\
        \ // getter call\n}\n```\n\n```javascript\n// equivalent JavaScript code\n\
        function User() {\n    this.name = '';\n}\n\nfunction main(args) {\n    var\
        \ user = new User();\n    user.name = 'Alex';\n    println(user.name);\n}\n\
        ```\n\n```java\n// equivalent Java code\npublic final class User {\n    @NotNull\n\
        \    private String name = \"\";\n\n    // getter\n    @NotNull\n    public\
        \ final String getName() {\n        return this.name;\n    }\n\n    // setter\n\
        \    public final void setName(@NotNull String name) {\n        this.name\
        \ = name;\n    }\n}\n\npublic final class PlaygroundKt {\n    public static\
        \ void main(String[] var0) {\n        User user = new User();\n        user.setName(\"\
        Alex\"); // setter call\n        System.out.println(user.getName()); // getter\
        \ call\n    }\n}\n```\n\nEach property in Kotlin has accessors, therefore\
        \ we should not define getters or setters using explicit functions. If you\
        \ want to change the default accessor, there is a special syntax for that.\n\
        \n```kotlin\nclass User {\n    private var name: String = \"\"\n\n    // DO\
        \ NOT DO THAT! DEFINE PROPERTY GETTER INSTEAD\n    fun getName() = name\n\n\
        \    // DO NOT DO THAT! DEFINE PROPERTY SETTER INSTEAD\n    fun setName(name:\
        \ String) {\n        this.name = name\n    }\n}\n```\n\nTo specify a custom\
        \ getter, we use the `get` keyword after the property definition. The rest\
        \ is equivalent to defining a function with no parameters. Inside this function,\
        \ we use the `field` keyword to reference the backing field. The default getter\
        \ returns the `field` value, but we can change this behavior so that this\
        \ value is modified in some way before it is returned. When we define a getter,\
        \ we can use single-expression syntax or a regular body and the `return` keyword.\n\
        \n```kotlin\nclass User {\n    var name: String = \"\"\n        get() = field.uppercase()\n\
        \    // or\n    // var name: String = \"\"\n    //     get() {\n    //   \
        \      return field.uppercase()\n    //     }\n}\n\nfun main() {\n    val\
        \ user = User()\n    user.name = \"norbert\"\n    println(user.name) // NORBERT\n\
        }\n```\n\nA getter must always have the same visibility and result type as\
        \ the property. Getters should not throw exceptions and should not perform\
        \ intensive calculations.\n\nBeware that all property usages are accessors'\
        \ usages. Inside accessors, you should use `field` instead of the property\
        \ name because, otherwise, you will likely end up with infinite recursion.\n\
        \n```kotlin\nclass User {\n    // DON'T DO THAT\n    var name: String = \"\
        \"\n        // Using property name inside getter\n        // leads to infinitive\
        \ recursion\n        get() = name.uppercase()\n}\n\nfun main() {\n    val\
        \ user = User()\n    user.name = \"norbert\"\n    println(user.name) // Error:\
        \ java.lang.StackOverflowError\n}\n```\n\nSetters can be specified similarly,\
        \ but we need to use the `set` keyword, and we need a single parameter that\
        \ represents the value that is set. The default setter is used to assign a\
        \ new value to the `field`, but we can modify this behavior, for instance,\
        \ to set a new value only if it satisfies some conditions.\n\n```kotlin\n\
        class User {\n    var name: String = \"\"\n        get() = field.uppercase()\n\
        \        set(value) {\n            if (value.isNotBlank()) {\n           \
        \     field = value\n            }\n        }\n}\n\nfun main() {\n    val\
        \ user = User()\n    user.name = \"norbert\"\n    user.name = \"\"\n    user.name\
        \ = \"  \"\n    println(user.name) // NORBERT\n}\n```\n\nSetters might have\
        \ more restrictive visibility than properties, which we will show in the next\
        \ chapter.\n\nIf a property's custom accessors do not use the `field` keyword,\
        \ then the backing field will not be generated. For example, we can define\
        \ a property to represent a full name that is calculated based on a name and\
        \ surname. This means that some properties might not need a field at all.\n\
        \n```kotlin\nclass User {\n    var name: String = \"\"\n    var surname: String\
        \ = \"\"\n    val fullName: String\n        get() = \"$name $surname\"\n}\n\
        \nfun main() {\n    val user = User()\n    user.name = \"Maja\"\n    user.surname\
        \ = \"Moskała\"\n    println(user.fullName) // Maja Moskała\n}\n```\n\nThe\
        \ `fullName` property needs only a getter because it is a read-only `val`\
        \ property. Whenever we ask for this property’s value, a full name will be\
        \ calculated based on the `name` and `surname`. Notice that this property\
        \ is calculated on demand, which is an advantage over using a regular property.\n\
        \n```kotlin\nclass User(\n    var name: String,\n    var surname: String,\n\
        ) {\n    val fullName1: String\n        get() = \"$name $surname\"\n    val\
        \ fullName2: String = \"$name $surname\"\n}\n\nfun main() {\n    val user\
        \ = User(\"Maja\", \"Markiewicz\")\n    println(user.fullName1) // Maja Markiewicz\n\
        \    println(user.fullName2) // Maja Markiewicz\n    user.surname = \"Moskał\
        a\"\n    println(user.fullName1) // Maja Moskała\n    println(user.fullName2)\
        \ // Maja Markiewicz\n}\n```\n\nThis difference is only visible when the values\
        \ our property is based on are mutable; therefore, when we define an immutable\
        \ object, either calculating the property value on the getter or during class\
        \ creation should both produce the same result. The difference is in performance:\
        \ we calculate constant property values during object creation, but getter\
        \ values are calculated on demand every time they are asked for.\n\n```kotlin\n\
        class Holder {\n    val v1: Int get() = calculate(\"v1\")\n    val v2: Int\
        \ = calculate(\"v2\")\n\n    private fun calculate(propertyName: String):\
        \ Int {\n        println(\"Calculating $propertyName\")\n        return 42\n\
        \    }\n}\n\nfun main() {\n    val h1 = Holder() // Calculating v2\n    //\
        \ h1 never used v1, so it was never calculated\n    // it calculated v2 even\
        \ though it was not used either\n    val h2 = Holder() // Calculating v2\n\
        \    println(h2.v1) // Calculating v1 and 42\n    println(h2.v1) // Calculating\
        \ v1 and 42\n    println(h2.v2) // 42\n    println(h2.v2) // 42\n    // h2\
        \ used v1 two times, and it was calculated two times, it \n    // calculated\
        \ v2 only once, even though it was used two times.\n}\n```\n\nAs another example,\
        \ let's imagine we need to keep the user's birthdate. Initially, we represented\
        \ it with `Date` from the Java Standard Library.\n\n```kotlin\nimport java.util.Date\n\
        \nclass User {\n    // ...\n    var birthdate: Date? = null\n}\n```\n\nTime\
        \ has passed, and `Date` is no longer a good way to represent this attribute.\
        \ Maybe we have problems with serialization; maybe we need to make our object\
        \ multiplatform; or maybe we need to represent time in another calendar not\
        \ supported by `Date`. So, we’ve decided to use a different type instead of\
        \ `Date`. Let's say that we’ve decided to use a `Long` property to keep milliseconds,\
        \ but we cannot get rid of the previous property because it is used by many\
        \ other parts of our code. To have our cake and eat it, we can transform our\
        \ `birthdate` property to fully depend on the new representation. This way,\
        \ we have changed how the birthdate is represented without changing the previous\
        \ usage.\n\n```kotlin\nclass User {\n    // ...\n    var birthdateMillis:\
        \ Long? = null\n\n    var birthdate: Date?\n        get() {\n            val\
        \ millis = birthdateMillis\n            return if (millis == null) null else\
        \ Date(millis)\n        }\n        set(value) {\n            birthdateMillis\
        \ = value?.time\n        }\n}\n```\n\n> In the above getter, I use `let` and\
        \ a constructor reference. Both these Kotlin features are explained in the\
        \ book **Functional Kotlin**.\n\nSuch a `birthdate` property can also be defined\
        \ as an extension function, which will be presented in the chapter *Extensions*."
          - type: "question-single-answer"
            stepId: "lesson-09_classes-properties-q1"
            question: "You need a `User.name` property that reads as uppercase and ignores\
        \ blank assignments. Which implementation is correct?"
            explanation: "Use accessors with the backing field `field`. Referring to the\
        \ property inside its own accessor causes infinite recursion; defining separate\
        \ `getName`/`setName` breaks Kotlin property idioms; `val` cannot have a setter."
            repeatable: false
            answers:
              - "var name: String = \"\" get() = field.uppercase() set(value) { if (value.isNotBlank())\
        \ field = value }"
              - "var name: String = \"\" get() = name.uppercase() set(v) { if (v.isNotBlank())\
        \ name = v }"
              - "private var _name = \"\"; fun getName() = _name.uppercase(); fun setName(s:\
        \ String) { if (s.isNotBlank()) _name = s }"
              - "val name: String get() = field.uppercase() set(value) { if (value.isNotBlank())\
        \ field = value }"
            correct: "var name: String = \"\" get() = field.uppercase() set(value) { if\
        \ (value.isNotBlank()) field = value }"
          - type: "question-multiple-answer"
            stepId: "lesson-09_classes-properties-q2"
            question: "Which statements about Kotlin properties and accessors are correct\
        \ on the JVM?"
            explanation: "Kotlin/JVM generates accessor methods; all property access goes\
        \ through accessors; a getter’s visibility and return type must match the\
        \ property; and no backing field is generated if custom accessors don’t reference\
        \ `field`. Getters do not cache results by default."
            repeatable: true
            answers:
              - "Kotlin/JVM generates a getter for `val` and a getter+setter for `var` properties."
              - "Accessing a property always calls its accessor, even within the class."
              - "If a property's custom accessors do not reference `field`, no backing field\
        \ is generated."
              - "A getter may have different visibility from the property."
              - "A getter must have the same return type as the property."
              - "Getters cache their result by default, so heavy computations run once per\
        \ instance."
            correct:
              - "Kotlin/JVM generates a getter for `val` and a getter+setter for `var` properties."
              - "Accessing a property always calls its accessor, even within the class."
              - "If a property's custom accessors do not reference `field`, no backing field\
        \ is generated."
              - "A getter must have the same return type as the property."
          - type: "text"
            stepId: "lesson-09_classes-constructors-text"
            repeatable: false
            text: |-
              When we create an object, we often want to initialize it with specific values. This is what we use constructors for. As we've seen already, when no constructors are specified, an empty default constructor is generated with no parameters.
              
              ```kotlin
              class A
              
              val a = A()
              ```
              
              To specify our custom constructor, the classic way is to use the `constructor` keyword inside the class body, and then we define its parameters and body.
              
              ```kotlin
              class User {
                  var name: String = ""
                  var surname: String = ""
              
                  constructor(name: String, surname: String) {
                      this.name = name
                      this.surname = surname
                  }
              }
              
              fun main() {
                  val user = User("Johnny", "Depp")
                  println(user.name) // Johnny
                  println(user.surname) // Depp
              }
              ```
              
              Constructors are typically used to set initial values of our properties. To simplify this, Kotlin introduced a special kind of constructor called the **primary constructor**. It is defined just after the class name, and its parameters can be used during the initialization of properties.
              
              ```kotlin
              class User constructor(name: String, surname: String) {
                  var name: String = name
                  var surname: String = surname
              }
              
              fun main() {
                  val user = User("Johnny", "Depp")
                  println(user.name) // Johnny
                  println(user.surname) // Depp
              }
              ```
              
              When we specify a primary constructor, use of the `constructor` keyword is optional, so we can just skip it.
              
              ```kotlin
              class User(name: String, surname: String) {
                  var name: String = name
                  var surname: String = surname
              }
              
              fun main() {
                  val user = User("Johnny", "Depp")
                  println(user.name) // Johnny
                  println(user.surname) // Depp
              }
              ```
              
              There can be only one primary constructor. We can define another constructor, called **secondary constructor**, but it needs to call the primary constructor using the `this` keyword.
              
              ```kotlin
              class User(name: String, surname: String) {
                  var name: String = name
                  var surname: String = surname
              
                  // Secondary constructor
                  constructor(user: User) : this(user.name, user.surname) {
                      // optional body
                  }
              }
              
              fun main() {
                  val user = User("Johnny", "Depp")
                  println(user.name) // Johnny
                  println(user.surname) // Depp
              
                  val user2 = User(user)
                  println(user2.name) // Johnny
                  println(user2.surname) // Depp
              }
              ```
              
              The primary constructor is typically used to specify initial values for our properties. These properties often have the same names as other parameters, so Kotlin introduced better support for this: we can define properties inside the primary constructor. Such properties define a class property and a constructor parameter, both of which have the same name.
              
              ```kotlin
              class User(
                  var name: String,
                  var surname: String,
              ) {
                  // optional body
              }
              
              fun main() {
                  val user = User("Johnny", "Depp")
                  println(user.name) // Johnny
                  println(user.surname) // Depp
              }
              ```
              
              This is how the vast majority of Kotlin classes are defined: using a primary constructor with properties. We rarely use other kinds of constructors.
              
              We often define primary constructors with default values. Here, we create an instance of `User` without providing the `surname` argument, so the default value we specified will be used during `User` creation.
              
              ```kotlin
              class User(
                  var name: String = "",
                  var surname: String = "Anonim",
              )
              
              fun main() {
                  val user = User("Johnny")
                  println(user.name) // Johnny
                  println(user.surname) // Anonim
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-09_classes-constructors-q1"
            question: "Which declarations result in a class that exposes public readable/writable\
        \ properties name and surname?"
            explanation: |-
              - Only properties declared with var are writable.
              - Parameters in the primary constructor without val/var are not properties.
              - Defining properties in the body and assigning from constructor parameters also creates writable properties.
            repeatable: false
            answers:
              - "class User(name: String, surname: String)"
              - "class User(var name: String, var surname: String)"
              - "class User(name: String, surname: String) { var name: String = name; var\
        \ surname: String = surname }"
              - "class User(val name: String, val surname: String)"
              - "class User { var name: String = \"\"; var surname: String = \"\"; constructor(name:\
        \ String, surname: String) { this.name = name; this.surname = surname } }"
            correct:
              - "class User(var name: String, var surname: String)"
              - "class User(name: String, surname: String) { var name: String = name; var\
        \ surname: String = surname }"
              - "class User { var name: String = \"\"; var surname: String = \"\"; constructor(name:\
        \ String, surname: String) { this.name = name; this.surname = surname } }"
          - type: "question-single-answer"
            stepId: "lesson-09_classes-constructors-q2"
            question: "In Kotlin, if a class declares a primary constructor, what is required\
        \ of any secondary constructor?"
            explanation: "Secondary constructors must delegate to the primary constructor\
        \ using this(...) before the body, ensuring a single initialization path."
            repeatable: true
            answers:
              - "It must delegate to the primary constructor via this(...) before its body."
              - "It must call the superclass constructor directly."
              - "It cannot be declared."
              - "It may skip delegating if it initializes all properties."
            correct: "It must delegate to the primary constructor via this(...) before its\
        \ body."
          - type: "text"
            stepId: "lesson-09_classes-classes-representing-data-in-kotlin-and-java-text"
            repeatable: false
            text: |-
              When comparing classes defined in Kotlin and Java, we can see how much boilerplate code Kotlin has eliminated. In Java, to represent a simple user, with a name, surname, and age, the typical implementation looks as follows:
              
              ```java
              public final class User {
                  @NotNull
                  private final String name;
                  @NotNull
                  private final String surname;
                  private final int age;
              
                  public User(
                      @NotNull String name,
                      @NotNull String surname,
                      int age
                  ) {
                      this.name = name;
                      this.surname = surname;
                      this.age = age;
                  }
              
                  @NotNull
                  public String getName() {
                      return name;
                  }
              
                  @NotNull
                  public String getSurname() {
                      return surname;
                  }
              
                  public int getAge() {
                      return age;
                  }
              }
              ```
              
              In Kotlin, we represent the same class in the following way:
              
              ```kotlin
              class User(
                  val name: String,
                  val surname: String,
                  val age: Int?,
              )
              ```
              
              The result of the compilation is practically the same. Getters and constructors are there. If you don’t believe it, check it yourself (as presented in the *What is under the hood on JVM?* section in the *Your first program in Kotlin* chapter). Kotlin is a concise but powerful language.
          - type: "question-multiple-answer"
            stepId: "lesson-09_classes-classes-representing-data-in-kotlin-and-java-q1"
            question: |-
              Given the Kotlin class:
              
              ```kotlin
              class User(
                  val name: String,
                  val surname: String,
                  val age: Int?
              )
              ```
              Which statements about the generated JVM class are true?
            explanation: "val properties generate getters but no setters; the primary constructor\
        \ compiles to a public constructor with the same parameters; only parameters\
        \ marked with val/var become properties."
            repeatable: true
            answers:
              - "Getters are generated for each val property."
              - "Setters are generated for each val property."
              - "A public constructor with three parameters is generated."
              - "equals/hashCode are generated the same way as for a data class."
              - "If val/var is removed from a parameter, it stops being a property with a\
        \ getter."
            correct:
              - "Getters are generated for each val property."
              - "A public constructor with three parameters is generated."
              - "If val/var is removed from a parameter, it stops being a property with a\
        \ getter."
          - type: "question-single-answer"
            stepId: "lesson-09_classes-classes-representing-data-in-kotlin-and-java-q2"
            question: |-
              Which Kotlin declaration best matches this Java class (final fields with getters and a public constructor):
              
              ```java
              public final class User {
                private final String name;
                private final String surname;
                private final int age;
                public User(String name, String surname, int age) { ... }
                public String getName() { return name; }
                public String getSurname() { return surname; }
                public int getAge() { return age; }
              }
              ```
            explanation: "Option A uses val (no setters), non-null types (including Int),\
        \ and a regular class (not data), which mirrors the Java class’ constructor\
        \ and getters without adding extra methods."
            repeatable: true
            answers:
              - "class User(val name: String, val surname: String, val age: Int)"
              - "data class User(val name: String, val surname: String, val age: Int)"
              - "class User(var name: String, var surname: String, var age: Int?)"
              - "class User(name: String, surname: String, age: Int)"
            correct: "class User(val name: String, val surname: String, val age: Int)"
          - type: "text"
            stepId: "lesson-09_classes-inner-classes-text"
            repeatable: false
            text: |-
              In Kotlin, we can define classes inside classes. They are static by default, which means that they do not have access to outer classes, therefore they can be created without a reference to an outer class.
              
              ```kotlin
              class Puppy(val name: String) {
              
                  class InnerPuppy {
                      fun think() {
                          // we have no access to name here
                          println("Inner puppy is thinking")
                      }
                  }
              }
              
              fun main() {
                  val innerPuppy = Puppy.InnerPuppy()
                  // We create InnerPuppy on class, not object
                  innerPuppy.think() // Inner puppy is thinking
              }
              ```
              
              If you want your inner class to have a reference to its outer class, you need to make it inner using the `inner` modifier. However, creating objects from such classes requires an instance of the outer class.
              
              ```kotlin
              class Puppy(val name: String) {
              
                  inner class InnerPuppy {
                      fun think() {
                          println("Inner $name is thinking")
                      }
                  }
              }
              
              fun main() {
                  val puppy = Puppy("Cookie")
                  val innerPuppy = puppy.InnerPuppy() // We need puppy
                  innerPuppy.think() // Inner Cookie is thinking
              }
              ```
              
              Examples of inner classes in the standard library are:
              * private implementations of iterators;
              * classes, where there is a close association between the outer class and the inner class, and the inner class is used to not define another name in the library namespace.
              
              ```kotlin
              // A class from Kotlin stdlib
              class FileTreeWalk(
                  ...
              ) : Sequence<File> {
              
                  /** Returns an iterator walking through files. */
                  override fun iterator(): Iterator<File> =
                      FileTreeWalkIterator()
              
                  private inner class FileTreeWalkIterator
                      : AbstractIterator<File>() {
                      ...
                  }
              
                  ...
              }
              ```
          - type: "text"
            stepId: "lesson-09_classes-summary-text"
            repeatable: false
            text: "As you can see, in Kotlin we can define classes using really concise\
        \ syntax, and the result is very readable. The primary constructor is an amazing\
        \ invention, as is the fact that Kotlin uses properties instead of fields.\
        \ You have also learned about inner classes. This is all great, but we haven't\
        \ yet touched on inheritance, which is so important for developers who like\
        \ Object-Oriented style. We will discuss this along with interfaces and abstract\
        \ classes in the next chapter."
          - type: "question-single-answer"
            stepId: "lesson-09_classes-summary-q1"
            question: "Which declaration correctly uses the primary constructor to create\
        \ an immutable id: Int and a mutable nickname: String property?"
            explanation: "In Kotlin, properties can be declared directly in the primary\
        \ constructor using val/var. Parameters without val/var are not properties,\
        \ and secondary constructors cannot declare properties."
            repeatable: true
            answers:
              - "class User(id: Int, var nickname: String)"
              - "class User(val id: Int, var nickname: String)"
              - "class User(private val id: Int) { var nickname: String }"
              - "class User(val id: Int) { constructor(id: Int, var nickname: String) }"
            correct: "class User(val id: Int, var nickname: String)"
          - type: "question-single-answer"
            stepId: "lesson-09_classes-summary-q2"
            question: |-
              Given the code:
              
              ```kotlin
              class Outer(val x: Int) {
                  class Nested {
                      fun value() = x
                  }
              }
              ```
              What happens and how can you access x from Nested?
            explanation: "Nested classes in Kotlin are static by default and do not hold\
        \ a reference to the outer class. Mark the class with `inner` to capture the\
        \ outer instance and then access `x` (optionally via `this@Outer.x`)."
            repeatable: true
            answers:
              - "Compilation error: Nested cannot access x; mark Nested as `inner` to access\
        \ the outer instance."
              - "Compiles and value() returns the outer x."
              - "Compiles only if x is annotated with @JvmField."
              - "Compiles if Nested is declared as a data class."
            correct: "Compilation error: Nested cannot access x; mark Nested as `inner`\
        \ to access the outer instance."
      - lessonId: "lesson-objects"
        name: "Objects"
        steps:
          - type: "text"
            stepId: "lesson-12_objects-#-objects-text"
            repeatable: false
            text: |-
              What is an object? This is the question I often start this section with in my workshops, and I generally get an instant response, "An instance of a class". That is right, but how do we create objects? One way is easy: using constructors.
              
              ```kotlin
              class A
              
              // Using a constructor to create an object
              val a = A()
              ```
              
              However, this is not the only way. In Kotlin, we can also create objects using **object expression** and **object declaration**. Let's discuss these two options.
          - type: "question-multiple-answer"
            stepId: "lesson-12_objects-#-objects-q1"
            question: "Besides calling a constructor like `A()`, which Kotlin constructs\
        \ can you use to create objects?"
            explanation: "Kotlin creates objects via constructor calls, object expressions\
        \ (anonymous objects), and object declarations (singletons). Interface, typealias,\
        \ and class declarations define types but do not instantiate objects."
            repeatable: true
            answers:
              - "object expression (e.g., `object : Interface { ... }`)"
              - "object declaration (e.g., `object Foo { ... }`)"
              - "interface declaration (`interface X`)"
              - "typealias (`typealias X = Y`)"
              - "class declaration (`class B`)"
            correct:
              - "object expression (e.g., `object : Interface { ... }`)"
              - "object declaration (e.g., `object Foo { ... }`)"
          - type: "text"
            stepId: "lesson-12_objects-object-expressions-text"
            repeatable: false
            text: |-
              To create an empty object using an expression, we use the `object` keyword and braces. This syntax for creating objects is known as *object expression*.
              
              ```kotlin
              val instance = object {}
              ```
              
              An empty object extends no classes (except for `Any`, which is extended by all objects in Kotlin), implements no interfaces, and has nothing inside its body. Nevertheless, it is useful. Its power lies in its uniqueness: such an object equals nothing else but itself. Therefore, it is perfectly suited to be used as some kind of token or synchronization lock.
              
              ```kotlin
              class Box {
                  var value: Any? = NOT_SET
              
                  fun initialized() = value != NOT_SET
              
                  companion object {
                      private val NOT_SET = object {}
                  }
              }
              
              private val LOCK = object {}
              fun synchronizedOperation() = synchronized(LOCK) {
                  // ...
              }
              ```
              
              An empty object can also be created with the constructor of `Any`, so `Any()` is an alternative to `object {}`.
              
              ```kotlin
              private val NOT_SET = Any()
              ```
              
              However, objects created with an object expression do not need to be empty. They can have bodies, extend classes, implement interfaces, etc. The syntax is the same as for classes, but object declarations use the `object` keyword instead of `class` and should not define the name or constructor.
              
              ```kotlin
              data class User(val name: String)
              
              interface UserProducer {
                  fun produce(): User
              }
              
              fun printUser(producer: UserProducer) {
                  println(producer.produce())
              }
              
              fun main() {
                  val user = User("Jake")
                  val producer = object : UserProducer {
                      override fun produce(): User = user
                  }
                  printUser(producer) // User(name=Jake)
              }
              ```
              
              In a local scope, object expressions define an anonymous type that won’t work outside the class where it is defined. This means the non-inherited members of object expressions are accessible only when an anonymous object is declared in a local or class-private scope; otherwise, the object is just an opaque `Any` type, or the type of the class or interface it inherits from. This makes non-inherited members of object expressions hard to use in real-life projects.
              
              ```kotlin
              class Robot {
                  // Possible, but rarely useful
                  // prefer regular member properties instead
                  private val point = object {
                      var x = 0
                      var y = 0
                  }
              
                  fun moveUp() {
                      point.y += 10
                  }
              
                  fun show() {
                      println("(${point.x}, ${point.y})")
                  }
              }
              
              fun main() {
                  val robot = Robot()
                  robot.show() // (0, 0)
                  robot.moveUp()
                  robot.show() // (0, 10)
              
                  val point = object {
                      var x = 0
                      var y = 0
                  }
                  println(point.x) // 0
                  point.y = 10
                  println(point.y) // 10
              }
              ```
              
              In practice, object expressions are used as an alternative to Java anonymous classes, i.e., when we need to create a watcher or a listener with multiple handler methods.
              
              ```kotlin
              taskNameView.addTextChangedListener(object : TextWatcher {
                  override fun afterTextChanged(
                      editable: Editable?
                  ) {
                      //...
                  }
              
                  override fun beforeTextChanged(
                      text: CharSequence?,
                      start: Int,
                      count: Int,
                      after: Int
                  ) {
                      //...
                  }
              
                  override fun onTextChanged(
                      text: CharSequence?,
                      start: Int,
                      before: Int,
                      count: Int
                  ) {
                      //...
                  }
              })
              ```
              
              Note that "object expression" is a better name than "anonymous class" since this is an expression that produces an object.
          - type: "question-multiple-answer"
            stepId: "lesson-12_objects-object-expressions-q1"
            question: |-
              Given the code below, which println calls compile?
              
              ```kotlin
              class A {
                  val pub = object { val x = 1 }
                  private val priv = object { val y = 2 }
              
                  fun inside() {
                      println(pub.x)   // [1]
                      println(priv.y)  // [2]
                  }
              }
              
              fun outside(a: A) {
                  println(a.pub)      // [3]
                  println(a.priv)     // [4]
              }
              ```
              Choose all that compile.
            explanation: "A public property initialized with an anonymous object is treated\
        \ as Any, so pub.x is not accessible anywhere. A private property preserves\
        \ the anonymous object type inside the class, so priv.y compiles. a.pub is\
        \ public (type Any) and printable; a.priv is private."
            repeatable: true
            answers:
              - "[1] println(pub.x)"
              - "[2] println(priv.y)"
              - "[3] println(a.pub)"
              - "[4] println(a.priv)"
            correct:
              - "[2] println(priv.y)"
              - "[3] println(a.pub)"
          - type: "question-multiple-answer"
            stepId: "lesson-12_objects-object-expressions-q2"
            question: "Which declarations are suitable as a unique lock token for `synchronized(LOCK)\
        \ { ... }`? Choose all that apply."
            explanation: "`object {}` and `Any()` create fresh, unique instances ideal as\
        \ tokens. A string constant can be shared (interned), `Any` is a type, not\
        \ an instance, and `Unit` is a global singleton—none of these are suitable\
        \ unique locks."
            repeatable: true
            answers:
              - "private val LOCK = object {}"
              - "private val LOCK = Any()"
              - "private const val LOCK = \"LOCK\""
              - "private val LOCK = Any"
              - "private val LOCK = Unit"
            correct:
              - "private val LOCK = object {}"
              - "private val LOCK = Any()"
          - type: "text"
            stepId: "lesson-12_objects-object-declaration-text"
            repeatable: false
            text: |-
              If we take an object expression and give it a name, we get an **object declaration**. This structure also creates a single object, but this object is not anonymous: it has a name that can be used to reference it.
              
              ```kotlin
              object Point {
                  var x = 0
                  var y = 0
              }
              
              fun main() {
                  println(Point.x) // 0
                  Point.y = 10
                  println(Point.y) // 10
              
                  val p = Point
                  p.x = 20
                  println(Point.x) // 20
                  println(Point.y) // 10
              }
              ```
              
              Object declaration is an implementation of a singleton pattern, so this declaration creates a class with a single instance. Whenever we want to use this class, we need to operate on this single instance. Object declarations support all the features that classes support; for example, they can extend classes or implement interfaces.
              
              ```kotlin
              data class User(val name: String)
              
              interface UserProducer {
                  fun produce(): User
              }
              
              object FakeUserProducer : UserProducer {
                  override fun produce(): User = User("fake")
              }
              
              fun setUserProducer(producer: UserProducer) {
                  println(producer.produce())
              }
              
              fun main() {
                  setUserProducer(FakeUserProducer) // User(name=fake)
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-12_objects-object-declaration-q1"
            question: |
              Given the following code, what does it print?
              
              ```kotlin
              object Config { var mode = "A" }
              
              fun swap() {
                  val c = Config
                  c.mode = "B"
              }
              
              fun main() {
                  println(Config.mode)
                  val ref = Config
                  ref.mode = "C"
                  swap()
                  println(Config.mode)
              }
              ```
            explanation: "Object declarations are singletons. `ref` and `c` both refer to\
        \ the same `Config` instance. Initial print is \"A\"; after `ref.mode = \"\
        C\"`, `swap()` sets `mode` to \"B\", so final print is \"B\"."
            repeatable: false
            answers:
              - "A then B"
              - "A then C"
              - "C then B"
              - "B then B"
            correct: "A then B"
          - type: "question-multiple-answer"
            stepId: "lesson-12_objects-object-declaration-q2"
            question: |
              Which of the following lines compile, given:
              
              ```kotlin
              interface UserProducer { fun produce(): String }
              object FakeUserProducer : UserProducer { override fun produce() = "fake" }
              fun setUserProducer(p: UserProducer) {}
              object Point { var x = 0 }
              ```
            explanation: "Object declarations are singletons used by name, not constructed\
        \ with `()`. They can be passed where their supertypes are expected."
            repeatable: true
            answers:
              - "val p = Point"
              - "val p = Point()"
              - "setUserProducer(FakeUserProducer)"
              - "setUserProducer(FakeUserProducer())"
              - "val ref: UserProducer = FakeUserProducer"
            correct:
              - "val p = Point"
              - "setUserProducer(FakeUserProducer)"
              - "val ref: UserProducer = FakeUserProducer"
          - type: "text"
            stepId: "lesson-12_objects-companion-objects-text"
            repeatable: false
            text: "When I reflect on the times when I worked as a Java developer, I remember\
        \ discussions about what features should be introduced into that language.\
        \ A common idea I often heard was introducing inheritance for static elements.\
        \ In the end, inheritance is very important in Java, so why can't we use it\
        \ for static elements? Kotlin has addressed this problem with companion objects;\
        \ however, to make that possible, it first needed to eliminate actual static\
        \ elements, i.e., elements that are called on classes, not on objects.\n\n\
        ```\n// Java\nclass User {\n   // Static element definition\n   public static\
        \ User empty() {\n       return new User();\n   }\n}\n\n// Static element\
        \ usage\nUser user = User.empty()\n```\n\nYes, we don’t have static elements\
        \ in Kotlin, but we don’t need them because we use object declarations instead.\
        \ If we define an object declaration in a class, it is static by default (just\
        \ like classes defined inside classes), so we can directly call its elements.\n\
        \n```kotlin\n// Kotlin\nclass User {\n    object Producer {\n        fun empty()\
        \ = User()\n    }\n}\n\n// Usage\nval user: User = User.Producer.empty()\n\
        ```\n\nThis is not as convenient as static elements, but we can improve it.\
        \ If we use the `companion` keyword before an object declaration defined inside\
        \ a class, then we can call these object methods implicitly \"on the class\"\
        .\n\n```kotlin\nclass User {\n    companion object Producer {\n        fun\
        \ empty() = User()\n    }\n}\n\n// Usage\nval user: User = User.empty()\n\
        // or\nval user: User = User.Producer.empty()\n```\n\nObjects with the `companion`\
        \ modifier, also known as companion objects, do not need an explicit name.\
        \ Their default name is `Companion`.\n\n```kotlin\nclass User {\n    companion\
        \ object {\n        fun empty() = User()\n    }\n}\n\n// Usage\nval user:\
        \ User = User.empty()\n// or\nval user: User = User.Companion.empty()\n```\n\
        \nThis is how we achieved a syntax that is nearly as convenient as static\
        \ elements. The only inconvenience is that we must locate all the “static”\
        \ elements inside a single object (there can be only one companion object\
        \ in a class). This is a limitation, but we have something in return: companion\
        \ objects are objects, so they can extend classes or implement interfaces.\n\
        \nLet me show you an example. Let’s say that you represent money in different\
        \ currencies using different classes like `USD`, `EUR`, or `PLN`. For convenience,\
        \ each of these defines `from` builder functions, which simplify object creation.\n\
        \n```kotlin\nimport java.math.BigDecimal\nimport java.math.MathContext\nimport\
        \ java.math.RoundingMode.HALF_EVEN\n\nabstract class Money(\n    val amount:\
        \ BigDecimal,\n    val currency: String\n)\n\nclass USD(amount: BigDecimal)\
        \ : Money(amount, \"USD\") {\n    companion object {\n        private val\
        \ MATH = MathContext(2, HALF_EVEN)\n        fun from(amount: Int): USD =\n\
        \            USD(amount.toBigDecimal(MATH))\n        fun from(amount: Double):\
        \ USD =\n            USD(amount.toBigDecimal(MATH))\n        fun from(amount:\
        \ String): USD =\n            USD(amount.toBigDecimal(MATH))\n    }\n}\n\n\
        class EUR(amount: BigDecimal) : Money(amount, \"EUR\") {\n    companion object\
        \ {\n        private val MATH = MathContext(2, HALF_EVEN)\n        fun from(amount:\
        \ Int): EUR =\n            EUR(amount.toBigDecimal(MATH))\n        fun from(amount:\
        \ Double): EUR =\n            EUR(amount.toBigDecimal(MATH))\n        fun\
        \ from(amount: String): EUR =\n            EUR(amount.toBigDecimal(MATH))\n\
        \    }\n}\n\nclass PLN(amount: BigDecimal) : Money(amount, \"PLN\") {\n  \
        \  companion object {\n        private val MATH = MathContext(2, HALF_EVEN)\n\
        \        fun from(amount: Int): PLN =\n            PLN(amount.toBigDecimal(MATH))\n\
        \        fun from(amount: Double): PLN =\n            PLN(amount.toBigDecimal(MATH))\n\
        \        fun from(amount: String): PLN =\n            PLN(amount.toBigDecimal(MATH))\n\
        \    }\n}\n\nfun main() {\n    val eur: EUR = EUR.from(\"12.00\")\n    val\
        \ pln: PLN = PLN.from(20)\n    val usd: USD = USD.from(32.5)\n}\n```\n\nThe\
        \ repetitive functions for creating objects from different types can be extracted\
        \ into an abstract `MoneyMaker` class, which can be extended by companion\
        \ objects of different currencies. This class can offer a range of methods\
        \ to create a currency. This way, we use companion object inheritance to extract\
        \ a pattern that is common to all companion objects of classes that represent\
        \ money.\n\n```kotlin\nimport java.math.BigDecimal\nimport java.math.MathContext\n\
        import java.math.RoundingMode.HALF_EVEN\n\nabstract class Money(\n    val\
        \ amount: BigDecimal,\n    val currency: String\n)\n\nabstract class MoneyMaker<M\
        \ : Money> {\n    private val MATH = MathContext(2, HALF_EVEN)\n    abstract\
        \ fun from(amount: BigDecimal): M\n    fun from(amount: Int): M = from(amount.toBigDecimal(MATH))\n\
        \    fun from(amount: Double): M = from(amount.toBigDecimal(MATH))\n    fun\
        \ from(amount: String): M = from(amount.toBigDecimal(MATH))\n}\n\nclass USD(amount:\
        \ BigDecimal) : Money(amount, \"USD\") {\n    companion object : MoneyMaker<USD>()\
        \ {\n        override fun from(amount: BigDecimal): USD = USD(amount)\n  \
        \  }\n}\n\nclass EUR(amount: BigDecimal) : Money(amount, \"EUR\") {\n    companion\
        \ object : MoneyMaker<EUR>() {\n        override fun from(amount: BigDecimal):\
        \ EUR = EUR(amount)\n    }\n}\n\nclass PLN(amount: BigDecimal) : Money(amount,\
        \ \"PLN\") {\n    companion object : MoneyMaker<PLN>() {\n        override\
        \ fun from(amount: BigDecimal): PLN = PLN(amount)\n    }\n}\n\nfun main()\
        \ {\n    val eur: EUR = EUR.from(\"12.00\")\n    val pln: PLN = PLN.from(20)\n\
        \    val usd: USD = USD.from(32.5)\n}\n```\n\nOur community is still learning\
        \ how to use these capabilities, but you can already find plenty of examples\
        \ in projects and libraries. Here are a few interesting examples:\n\n```kotlin\n\
        // Using companion object inheritance for logging\n// from the Kotlin Logging\
        \ framework\nclass FooWithLogging {\n    fun bar(item: Item) {\n        logger.info\
        \ { \"Item $item\" }\n        // Logger comes from the companion object\n\
        \    }\n\n    companion object : KLogging()\n    // companion inherits logger\
        \ property\n}\n```\n\n```kotlin\n// Android-specific example of using an abstract\
        \ factory \n// for companion object\nclass MainActivity : Activity() {\n \
        \   //...\n\n    // Using companion object as a factory\n    companion object\
        \ : ActivityFactory() {\n        override fun getIntent(context: Context):\
        \ Intent =\n            Intent(context, MainActivity::class.java)\n    }\n\
        }\n\nabstract class ActivityFactory {\n    abstract fun getIntent(context:\
        \ Context): Intent\n\n    fun start(context: Context) {\n        val intent\
        \ = getIntent(context)\n        context.startActivity(intent)\n    }\n\n \
        \   fun startForResult(activity: Activity, requestCode: Int) {\n        val\
        \ intent = getIntent(activity)\n        activity.startActivityForResult(intent,\
        \ requestCode)\n    }\n}\n```\n\n```kotlin\n// Usage of all the members of\
        \ the companion ActivityFactory\nval intent = MainActivity.getIntent(context)\n\
        MainActivity.start(context)\nMainActivity.startForResult(activity, requestCode)\n\
        \n// In contexts on Kotlin Coroutines, companion objects are\n// used as keys\
        \ to identify contexts\ndata class CoroutineName(\n    val name: String\n\
        ) : AbstractCoroutineContextElement(CoroutineName) {\n\n    // Companion object\
        \ is a key\n    companion object Key : CoroutineContext.Key<CoroutineName>\n\
        \n    override fun toString(): String = \"CoroutineName($name)\"\n}\n\n//\
        \ Finding a context by key\nval name1 = context[CoroutineName] // Yes, this\
        \ is a companion\n\n// You can also refer to companion objects by its name\n\
        val name2 = context[CoroutineName.Key]\n```"
          - type: "question-multiple-answer"
            stepId: "lesson-12_objects-companion-objects-q1"
            question: |-
              Given the code:
              
              ```kotlin
              class User {
                  object Producer {
                      fun empty() = User()
                  }
                  companion object {
                      fun of() = User()
                  }
              }
              ```
              Which calls compile?
            explanation: |-
              - `User.Producer.empty()` works: nested object members are accessed via the object name.
              - `User.of()` and `User.Companion.of()` work: companion members are callable on the class and via `Companion`.
              - `empty()` is not in the companion, so `User.empty()` and `User.Companion.empty()` do not compile.
            repeatable: true
            answers:
              - "User.Producer.empty()"
              - "User.empty()"
              - "User.of()"
              - "User.Companion.of()"
              - "User.Companion.empty()"
            correct:
              - "User.Producer.empty()"
              - "User.of()"
              - "User.Companion.of()"
          - type: "question-multiple-answer"
            stepId: "lesson-12_objects-companion-objects-q2"
            question: |-
              You have a coroutine context key defined via a companion object:
              
              ```kotlin
              data class CoroutineName(val name: String)
                : AbstractCoroutineContextElement(CoroutineName) {
                  companion object Key : CoroutineContext.Key<CoroutineName>
              }
              ```
              Which expressions correctly retrieve the element from a `CoroutineContext` named `context`?
            explanation: "The companion object itself is the key. It can be referenced by\
        \ the class name (`CoroutineName`) or by the companion's explicit name (`CoroutineName.Key`).\
        \ Constructor calls and KClass references are not valid keys."
            repeatable: true
            answers:
              - "context[CoroutineName]"
              - "context[CoroutineName.Key]"
              - "context[CoroutineName(\"main\")]"
              - "context[CoroutineName::class]"
              - "context[CoroutineName.Key::class]"
            correct:
              - "context[CoroutineName]"
              - "context[CoroutineName.Key]"
          - type: "text"
            stepId: "lesson-12_objects-data-object-declarations-text"
            repeatable: false
            text: |-
              Since Kotlin 1.8, you can use the `data` modifier for object declarations. It generates the `toString` method for the object; this method includes the object name as a string.
              
              ```kotlin
              data object ABC
              
              fun main() {
                  println(ABC) // ABC
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-12_objects-data-object-declarations-q1"
            question: "In Kotlin 1.8+, what does the `data` modifier on an `object` declaration\
        \ generate automatically?"
            explanation: "`data object` only auto-generates `toString()` that returns the\
        \ object name (e.g., \"ABC\"). It does not add `equals()`, `hashCode()`, `copy()`,\
        \ or `componentN()` like a data class."
            repeatable: true
            answers:
              - "Only a toString() that returns the object name (e.g., \"ABC\")"
              - "toString(), equals(), and hashCode() based on properties"
              - "A copy() function and componentN() functions like a data class"
              - "Nothing; behavior is identical to a plain object"
            correct: "Only a toString() that returns the object name (e.g., \"ABC\")"
          - type: "text"
            stepId: "lesson-12_objects-constant-values-text"
            repeatable: false
            text: |-
              It’s common practice to generally extract constant values as properties of companion objects and name them using UPPER_SNAKE_CASE. This way, we name those values and simplify their changes in the future. We name constant values in a characteristic way to make it clear that they represent a constant.
              
              ```kotlin
              class Product(
                  val code: String,
                  val price: Double,
              ) {
                  init {
                      require(price > MIN_AMOUNT)
                  }
              
                  companion object {
                      val MIN_AMOUNT = 5.00
                  }
              }
              ```
              
              When companion object properties or top-level properties represent a constant value (known at compile time) that is either a primitive or a `String`, we can add the `const` modifier. This is an optimization. All usages of such variables will be replaced with their values at compile time.
              
              ```kotlin
              class Product(
                  val code: String,
                  val price: Double,
              ) {
                  init {
                      require(price > MIN_AMOUNT)
                  }
              
                  companion object {
                      const val MIN_AMOUNT = 5.00
                  }
              }
              ```
              
              Such properties can also be used in annotations:
              
              ```kotlin
              private const val OUTDATED_API: String =
                  "This is a part of an outdated API."
              
              @Deprecated(OUTDATED_API)
              fun foo() {
                  ...
              }
              
              @Deprecated(OUTDATED_API)
              fun boo() {
                  ...
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-12_objects-constant-values-q1"
            question: "Which declarations are valid uses of `const` in Kotlin?"
            explanation: "`const` is allowed only for `val` properties at top level or inside\
        \ `object`/companion objects, with a compile-time constant initializer of\
        \ a primitive or `String`. It’s not allowed for local variables, instance\
        \ properties, or `var`."
            repeatable: true
            answers:
              - "`const val API_URL: String = \"https://example.com\"`"
              - "`class Product { companion object { const val MIN_AMOUNT = 5.00 } }`"
              - "`object Config { const val MAX_RETRIES: Int = 3 }`"
              - "`fun compute() { const val LOCAL_FLAG = true }`"
              - "`class C { const val ID = 42 }`"
              - "`const var NAME: String = \"A\"`"
            correct:
              - "`const val API_URL: String = \"https://example.com\"`"
              - "`class Product { companion object { const val MIN_AMOUNT = 5.00 } }`"
              - "`object Config { const val MAX_RETRIES: Int = 3 }`"
          - type: "question-single-answer"
            stepId: "lesson-12_objects-constant-values-q2"
            question: "What happens when a `val` primitive/String in a companion object\
        \ or at top level is marked `const`?"
            explanation: "`const` makes the property a compile-time constant: all usages\
        \ are replaced with the literal value, and it can be used in annotation arguments."
            repeatable: false
            answers:
              - "Usages are replaced with the literal value at compile time."
              - "It’s accessed via a synthetic getter at runtime."
              - "It’s stored in a backing field initialized in an `init` block."
              - "It requires `@JvmField` to be inlined."
            correct: "Usages are replaced with the literal value at compile time."
          - type: "text"
            stepId: "lesson-12_objects-summary-text"
            repeatable: false
            text: |-
              In this chapter, we've learned that objects can be created not only from classes but also using object expressions and object declarations. Both these kinds of objects have practical usages. Object expression is used as an alternative to Java anonymous objects, but it offers more. Object declaration is Kotlin's implementation of the singleton pattern. A special form of object declaration, known as a companion object, is used as an alternative to static elements but with additional support for inheritance. We also have the `const` modifier, which offers better support for constant elements defined at the top level or in object declarations.
              
              In the previous chapter, we discussed data classes, but there are other modifiers we use for classes in Kotlin. In the next chapter, we will learn about another important type of class: exceptions.
          - type: "question-multiple-answer"
            stepId: "lesson-12_objects-summary-q1"
            question: "Where is it valid to declare `const val` in Kotlin? Choose all that\
        \ apply."
            explanation: "`const val` is for compile-time constants and is allowed at the\
        \ top level and inside object declarations (including companion objects).\
        \ It is not allowed for local variables or instance properties."
            repeatable: true
            answers:
              - "At top level in a file"
              - "Inside an object declaration"
              - "Inside a companion object"
              - "Inside a function body"
              - "As a property of a regular (non-object) class instance"
            correct:
              - "At top level in a file"
              - "Inside an object declaration"
              - "Inside a companion object"
          - type: "question-single-answer"
            stepId: "lesson-12_objects-summary-q2"
            question: "Which Kotlin feature replaces Java’s static members while also supporting\
        \ inheritance?"
            explanation: "Companion objects provide static-like members scoped to a class\
        \ and can participate in inheritance (e.g., implement interfaces), unlike\
        \ Java static members."
            repeatable: true
            answers:
              - "Top-level functions/properties"
              - "Object declaration"
              - "Companion object"
              - "Object expression"
            correct: "Companion object"
      - lessonId: "lesson-exceptions"
        name: "Exceptions"
        steps:
          - type: "text"
            stepId: "lesson-13_exceptions-#-exceptions-text"
            repeatable: false
            text: |-
              An exception is a generally unwanted event that interrupts the regular flow of your program. It might occur when you perform an illegal operation. Exceptions contain information that helps developers find out what led to this problem.
              
              Let's take a look at an example. When you divide an integer by 0, an exception of type `ArithmeticException` will be thrown. Each exception might have a message included that should explain what went wrong. In this case, the message will be "/ by zero". Each exception also includes its stack trace, which is a list of the method calls that the application was in the middle of when the exception was thrown. In this example, it includes information that this exception was thrown from the `calculate` function, which was called from the `printCalculated` function, which was called from the `main` function. Exception interrupts program execution, so statements after it won't be executed. In the example below, notice that "After" is never printed.
              
              ```kotlin
              private fun calculate(): Int {
                  return 1 / 0
              }
              
              private fun printCalculated() {
                  println(calculate())
              }
              
              fun main() {
                  println("Before")
                  printCalculated()
                  println("After")
              }
              // Before
              // Exception java.lang.ArithmeticException: / by zero
              //     at PlaygroundKt.calculate(Playground.kt:2)
              //     at PlaygroundKt.printCalculated(Playground.kt:6)
              //     at PlaygroundKt.main(Playground.kt:11)
              //     at PlaygroundKt.main(Playground.kt)
              ```
              
              As another example, we can parse a string to an integer using the `toInt` method, but this only works when the string is a number. When it isn’t, we will see `NumberFormatException` with a message explaining which string was used.
              
              ```kotlin
              fun main() {
                  val i1 = "10".toInt()
                  println(i1)
                  val i2 = "ABC".toInt()
                  println(i2)
              }
              // 10
              // Exception in thread "main" java.lang.NumberFormatException:
              // For input string: "ABC"
              //   at java.base/java.lang.NumberFormatException.
              //   forInputString(NumberFormatException.java:67)
              //   at java.base/java.lang.Integer.parseInt(Integer.java:660)
              //   at java.base/java.lang.Integer.parseInt(Integer.java:778)
              //   at PlaygroundKt.main(Playground.kt:4)
              //   at PlaygroundKt.main(Playground.kt)
              ```
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-#-exceptions-q1"
            question: |-
              Given the code below, what is printed before the program terminates?
              
              ```kotlin
              fun baz() {
                  val x = "x".toInt()
                  println("C")
              }
              
              fun bar() = baz()
              
              fun foo() {
                  println("A")
                  bar()
                  println("B")
              }
              
              fun main() {
                  println("M")
                  foo()
                  println("N")
              }
              ```
            explanation: "\"x\".toInt() throws NumberFormatException before printing C.\
        \ The exception propagates through bar and foo, so lines after bar() (B) and\
        \ after foo() (N) don't execute. A was printed before the failure."
            repeatable: true
            answers:
              - "Prints: M, A; then throws NumberFormatException (nothing else prints)."
              - "Prints: M, A, C; then throws NumberFormatException."
              - "Prints: M, A, B; then throws NumberFormatException."
              - "Prints: M; then throws NumberFormatException (A is not printed)."
            correct: "Prints: M, A; then throws NumberFormatException (nothing else prints)."
          - type: "question-multiple-answer"
            stepId: "lesson-13_exceptions-#-exceptions-q2"
            question: "Which statements about exceptions in Kotlin (as shown) are correct?"
            explanation: "1) True (ArithmeticException). 2) True (call chain at throw site).\
        \ 3) True (program flow stops past the throw). 4) False: \"10\" parses; errors\
        \ like \"ABC\" throw NumberFormatException. 5) False: divide-by-zero message\
        \ is \"/ by zero\"."
            repeatable: false
            answers:
              - "Dividing an Int by zero throws an ArithmeticException."
              - "A stack trace shows which functions were on the call stack when the exception\
        \ was thrown."
              - "Exceptions interrupt program execution; statements after them do not execute."
              - "\"10\".toInt() throws NumberFormatException."
              - "The message for dividing by zero is \"For input string: ...\"."
            correct:
              - "Dividing an Int by zero throws an ArithmeticException."
              - "A stack trace shows which functions were on the call stack when the exception\
        \ was thrown."
              - "Exceptions interrupt program execution; statements after them do not execute."
          - type: "text"
            stepId: "lesson-13_exceptions-throwing-exceptions-text"
            repeatable: false
            text: |-
              We can throw exceptions ourselves using the `throw` keyword and a value that can be used as an exception, like the aforementioned `ArithmeticException` or `NumberFormatException`.
              
              ```kotlin
              private fun functionThrowing() {
                  throw ArithmeticException("Some message")
              }
              
              fun main() {
                  println("Before")
                  functionThrowing()
                  println("After")
              }
              // Before
              // Exception in thread "main" java.lang.ArithmeticException:
              // Some message
              //  at PlaygroundKt.functionThrowing(Playground.kt:2)
              //  at PlaygroundKt.main(Playground.kt:7)
              //  at PlaygroundKt.main(Playground.kt)
              ```
              
              Exceptions communicate conditions that a function is not prepared to handle or is not responsible for. This isn’t necessarily an indication of an error; it’s more like a notification event that can be dealt with in another place that is set up to catch it.
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-throwing-exceptions-q1"
            question: |-
              What happens when this code runs?
              
              ```kotlin
              fun boom() {
                  throw ArithmeticException("oops")
              }
              
              fun main() {
                  println("Before")
                  boom()
                  println("After")
              }
              ```
            explanation: "`throw` immediately interrupts normal flow and unwinds the stack;\
        \ the line after it is not executed. Kotlin has no checked exceptions requirement."
            repeatable: false
            answers:
              - "Prints \"Before\" and \"After\"."
              - "Prints \"Before\", then throws; \"After\" is not printed."
              - "Throws before printing anything."
              - "Does not compile because Kotlin requires checked exceptions."
            correct: "Prints \"Before\", then throws; \"After\" is not printed."
          - type: "question-multiple-answer"
            stepId: "lesson-13_exceptions-throwing-exceptions-q2"
            question: "Which `throw` expressions compile in Kotlin? (Assume they appear\
        \ inside a function.)"
            explanation: "`throw` requires a `Throwable`. The first three are `Throwable`\
        \ subtypes; `String` and `Int` are not."
            repeatable: true
            answers:
              - "throw ArithmeticException(\"Bad math\")"
              - "throw NumberFormatException()"
              - "throw Exception()"
              - "throw \"Bad\""
              - "throw 404"
            correct:
              - "throw ArithmeticException(\"Bad math\")"
              - "throw NumberFormatException()"
              - "throw Exception()"
          - type: "text"
            stepId: "lesson-13_exceptions-defining-exceptions-text"
            repeatable: false
            text: |-
              We can also define our own exceptions. These are regular classes declarations that extend the `Throwable` class. Every such class can be thrown using `throw`.
              
              ```kotlin
              class MyException : Throwable("Some message")
              
              private fun functionThrowing() {
                  throw MyException()
                  // or throw MyExceptionObject
              }
              
              fun main() {
                  println("Before")
                  functionThrowing()
                  println("After")
              }
              // Before
              // Exception in thread "main" MyException: Some message
              //  at PlaygroundKt.functionThrowing(Playground.kt:4)
              //  at PlaygroundKt.main(Playground.kt:9)
              //  at PlaygroundKt.main(Playground.kt)
              ```
              
              > Beware! Exceptions cannot be defined as object declarations because each exception keeps mutable stack trace information.
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-defining-exceptions-q1"
            question: "You want to be able to write: `throw MyException(\"fail\")`. Which\
        \ declaration compiles and supports this?"
            explanation: "Custom exceptions must be classes extending Throwable (or Exception).\
        \ They cannot be `object` singletons, and `data class` cannot extend a class.\
        \ A sealed class is abstract and cannot be instantiated directly."
            repeatable: true
            answers:
              - "`class MyException(message: String) : Exception(message)`"
              - "`object MyException : Throwable(\"fail\")`"
              - "`data class MyException(val msg: String) : Throwable()`"
              - "`sealed class MyException(message: String) : Throwable(message)`"
            correct: "`class MyException(message: String) : Exception(message)`"
          - type: "question-exact-text"
            stepId: "lesson-13_exceptions-defining-exceptions-q2"
            question: "Why can't exceptions be defined as `object` declarations in Kotlin?"
            explanation: "Each exception instance maintains mutable stack trace state. A\
        \ singleton would share that state across throws, so Kotlin forbids `Throwable`\
        \ as an object."
            repeatable: false
            correct:
              - "Because exceptions carry mutable stack trace per instance"
              - "They have mutable stack trace state"
              - "Singleton objects would share the stack trace"
              - "Kotlin forbids Throwable as object because of mutable stack trace"
          - type: "text"
            stepId: "lesson-13_exceptions-catching-exceptions-text"
            repeatable: false
            text: |-
              Just like exceptions can be thrown, they can be caught using a try-catch structure that contains a try-block and a catch-block. An exception thrown in a function immediately ends this function’s execution, and the process repeats in the function that called the function in which the exception was thrown. This changes when an exception is thrown inside a try-block, because then its catch-blocks are checked. Each catch-block can specify what type of exceptions it catches. The first catch-block that accepts the exception that was thrown will catch it and then execute its body. If an exception is caught, the execution of the program continues after the try block.
              
              ```kotlin
              class MyException : Throwable("Some message")
              
              fun someFunction() {
                  throw MyException()
                  println("Will not be printed")
              }
              
              fun main() {
                  try {
                      someFunction()
                      println("Will not be printed")
                  } catch (e: MyException) {
                      println("Caught $e")
                      // Caught MyException: Some message
                  }
              }
              ```
              
              Let's see try-catch with more catch-blocks in action. Remember that the first block that accepts an exception is always chosen. A catch-block accepts an exception if this exception is a subtype of the type specified in the catch-block. Note that all exceptions must extend `Throwable`, so catching this type means catching all possible exceptions.
              
              ```kotlin
              import java.lang.NumberFormatException
              
              class MyException : Throwable("Some message")
              
              fun testTryCatch(exception: Throwable) {
                  try {
                      throw exception
                  } catch (e: ArithmeticException) {
                      println("Got ArithmeticException")
                  } catch (e: MyException) {
                      println("Got MyException")
                  } catch (e: Throwable) {
                      println("Got some exception")
                  }
              }
              
              fun main() {
                  testTryCatch(ArithmeticException())
                  // Got ArithmeticException
                  testTryCatch(MyException())
                  // Got MyException
                  testTryCatch(NumberFormatException())
                  // Got some exception
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-catching-exceptions-q1"
            question: |
              What does the following program print?
              
              ```kotlin
              open class E1 : Throwable("E1")
              class E2 : E1()
              class E3 : Throwable("E3")
              
              fun handle(t: Throwable) {
                  try {
                      throw t
                  } catch (e: E1) {
                      println("E1")
                  } catch (e: E3) {
                      println("E3")
                  } catch (e: Throwable) {
                      println("T")
                  }
              }
              
              fun main() {
                  handle(E2())
                  handle(E3())
                  handle(NumberFormatException())
              }
              ```
            explanation: "E2 is a subtype of E1, so it is caught by the E1 catch. E3 matches\
        \ its own catch. NumberFormatException matches only the Throwable catch. The\
        \ first matching catch handles the exception."
            repeatable: true
            answers:
              - |-
                E1
                E3
                T
              - |-
                E1
                T
                E3
              - |-
                E2
                E3
                T
              - |-
                E1
                E3
                Throwable
            correct: |-
              E1
              E3
              T
          - type: "question-multiple-answer"
            stepId: "lesson-13_exceptions-catching-exceptions-q2"
            question: "Which statements about try-catch in Kotlin are correct?"
            explanation: "Catch selection is based on the first compatible type (subtyping).\
        \ Throwable is the root of all exceptions, so catching it matches any exception.\
        \ Once a catch handles an exception, control continues after the try-catch;\
        \ later catches are not evaluated and catch parameters must be Throwable subtypes."
            repeatable: false
            answers:
              - "The first catch block whose parameter type is a supertype of the thrown exception\
        \ handles it."
              - "Catching Throwable catches any exception."
              - "After a catch block handles an exception, execution continues after the try-catch."
              - "Later catch blocks are also evaluated after a previous one matches."
              - "A catch block can declare a parameter of any type, not just Throwable subtypes."
            correct:
              - "The first catch block whose parameter type is a supertype of the thrown exception\
        \ handles it."
              - "Catching Throwable catches any exception."
              - "After a catch block handles an exception, execution continues after the try-catch."
          - type: "text"
            stepId: "lesson-13_exceptions-a-try-catch-block-used-as-an-expression-text"
            repeatable: false
            text: |-
              The try-catch structure can be used as an expression. It returns the result of a try-block if no exception occurred. If an exception occurs and is caught, then the try-catch expression returns the result of the catch-block.
              
              ```kotlin
              fun main() {
                  val a = try {
                      1
                  } catch (e: Error) {
                      2
                  }
                  println(a) // 1
              
                  val b = try {
                      throw Error()
                      1
                  } catch (e: Error) {
                      2
                  }
                  println(b) // 2
              }
              ```
              
              A try-catch expression can be used to provide an alternative value for a situation in which a problem occurs:
              
              ```kotlin
              import java.io.File
              import java.io.FileNotFoundException
              
              fun main() {
                  val content = try {
                      File("AAA").readText()
                  } catch (e: FileNotFoundException) {
                      ""
                  }
                  println(content) // (empty string)
              }
              ```
              
              A practical example might be reading a string containing an object in JSON format. We use the Gson library, whose `fromJson` method throws `JsonSyntaxException` when a string does not contain a proper JSON object. Instead, we would prefer a function that returns `null` in such cases; we can implement this using try-catch as an expression.
              
              ```kotlin
              fun <T : Any> fromJsonOrNull(
                  json: String,
                  clazz: KClass<T>
              ): T? = try {
                  gson.fromJson(json, clazz.java)
              } catch (e: JsonSyntaxException) {
                  null
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-a-try-catch-block-used-as-an-expression-q1"
            question: |-
              What is the inferred type of x and what does this program print?
              
              ```kotlin
              fun main() {
                  val x = try {
                      42
                  } catch (e: Exception) {
                      null
                  }
                  println(x)
              }
              ```
            explanation: "try-catch is an expression. The branches are Int and null (Nothing?),\
        \ so the common type is Int?. No exception occurs, so the value is 42 and\
        \ it prints 42."
            repeatable: true
            answers:
              - "Int?, prints 42"
              - "Int, prints 42"
              - "Any?, prints 42"
              - "Compilation error due to mismatched branch types"
            correct: "Int?, prints 42"
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-a-try-catch-block-used-as-an-expression-q2"
            question: |-
              Which implementation correctly returns null on malformed JSON using try-catch as an expression?
              
              Assume gson.fromJson throws JsonSyntaxException for invalid JSON.
              
              ```kotlin
              fun <T : Any> fromJsonOrNull(json: String, clazz: KClass<T>): T?
              ```
            explanation: "Only the catch branch returning null makes the try-catch expression\
        \ yield null on parsing failure. finally does not change the expression value;\
        \ the other options don't return null."
            repeatable: false
            answers:
              - "return try { gson.fromJson(json, clazz.java) } catch (e: JsonSyntaxException)\
        \ { null }"
              - "return try { gson.fromJson(json, clazz.java) } finally { null }"
              - "return try { gson.fromJson(json, clazz.java) } catch (e: JsonSyntaxException)\
        \ { \"\" as T }"
              - "return try { gson.fromJson(json, clazz.java) } catch (e: JsonSyntaxException)\
        \ { throw e }"
            correct: "return try { gson.fromJson(json, clazz.java) } catch (e: JsonSyntaxException)\
        \ { null }"
          - type: "text"
            stepId: "lesson-13_exceptions-the-finally-block-text"
            repeatable: false
            text: |-
              Inside the try-structure, we can also use a finally-block, which is used to specify what should always be invoked, even if an exception occurs. This block does not catch any exceptions; it is used to guarantee that some operations will be executed, no matter the exceptions.
              
              Take a look at the code below. An exception is thrown inside `someFunction`. This exception ends this function’s execution and skips the rest of the try-block. Since we do not have a catch-block, this exception will not be caught, thus ending the execution of the `main` function. However, there is also the finally-block, whose body is invoked even if an exception occurs.
              
              ```kotlin
              fun someFunction() {
                  throw Throwable("Some error")
              }
              
              fun main() {
                  try {
                      someFunction()
                  } finally {
                      println("Finally block was called")
                  }
                  println("Will not be printed")
              }
              // Finally block was called
              ```
              
              The finally-block is also invoked when the try-block finishes without an exception.
              
              ```kotlin
              fun someFunction() {
                  println("Function called")
              }
              
              fun main() {
                  try {
                      someFunction()
                      println("After call")
                  } finally {
                      println("Finally block was called")
                  }
                  println("After try-finally")
              }
              // Function called
              // After call
              // Finally block was called
              // After try-finally
              ```
              
              We use the finally-block to do operations that should always be done, no matter if an exception occurs or not. It typically involves closing connections or cleaning up resources.
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-the-finally-block-q1"
            question: |-
              Given the code:
              
              ```kotlin
              fun fail() {
                  println("start")
                  throw IllegalStateException("x")
                  println("unreached")
              }
              
              fun main() {
                  try {
                      fail()
                      println("after fail")
                  } finally {
                      println("finally")
                  }
                  println("end")
              }
              ```
              What is the output?
            explanation: "The exception interrupts the try-block: \"unreached\" and \"after\
        \ fail\" are skipped. The finally-block still runs. Because the exception\
        \ is uncaught, execution does not continue to \"end\". Output: start, finally."
            repeatable: true
            answers:
              - |-
                start
                finally
              - |-
                start
                finally
                end
              - |-
                start
                after fail
                finally
              - "finally"
            correct: |-
              start
              finally
          - type: "question-multiple-answer"
            stepId: "lesson-13_exceptions-the-finally-block-q2"
            question: "Which statements about Kotlin's finally-block are true?"
            explanation: "finally always runs whether try completes normally or exceptionally,\
        \ and is commonly used for cleanup. It does not catch exceptions; if an exception\
        \ is uncaught, finally runs but code after try-finally does not execute."
            repeatable: true
            answers:
              - "It runs whether or not an exception occurs in the try-block."
              - "It catches exceptions when there is no catch-block."
              - "It's typically used to close resources or clean up."
              - "If an exception is thrown and not caught, the finally-block runs but statements\
        \ after the try-finally are not executed."
              - "The Kotlin compiler may omit the finally-block if no exception is thrown."
            correct:
              - "It runs whether or not an exception occurs in the try-block."
              - "It's typically used to close resources or clean up."
              - "If an exception is thrown and not caught, the finally-block runs but statements\
        \ after the try-finally are not executed."
          - type: "text"
            stepId: "lesson-13_exceptions-important-exceptions-text"
            repeatable: false
            text: |-
              A few kinds of exceptions are defined in Kotlin that we use in certain situations. The most important ones are:
              - `IllegalArgumentException` - we use this when an argument has an incorrect value. For example, when you expect your argument value to be bigger than 0 but it is not.
              - `IllegalStateException` - we use this when the state of our system is incorrect. This means the values of properties are not accepted by a function call.
              
              ```kotlin
              fun findClusters(number: Int) {
                  if (number < 1) {
                      throw IllegalArgumentException("...")
                  }
                  // ...
              }
              
              var userName = ""
              
              fun printUserName() {
                  if (userName == "") {
                      throw IllegalStateException("Name must not be empty")
                  }
                  // ...
              }
              ```
              
              In Kotlin, we use the `require` and `check` functions to throw `IllegalArgumentException` and `IllegalStateException` when their conditions are not satisfied.
              
              ```kotlin
              fun pop(num: Int): List<T> {
                  require(num <= size)
                  // throws IllegalArgumentException if num > size
                  check(isOpen)
                  // throws IllegalStateException if is not open
                  val ret = collection.take(num)
                  collection = collection.drop(num)
                  return ret
              }
              ```
              
              There is also an `error` function from Kotlin stdlib that throws `IllegalArgumentException` with a message specified as an argument. It is often used as a body for a branch in a when-condition, on the right side of the Elvis operator, or in an if-else expression.
              
              ```kotlin
              fun makeOperation(
                  operation: String,
                  left: Int,
                  right: Int? = null
              ): Int = when (operation) {
                  "add" ->
                      left + (right ?: error("Two numbers required"))
                  "subtract" ->
                      left - (right ?: error("Two numbers required"))
                  "opposite" -> -left
                  else -> error("Unknown operation")
              }
              
              fun main() {
                  println(makeOperation("add", 1, 2)) // 3
                  println(makeOperation("subtract", 1, 2)) // -1
                  println(makeOperation("opposite", 10)) // -10
              
                  makeOperation("add", 1) // ERROR!
                  // IllegalStateException: Two numbers required
                  makeOperation("subtract", 1) // ERROR!
                  // IllegalStateException: Two numbers required
                  makeOperation("other", 1, 2) // ERROR!
                  // IllegalStateException: Unknown operation
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-important-exceptions-q1"
            question: |-
              Given the code:
              
              ```kotlin
              fun <T> pop(num: Int, size: Int, isOpen: Boolean): List<T> {
                  require(num <= size)
                  check(isOpen)
                  // ...
                  return emptyList()
              }
              ```
              
              If size = 3, isOpen = false, and num = 5, which exception is thrown first?
            explanation: "`require(num <= size)` fails first and throws IllegalArgumentException\
        \ before `check(isOpen)` is evaluated."
            repeatable: false
            answers:
              - "IllegalArgumentException"
              - "IllegalStateException"
              - "IndexOutOfBoundsException"
              - "No exception (function returns normally)"
            correct: "IllegalArgumentException"
          - type: "question-multiple-answer"
            stepId: "lesson-13_exceptions-important-exceptions-q2"
            question: "Select all correct statements about `require`, `check`, and `error`\
        \ in Kotlin (based on the provided snippet)."
            explanation: "Use `require` for argument validation (IllegalArgumentException)\
        \ and `check` for state validation (IllegalStateException). The `error` function\
        \ is commonly used in expression contexts like when-branches or Elvis."
            repeatable: true
            answers:
              - "`require(condition)` throws IllegalArgumentException when the condition is\
        \ false."
              - "`check(condition)` throws IllegalStateException when the condition is false."
              - "`error(\"msg\")` is often used as a when-branch body or on the right side\
        \ of the Elvis operator."
              - "`check(...)` should be used to validate function parameters provided by the\
        \ caller."
              - "`require(...)` should be used to assert internal object/system state."
            correct:
              - "`require(condition)` throws IllegalArgumentException when the condition is\
        \ false."
              - "`check(condition)` throws IllegalStateException when the condition is false."
              - "`error(\"msg\")` is often used as a when-branch body or on the right side\
        \ of the Elvis operator."
          - type: "text"
            stepId: "lesson-13_exceptions-the-hierarchy-of-exceptions-text"
            repeatable: false
            text: |-
              The most important subtypes of `Throwable` are `Error` and `Exception`. These represent two types of exceptions:
              * `Error` type represents exceptions that are impossible to recover from and consequently should not be caught, at least not without throwing them again in catch-block. Exceptions that are impossible to recover from include `OutOfMemoryError`, which is thrown when there is insufficient space in the JVM heap.
              * `Exception` type represents exceptions we can recover from using a try-catch block. This group includes `IllegalArgumentException`, `IllegalStateException`, `ArithmeticException`, and `NumberFormatException`.
              
              In most cases, when we define custom exceptions, we should use the `Exception` superclass; when we catch exceptions, we should only throw subtypes of `Exception`.
              
              ![](exception_hierarchy.png)
              
              In Kotlin, we are not forced to catch any kinds of exceptions; so, unlike in some other languages, there are no checked exceptions.
          - type: "question-multiple-answer"
            stepId: "lesson-13_exceptions-the-hierarchy-of-exceptions-q1"
            question: "Select all correct statements about Kotlin's exception hierarchy\
        \ and handling:"
            explanation: "Error is for unrecoverable conditions; don't catch it unless rethrowing.\
        \ Kotlin has no checked exceptions, so catching is not enforced. App-level/custom\
        \ exceptions should extend Exception, and exceptions like IllegalArgumentException\
        \ are recoverable."
            repeatable: true
            answers:
              - "Error indicates unrecoverable problems; avoid catching it (unless rethrowing)."
              - "Kotlin requires you to catch certain exceptions at compile time (checked\
        \ exceptions)."
              - "Custom domain exceptions should typically extend Exception, not Error."
              - "It's good practice to catch Throwable to handle all failures in one place."
              - "Exceptions like IllegalArgumentException and NumberFormatException are recoverable\
        \ via try-catch."
            correct:
              - "Error indicates unrecoverable problems; avoid catching it (unless rethrowing)."
              - "Custom domain exceptions should typically extend Exception, not Error."
              - "Exceptions like IllegalArgumentException and NumberFormatException are recoverable\
        \ via try-catch."
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-the-hierarchy-of-exceptions-q2"
            question: "When defining a custom, recoverable application-level failure in\
        \ Kotlin, which superclass should you most commonly extend?"
            explanation: "Custom exceptions should extend Exception. Error is for unrecoverable\
        \ JVM issues (e.g., OutOfMemoryError) and should not be used for domain failures."
            repeatable: false
            answers:
              - "Throwable"
              - "Error"
              - "Exception"
              - "OutOfMemoryError"
            correct: "Exception"
          - type: "text"
            stepId: "lesson-13_exceptions-summary-text"
            repeatable: false
            text: |-
              In this chapter we’ve learned about exceptions, which are an important part of Kotlin programming. We’ve learned how to throw, catch, and define exceptions. We’ve also learned about the finally-block and the exceptions hierarchy.
              
              Continuing with special kinds of classes, let's talk about enum classes, which are used to represent a set of object instance values.
          - type: "question-single-answer"
            stepId: "lesson-13_exceptions-summary-q1"
            question: |-
              In Kotlin, why does this compile, and what is the type of the right-hand expression?
              
              ```
              val len: Int = s?.length ?: throw IllegalArgumentException("s is null")
              ```
            explanation: "`throw` is an expression with type `Nothing`, which is a subtype\
        \ of all types. This lets it fit the expected type on the RHS of the Elvis\
        \ operator."
            repeatable: true
            answers:
              - "Because `throw` is an expression of type Nothing."
              - "Because `throw` has type Unit, which can be assigned to any type."
              - "Because `throw` is special-cased by the Elvis operator only."
              - "Because the compiler widens the RHS to Any?."
            correct: "Because `throw` is an expression of type Nothing."
          - type: "question-multiple-answer"
            stepId: "lesson-13_exceptions-summary-q2"
            question: "Which statements about exceptions and try/catch/finally in Kotlin/JVM\
        \ are true?"
            explanation: |-
              - Catching `Throwable` before a more specific type makes the latter catch unreachable (compile-time error).
              - `finally` runs after try/catch even on exception or return (unless the process terminates).
              - Kotlin has no checked exceptions; `Throwable` is the root of the hierarchy.
            repeatable: false
            answers:
              - "A catch for Throwable before a catch for Exception makes the second catch\
        \ unreachable and is a compilation error."
              - "A finally block runs after try/catch even if an exception is thrown or a\
        \ return is executed (unless the process terminates)."
              - "Kotlin requires declaring thrown exceptions in function signatures (checked\
        \ exceptions)."
              - "Custom exception classes must be declared open to be throwable."
              - "Throwable is the root of the exception hierarchy in Kotlin/JVM."
            correct:
              - "A catch for Throwable before a catch for Exception makes the second catch\
        \ unreachable and is a compilation error."
              - "A finally block runs after try/catch even if an exception is thrown or a\
        \ return is executed (unless the process terminates)."
              - "Throwable is the root of the exception hierarchy in Kotlin/JVM."
      - lessonId: "lesson-enum-classes\r"
        name: "Enum classes\r"
        steps:
          - type: "text"
            stepId: "lesson-14_enum-#-enum-classes-text"
            repeatable: false
            text: |-
              In this chapter, we're going to introduce the concept of enum classes. Let's start with an example. Suppose that you’re implementing a payment method that has to support three possible options: cash payment, card payment, and bank transfer. The most basic way to represent a fixed set of values in Kotlin is an enum class. Inside its body, we list all the values, divided by a comma. We name values using UPPER_SNAKE_CASE notation (e.g., `BANK_TRANSFER`). Enum class elements can be referenced by the enum name, followed by a dot, and then the value name (e.g., `PaymentOption.CASH`). All values are typed as the enum class type.
              
              ```kotlin
              enum class PaymentOption {
                  CASH,
                  CARD,
                  TRANSFER,
              }
              
              fun printOption(option: PaymentOption) {
                  println(option)
              }
              
              fun main() {
                  val option: PaymentOption = PaymentOption.CARD
                  println(option) // CARD
                  printOption(option) // CARD
              }
              ```
              
              Each enum class has the following companion object elements:
              * `entries` property, which keeps a list of all the values of this enum class. It is a modern replacement of the `values` function, that returns an array of elements.
              * `valueOf` function, which parses a string into a value matching its name (this is case-sensitive) or throws an exception.
              
              ```kotlin
              enum class PaymentOption {
                  CASH,
                  CARD,
                  TRANSFER,
              }
              
              fun main() {
                  val option: PaymentOption =
                      PaymentOption.valueOf("TRANSFER")
                  println(option)
              
                  println("All options: ")
                  val paymentOptions: List<PaymentOption> =
                      PaymentOption.entries
                  for (paymentOption in paymentOptions) {
                      println(paymentOption)
                  }
              }
              // TRANSFER
              // All options:
              // CASH
              // CARD
              // TRANSFER
              ```
              
              Instead of these methods, we can also use the top-level `enumValues` and `enumValueOf` functions.
              
              ```kotlin
              enum class PaymentOption {
                  CASH,
                  CARD,
                  TRANSFER,
              }
              
              fun main() {
                  val option = enumValueOf<PaymentOption>("TRANSFER")
                  println(option)
              
                  println("All options: ")
                  val paymentOptions = enumValues<PaymentOption>()
                  for (paymentOption in paymentOptions) {
                      println(paymentOption)
                  }
              }
              // TRANSFER
              // All options:
              // CASH
              // CARD
              // TRANSFER
              ```
              
              As you can see, enum elements keep their values in order. This order is important. Each enum value has two properties:
              * `name` - the name of this value,
              * `ordinal` - the position of this value (starting from 0).
              
              ```kotlin
              enum class PaymentOption {
                  CASH,
                  CARD,
                  TRANSFER,
              }
              
              fun main() {
                  val option = PaymentOption.TRANSFER
                  println(option.name) // TRANSFER
                  println(option.ordinal) // 2
              }
              ```
              
              Each enum class is a subclass of the abstract class `Enum`. This superclass guarantees the `name` and `ordinal` properties. Enum classes have properties that implement `toString`, `equals`, and `hashCode`, but, unlike data classes, they also have `compareTo` (their natural order is the order of the elements in the body).
              
              Enum values can be used inside when-conditions. Moreover, there is no need to use the else-branch when all possible enum values are covered.
              
              ```kotlin
              fun transactionFee(paymentOption: PaymentOption): Double =
                  when (paymentOption) {
                      PaymentOption.CASH -> 0.0
                      PaymentOption.CARD, PaymentOption.TRANSFER -> 0.05
                  }
              ```
              
              Enum classes are very convenient because they can be easily parsed or stringified. They are a popular way to represent a finite set of possible values.
          - type: "question-single-answer"
            stepId: "lesson-14_enum-#-enum-classes-q1"
            question: "Given `enum class PaymentOption { CASH, CARD, TRANSFER }`, which\
        \ API is a property on `PaymentOption` that exposes all constants as a List\
        \ in declaration order?"
            explanation: "`entries` is the modern companion property that returns a List\
        \ in declaration order. `values()` and `enumValues<T>()` return arrays."
            repeatable: true
            answers:
              - "PaymentOption.entries"
              - "PaymentOption.values()"
              - "enumValues<PaymentOption>()"
              - "PaymentOption.allValues"
            correct: "PaymentOption.entries"
          - type: "question-single-answer"
            stepId: "lesson-14_enum-#-enum-classes-q2"
            question: |-
              What does the following print?
              
              ```kotlin
              enum class PaymentOption { CASH, CARD, TRANSFER }
              
              fun main() {
                  println(listOf(PaymentOption.CARD, PaymentOption.CASH, PaymentOption.TRANSFER).sorted())
              }
              ```
            explanation: "Enums implement Comparable by ordinal (declaration order). Sorting\
        \ yields `[CASH, CARD, TRANSFER]`, and `toString()` of enum constants prints\
        \ their names."
            repeatable: true
            answers:
              - "[CASH, CARD, TRANSFER]"
              - "[CARD, CASH, TRANSFER]"
              - "[TRANSFER, CARD, CASH]"
              - "Compilation error"
            correct: "[CASH, CARD, TRANSFER]"
          - type: "text"
            stepId: "lesson-14_enum-data-in-enum-values-text"
            repeatable: false
            text: |-
              In Kotlin, each enum value can hold a state. It is possible to define a primary constructor for an enum class, and then each value needs to specify its data next to its name. **It is the best practice that enum values should always be immutable, so their state should never change**.
              
              ```kotlin
              import java.math.BigDecimal
              
              enum class PaymentOption(val commission: BigDecimal) {
                  CASH(BigDecimal.ONE),
                  CARD(BigDecimal.TEN),
                  TRANSFER(BigDecimal.ZERO)
              }
              
              fun main() {
                  println(PaymentOption.CARD.commission) // 10
                  println(PaymentOption.TRANSFER.commission) // 0
              
                  val paymentOption: PaymentOption =
                      PaymentOption.entries.random()
                  println(paymentOption.commission) // 0, 1 or 10
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-14_enum-data-in-enum-values-q1"
            question: "Which snippet both compiles and follows the recommendation that enum\
        \ values be immutable and explicitly provide their data?"
            explanation: "Use a primary constructor with val and supply arguments for every\
        \ constant. Option 2 uses var (mutable), 3 relies on a default so constants\
        \ don’t explicitly provide data, and 4 tries to assign to a val."
            repeatable: true
            answers:
              - "enum class PaymentOption(val commission: BigDecimal) { CASH(BigDecimal.ONE),\
        \ CARD(BigDecimal.TEN) }"
              - "enum class PaymentOption(var commission: BigDecimal) { CASH(BigDecimal.ONE),\
        \ CARD(BigDecimal.TEN) }"
              - "enum class PaymentOption(val commission: BigDecimal = BigDecimal.ZERO) {\
        \ CASH, CARD }"
              - "enum class PaymentOption(val commission: BigDecimal) { CASH(BigDecimal.ONE);\
        \ fun setCommission(x: BigDecimal) { commission = x } }"
            correct: "enum class PaymentOption(val commission: BigDecimal) { CASH(BigDecimal.ONE),\
        \ CARD(BigDecimal.TEN) }"
          - type: "question-single-answer"
            stepId: "lesson-14_enum-data-in-enum-values-q2"
            question: "For the enum from the section, which expression has type BigDecimal?"
            explanation: "The per-constant property is a BigDecimal; the others are PaymentOption,\
        \ Array<PaymentOption>, or String."
            repeatable: true
            answers:
              - "PaymentOption.CARD.commission"
              - "PaymentOption.entries.random()"
              - "PaymentOption.values()"
              - "PaymentOption.CARD.name"
            correct: "PaymentOption.CARD.commission"
          - type: "text"
            stepId: "lesson-14_enum-enum-classes-with-custom-methods-text"
            repeatable: false
            text: |-
              Kotlin enums can have abstract methods whose implementations are item-specific. When we define them, the enum class itself needs to define an abstract method, and each item must override it:
              
              ```kotlin
              enum class PaymentOption {
                  CASH {
                      override fun startPayment(
                          transaction: Transaction
                      ) {
                          showCashPaymentInfo(transaction)
                      }
                  },
                  CARD {
                      override fun startPayment(
                          transaction: Transaction
                      ) {
                          moveToCardPaymentPage(transaction)
                      }
                  },
                  TRANSFER {
                      override fun startPayment(
                          transaction: Transaction
                      ) {
                          showMoneyTransferInfo()
                          setupPaymentWatcher(transaction)
                      }
                  };
              
                  abstract fun startPayment(transaction: Transaction)
              }
              ```
              
              This option is not popular as we generally prefer using functional primary constructor parameters or extension functions.
          - type: "question-multiple-answer"
            stepId: "lesson-14_enum-enum-classes-with-custom-methods-q1"
            question: "Select all correct statements about enum classes with item-specific\
        \ behavior in Kotlin."
            explanation: "Enums can declare abstract methods, but then every entry must\
        \ implement them. If there are members after the entries, a semicolon is required.\
        \ Instead of item-specific abstract methods, you can move behavior out via\
        \ an extension function."
            repeatable: true
            answers:
              - "If an enum declares an abstract method, every entry must override it with\
        \ its own body."
              - "A semicolon after the last enum entry is required if the enum declares members\
        \ after the entries."
              - "Extension functions can be used to move the behavior outside the enum instead\
        \ of using abstract methods."
              - "Secondary constructors are the idiomatic way to pass per-entry lambdas for\
        \ behavior."
              - "An enum can inherit from another enum to reuse abstract methods."
            correct:
              - "If an enum declares an abstract method, every entry must override it with\
        \ its own body."
              - "A semicolon after the last enum entry is required if the enum declares members\
        \ after the entries."
              - "Extension functions can be used to move the behavior outside the enum instead\
        \ of using abstract methods."
          - type: "question-single-answer"
            stepId: "lesson-14_enum-enum-classes-with-custom-methods-q2"
            question: "Which enum declaration both compiles and uses a functional primary\
        \ constructor parameter to provide per-entry behavior for `startPayment`?"
            explanation: "C passes a function via the primary constructor and delegates\
        \ `startPayment` to it. A and B leave abstract methods unimplemented for some\
        \ entries. D misses the required semicolon before declaring members after\
        \ entries."
            repeatable: false
            answers:
              - |-
                A)
                ```kotlin
                enum class PaymentOption {
                    CASH, CARD;
                    abstract fun startPayment(t: Transaction)
                }
                ```
              - |-
                B)
                ```kotlin
                enum class PaymentOption {
                    CASH {
                        override fun startPayment(t: Transaction) {}
                    },
                    CARD;
                    abstract fun startPayment(t: Transaction)
                }
                ```
              - |-
                C)
                ```kotlin
                enum class PaymentOption(
                    private val start: (Transaction) -> Unit
                ) {
                    CASH({}),
                    CARD({});
                
                    fun startPayment(t: Transaction) = start(t)
                }
                ```
              - |-
                D)
                ```kotlin
                enum class PaymentOption {
                    CASH {
                        override fun startPayment(t: Transaction) {}
                    },
                    CARD {
                        override fun startPayment(t: Transaction) {}
                    }
                    abstract fun startPayment(t: Transaction)
                }
                ```
            correct: "C"
          - type: "text"
            stepId: "lesson-14_enum-summary-text"
            repeatable: false
            text: |-
              Enum classes are a convenient way to represent a concrete set of possible values. Each value has the properties `name` and `ordinal` (position). We can get an array of all values using the `values` companion object function or the `enumValues` top-level function. We can also parse an enum value from `String` using the `valueOf` companion object function or the `enumValueOf` top-level function.
              
              In the next chapter, we will talk about sealed classes, which are often treated as similar to enums but represent completely different and even more powerful abstractions. Sealed classes can form a closed hierarchy of classes, whereas enums represent only a set of constant values.
          - type: "question-multiple-answer"
            stepId: "lesson-14_enum-summary-q1"
            question: "Given `enum class Direction { NORTH, SOUTH, EAST, WEST }`, which\
        \ expressions return an `Array<Direction>` containing all enum constants?"
            explanation: "`values()` (companion function) and `enumValues<T>()` (top-level)\
        \ both return `Array<T>` of all constants. `valueOf/enumValueOf` parse a single\
        \ constant, and `Direction.values` is not a property."
            repeatable: false
            answers:
              - "Direction.values()"
              - "enumValues<Direction>()"
              - "Direction.valueOf(\"NORTH\")"
              - "enumValueOf<Direction>(\"EAST\")"
              - "Direction.values"
            correct:
              - "Direction.values()"
              - "enumValues<Direction>()"
          - type: "question-single-answer"
            stepId: "lesson-14_enum-summary-q2"
            question: "Which statement best describes how sealed classes differ from enum\
        \ classes?"
            explanation: "Enums are a set of constant values. Sealed classes form a closed\
        \ type hierarchy and can represent different shapes/state per subtype."
            repeatable: true
            answers:
              - "Enum classes represent a fixed set of constants; sealed classes define a\
        \ closed hierarchy of types and can model different data per subtype."
              - "Both enums and sealed classes only allow constant values without properties."
              - "Sealed classes are enums with extra functions."
              - "Enum classes support inheritance hierarchies; sealed classes cannot be subclassed."
            correct: "Enum classes represent a fixed set of constants; sealed classes define\
        \ a closed hierarchy of types and can model different data per subtype."
      - lessonId: "lesson-sealed-classes-and-interfaces"
        name: "Sealed classes and interfaces"
        steps:
          - type: "text"
            stepId: "lesson-15_sealed-#-sealed-classes-and-interfaces-text"
            repeatable: false
            text: |-
              Classes and interfaces in Kotlin are not only used to represent a set of operations or data; we can also use classes and inheritance to represent hierarchies through polymorphism. For instance, let's say that you send a network request; as a result, you either successfully receive the requested data, or the request fails with some information about what went wrong. These two outcomes can be represented using two classes that implement an interface:
              
              ```kotlin
              interface Result
              class Success(val data: String) : Result
              class Failure(val exception: Throwable) : Result
              ```
              
              Alternatively, you could use an abstract class:
              
              ```kotlin
              abstract class Result
              class Success(val data: String) : Result()
              class Failure(val exception: Throwable) : Result()
              ```
              
              With either of these, we know that when a function returns `Result`, it can be `Success` or `Failure`.
              
              ```kotlin
              val result: Result = getSomeData()
              when (result) {
                  is Success -> handleSuccess(result.data)
                  is Failure -> handleFailure(result.exception)
              }
              ```
              
              The problem is that when a regular interface or abstract class is used, there is no guarantee that its defined subclasses are all possible subtypes of this interface or abstract class. Someone might define another class and make it implement `Result`. Someone might also implement an object expression that implements `Result`.
              
              ```kotlin
              class FakeSuccess : Result
              
              val res: Result = object : Result {}
              ```
              
              A hierarchy whose subclasses are not known in advance is known as a non-restricted hierarchy. For `Result`, we prefer to define a restricted hierarchy, which we do by using a `sealed` modifier before a class or an interface.
              
              ```kotlin
              sealed interface Result
              class Success(val data: String) : Result
              class Failure(val exception: Throwable) : Result
              
              // or
              
              sealed class Result
              class Success(val data: String) : Result()
              class Failure(val exception: Throwable) : Result()
              ```
              
              > When we use the `sealed` modifier before a class, it makes this class abstract already, so we don’t use the `abstract` modifier.
              
              There are a few requirements that all sealed class or interface children must meet:
              * they need to be defined in the same package and module where the sealed class or interface is,
              * they can't be local or defined using object expression.
              
              This means that when you use the `sealed` modifier, you control which subclasses a class or interface has. The clients of your library or module cannot add their own direct subclasses. No one can quietly add a local class or object expression that extends a sealed class or interface. Kotlin has made this impossible. The hierarchy of subclasses is restricted.
              
              > Sealed interfaces were introduced in more recent versions of Kotlin to allow classes to implement multiple sealed hierarchies. The relation between a sealed class and a sealed interface is similar to the relation between an abstract class and an interface. The power of classes is that they can keep a state (non-abstract properties) and control their members' openness (can have final methods and properties). The power of interfaces is that a class can inherit from only one class but it can implement multiple interfaces.
          - type: "question-multiple-answer"
            stepId: "lesson-15_sealed-#-sealed-classes-and-interfaces-q1"
            question: |
              Given the sealed base below, which declarations are valid direct implementations of it?
              
              ```kotlin
              // file: a/b/Result.kt (module: core)
              package a.b
              sealed interface Result
              ```
            explanation: "Children of a sealed type must be in the same package and module;\
        \ they cannot be local or anonymous (object expression). Named top-level objects\
        \ are allowed."
            repeatable: true
            answers:
              - |-
                ```kotlin
                // file: a/b/Success.kt (module: core)
                package a.b
                class Success(val data: String) : Result
                ```
              - |-
                ```kotlin
                // file: a/b/Err.kt (module: api — different module)
                package a.b
                class Err(val e: Throwable) : Result
                ```
              - |-
                ```kotlin
                // file: a/c/Foo.kt (module: core — different package)
                package a.c
                class Foo : Result
                ```
              - |-
                ```kotlin
                // file: a/b/Flags.kt (module: core)
                package a.b
                object Loading : Result
                ```
              - |-
                ```kotlin
                // anywhere
                val r: Result = object : Result {}
                ```
              - |-
                ```kotlin
                // in a function (package a.b)
                fun f() {
                    class LocalImpl : Result
                }
                ```
            correct:
              - |-
                ```kotlin
                // file: a/b/Success.kt (module: core)
                package a.b
                class Success(val data: String) : Result
                ```
              - |-
                ```kotlin
                // file: a/b/Flags.kt (module: core)
                package a.b
                object Loading : Result
                ```
          - type: "question-single-answer"
            stepId: "lesson-15_sealed-#-sealed-classes-and-interfaces-q2"
            question: "You want classes to participate in multiple restricted hierarchies.\
        \ Which base should you make sealed?"
            explanation: "Classes can implement multiple interfaces but extend only one\
        \ class. Sealing an interface creates restricted hierarchies that a class\
        \ can join multiple of."
            repeatable: false
            answers:
              - "sealed interface"
              - "sealed class"
              - "abstract class"
              - "regular interface"
            correct: "sealed interface"
          - type: "text"
            stepId: "lesson-15_sealed-sealed-classes-and-`when`-expressions-text"
            repeatable: false
            text: |-
              Using `when` as an expression must return some value, so it must be exhaustive. In most cases, the only way to achieve this is to specify an `else` clause.
              
              ```kotlin
              fun commentValue(value: String) = when {
                  value.isEmpty() -> "Should not be empty"
                  value.length < 5 -> "Too short"
                  else -> "Correct"
              }
              
              fun main() {
                  println(commentValue("")) // Should not be empty
                  println(commentValue("ABC")) // Too short
                  println(commentValue("ABCDEF")) // Correct
              }
              ```
              
              However, there are also cases in which Kotlin knows that we have specified all possible values. For example, when we use a when-expression with an enum value and we compare this value to all possible enum values.
              
              ```kotlin
              enum class PaymentType {
                  CASH,
                  CARD,
                  CHECK
              }
              
              fun commentDecision(type: PaymentType) = when (type) {
                  PaymentType.CASH -> "I will pay with cash"
                  PaymentType.CARD -> "I will pay with card"
                  PaymentType.CHECK -> "I will pay with check"
              }
              ```
              
              The power of having a finite set of types as an argument makes it possible to have an exhaustive `when` with a branch for every possible value. In the case of sealed classes or interfaces, this means having `is` checks for all possible subtypes.
              
              ```kotlin
              sealed class Response<out V>
              class Success<V>(val value: V) : Response<V>()
              class Failure(val error: Throwable) : Response<Nothing>()
              
              fun handle(response: Response<String>) {
                  val text = when (response) {
                      is Success -> "Success with ${response.value}"
                      is Failure -> "Error"
                      // else is not needed here
                  }
                  print(text)
              }
              ```
              
              Also, IntelliJ automatically suggests adding the remaining branches. This makes sealed classes very convenient when we need to cover all possible types.
              
              ![](remaining_branches.png)
              
              Note that when an `else` clause is not used and we add another subclass of this sealed class, the usage needs to be adjusted by including this new type. This is convenient in local code as it forces us to handle this new class in exhaustive `when` expressions. The inconvenient part is that when this sealed class is part of the public API of a library or shared module, adding a subtype is a breaking change because all modules that use exhaustive `when` need to cover one more possible type.
          - type: "question-multiple-answer"
            stepId: "lesson-15_sealed-sealed-classes-and-`when`-expressions-q1"
            question: "In which situations can a Kotlin `when` expression be exhaustive\
        \ without an `else` branch?"
            explanation: "A `when` used as an expression must be exhaustive. It’s exhaustive\
        \ without `else` when the compiler knows the full set of cases: all enum constants,\
        \ or all known subtypes of a sealed class/interface. Open/non-sealed hierarchies\
        \ are not finite to the compiler."
            repeatable: true
            answers:
              - "Matching an enum and listing all enum constants"
              - "Matching a sealed class and listing `is` checks for all its subtypes"
              - "Matching a sealed interface and listing `is` checks for all its implementations"
              - "Matching an open class and listing all currently known subclasses"
              - "Matching a non-sealed interface and listing its implementations"
            correct:
              - "Matching an enum and listing all enum constants"
              - "Matching a sealed class and listing `is` checks for all its subtypes"
              - "Matching a sealed interface and listing `is` checks for all its implementations"
          - type: "question-single-answer"
            stepId: "lesson-15_sealed-sealed-classes-and-`when`-expressions-q2"
            question: "A library exposes a sealed class used in client code with exhaustive\
        \ `when` expressions (no `else`). The library adds a new subtype in the next\
        \ release. What happens to clients?"
            explanation: "Adding a new subtype to a sealed hierarchy is a breaking change\
        \ for clients that rely on exhaustive `when` without `else`; their code will\
        \ stop compiling until they handle the new subtype."
            repeatable: true
            answers:
              - "Clients get compile errors where exhaustive `when` is used and must handle\
        \ the new subtype"
              - "No effect; clients keep compiling and running without changes"
              - "Clients only get a runtime crash if that `when` executes"
              - "Clients just need to recompile; no code changes required"
            correct: "Clients get compile errors where exhaustive `when` is used and must\
        \ handle the new subtype"
          - type: "text"
            stepId: "lesson-15_sealed-sealed-vs-enum-text"
            repeatable: false
            text: "Enum classes are used to represent a set of values. Sealed classes or\
        \ interfaces represent a set of subtypes that can be made with classes or\
        \ object declarations. This is a significant difference. A class is more than\
        \ a value. It can have many instances and can be a data holder. Think of `Response`:\
        \ if it were an enum class, it couldn't hold `value` or `error`. Sealed subclasses\
        \ can each store different data, whereas an enum is just a set of values."
          - type: "question-single-answer"
            stepId: "lesson-15_sealed-sealed-vs-enum-q1"
            question: "You need a closed set of response variants where each case can carry\
        \ different, per-instance data (e.g., Success(data: String) or Error(cause:\
        \ Throwable)). Which declaration best fits?"
            explanation: "Sealed types define a closed set of subtypes and each subtype\
        \ can hold its own data. Enum entries are singletons and cannot carry arbitrary\
        \ per-instance payload. An abstract (non-sealed) base class does not enforce\
        \ a closed set."
            repeatable: true
            answers:
              - "enum class Response { Success, Error }"
              - "enum class Response(val data: String?, val cause: Throwable?) { Success(null,\
        \ null), Error(null, null) }"
              - "sealed interface Response { data class Success(val data: String): Response;\
        \ data class Error(val cause: Throwable): Response }"
              - "abstract class Response { data class Success(val data: String): Response();\
        \ data class Error(val cause: Throwable): Response() }"
            correct: "sealed interface Response { data class Success(val data: String):\
        \ Response; data class Error(val cause: Throwable): Response }"
          - type: "question-multiple-answer"
            stepId: "lesson-15_sealed-sealed-vs-enum-q2"
            question: "Select all true statements about sealed classes/interfaces vs enum\
        \ classes in Kotlin:"
            explanation: "Enums model a fixed set of value singletons; you can't instantiate\
        \ new enum entries or give them per-instance payloads. Sealed hierarchies\
        \ are closed and their variants can carry different data."
            repeatable: true
            answers:
              - "Enum entries are singletons representing values, not instanceable data holders."
              - "Sealed types define a closed set of subtypes; each subtype can have its own\
        \ properties."
              - "You can create new enum instances at runtime with different payloads."
              - "Sealed classes are appropriate when each variant must store different data."
              - "Enum classes can be extended by regular classes to add more entries."
            correct:
              - "Enum entries are singletons representing values, not instanceable data holders."
              - "Sealed types define a closed set of subtypes; each subtype can have its own\
        \ properties."
              - "Sealed classes are appropriate when each variant must store different data."
          - type: "text"
            stepId: "lesson-15_sealed-use-cases-text"
            repeatable: false
            text: |-
              We use sealed classes whenever we want to express that there is a concrete number of subclasses of a class.
              
              ```kotlin
              sealed class MathOperation
              class Plus(val left: Int, val right: Int) : MathOperation()
              class Minus(val left: Int, val right: Int) : MathOperation()
              class Times(val left: Int, val right: Int) : MathOperation()
              class Divide(val left: Int, val right: Int) : MathOperation()
              
              sealed interface Tree
              class Leaf(val value: Any?) : Tree
              class Node(val left: Tree, val right: Tree) : Tree
              
              sealed interface Either<out L, out R>
              class Left<out L>(val value: L) : Either<L, Nothing>
              class Right<out R>(val value: R) : Either<Nothing, R>
              
              sealed interface AdView
              object FacebookAd : AdView
              object GoogleAd : AdView
              class OwnAd(val text: String, val imgUrl: String) : AdView
              ```
              
              The key benefit is that when-expression can easily cover all possible types in a hierarchy using is-checks. A when-condition with a sealed element as a value ensures the compiler performs exhaustive type checking, and our program can only represent valid states.
              
              ```kotlin
              fun BinaryTree.height(): Int = when (this) {
                  is Leaf -> 1
                  is Node -> maxOf(this.left.height(), this.right.height())
              }
              ```
              
              However, expressing that a hierarchy is restricted improves readability. Finally, when we use the `sealed` modifier, we can use reflection to find all the subclasses:
              
              ```kotlin
              sealed interface Parent
              class A : Parent
              class B : Parent
              class C : Parent
              
              fun main() {
                  println(Parent::class.sealedSubclasses)
                  // [class A, class B, class C]
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-15_sealed-use-cases-q1"
            question: "Which statements about Kotlin sealed hierarchies and when-expressions\
        \ are correct?"
            explanation: |-
              - When matching on a sealed type, the compiler can verify exhaustiveness without else if you handle all known implementations.
              - Adding a new implementation can make previously exhaustive when-expressions fail to compile until updated.
              - Sealed interfaces/classes can be implemented by objects and regular classes.
              - sealedSubclasses returns KClass entries, not instances.
            repeatable: true
            answers:
              - "A when over a sealed type can be exhaustive without else by handling all\
        \ known implementations."
              - "Adding a new implementation to a sealed hierarchy can break compilation of\
        \ a previously exhaustive when without else."
              - "object singletons and regular classes can implement a sealed interface."
              - "KClass.sealedSubclasses returns the instances of all implementations at runtime."
            correct:
              - "A when over a sealed type can be exhaustive without else by handling all\
        \ known implementations."
              - "Adding a new implementation to a sealed hierarchy can break compilation of\
        \ a previously exhaustive when without else."
              - "object singletons and regular classes can implement a sealed interface."
          - type: "question-exact-text"
            stepId: "lesson-15_sealed-use-cases-q2"
            question: "What is the KClass property that lists all known subclasses of a\
        \ sealed class or interface?"
            explanation: "Use KClass.sealedSubclasses to obtain the known direct subclasses\
        \ as KClass values."
            repeatable: false
            correct:
              - "sealedSubclasses"
          - type: "text"
            stepId: "lesson-15_sealed-summary-text"
            repeatable: false
            text: |-
              Sealed classes and interfaces should be used to represent restricted hierarchies. The when-statement makes it easier to handle each possible sealed subtype and, as a result, to add new methods to sealed elements using extension functions. Abstract classes leave space for new classes to join this hierarchy. If we want to control what the subclasses of a class are, we should use the `sealed` modifier.
              
              Next, we will talk about the last special kind of class that is used to add extra information about our code elements: annotations.
          - type: "question-single-answer"
            stepId: "lesson-15_sealed-summary-q1"
            question: |-
              Consider:
              
              ```kotlin
              abstract class Expr
              class Num(val n: Int) : Expr()
              class Sum(val a: Expr, val b: Expr) : Expr()
              
              fun eval(e: Expr): Int = when (e) {
                  is Num -> e.n
                  is Sum -> eval(e.a) + eval(e.b)
                  // no else
              }
              ```
              This fails to compile because the `when` is not exhaustive. What single change lets it compile without adding an `else` branch?
            explanation: "Sealed classes/interfaces restrict the hierarchy, so the compiler\
        \ knows all subtypes and can verify `when` exhaustiveness without `else`.\
        \ `abstract`/`open` don’t provide this guarantee; data classes are unrelated."
            repeatable: true
            answers:
              - "Change `Expr` to `sealed class Expr`"
              - "Change `Expr` to `open class Expr`"
              - "Make `Num` and `Sum` data classes"
              - "Add an `else` branch"
            correct: "Change `Expr` to `sealed class Expr`"
          - type: "question-multiple-answer"
            stepId: "lesson-15_sealed-summary-q2"
            question: "Which statements about sealed classes/interfaces are true?"
            explanation: "Sealed types model restricted hierarchies and allow exhaustive\
        \ `when` without `else`. They don’t auto-generate data-class functionality,\
        \ aren’t equivalent to enums, and don’t allow subclassing from anywhere."
            repeatable: false
            answers:
              - "They restrict which classes can inherit from them."
              - "They enable `when` expressions to be exhaustive without `else` when all subtypes\
        \ are covered."
              - "They automatically provide `equals/hashCode` and `copy` like data classes."
              - "They are equivalent to enums; each subclass is a singleton instance."
              - "They guarantee new subclasses can be added anywhere in the project."
            correct:
              - "They restrict which classes can inherit from them."
              - "They enable `when` expressions to be exhaustive without `else` when all subtypes\
        \ are covered."
      - lessonId: "lesson-annotation-classes"
        name: "Annotation classes"
        steps:
          - type: "text"
            stepId: "lesson-16_annotations-#-annotation-classes-text"
            repeatable: false
            text: |-
              Another special kind of class in Kotlin is annotations, which we use to provide additional information about an element. Here is an example class that uses the `JvmField`, `JvmStatic`, and `Throws` annotations.
              
              ```kotlin
              import java.math.BigDecimal
              import java.math.MathContext
              
              class Money(
                  val amount: BigDecimal,
                  val currency: String,
              ) {
                  @Throws(IllegalArgumentException::class)
                  operator fun plus(other: Money): Money {
                      require(currency == other.currency)
                      return Money(amount + other.amount, currency)
                  }
              
                  companion object {
                      @JvmField
                      val MATH = MathContext(2)
              
                      @JvmStatic
                      fun eur(amount: Double) =
                          Money(amount.toBigDecimal(MATH), "EUR")
              
                      @JvmStatic
                      fun usd(amount: Double) =
                          Money(amount.toBigDecimal(MATH), "USD")
              
                      @JvmStatic
                      fun pln(amount: Double) =
                          Money(amount.toBigDecimal(MATH), "PLN")
                  }
              }
              ```
              
              You can also define your own annotations. This is an example of annotation declaration and usage:
              
              ```kotlin
              annotation class Factory
              annotation class FactoryFunction(val name: String)
              
              @Factory
              class CarFactory {
              
                  @FactoryFunction(name = "toyota")
                  fun makeToyota(): Car = Toyota()
              
                  @FactoryFunction(name = "skoda")
                  fun makeSkoda(): Car = Skoda()
              }
              
              abstract class Car
              class Toyota : Car()
              class Skoda : Car()
              ```
              
              You might be asking yourself what these annotations do. The answer is surprisingly simple: absolutely nothing. Annotations, by themselves, are not active and do not change how our code works. They only hold information. However, many libraries depend on annotations and behave according to what we specify with them.
              
              Many important libraries use a mechanism called *annotation processing*. How it works is simple: there are classes called *annotation processors* that are running when we build our code. They analyze our code and generate extra code. They generally strongly depend on annotations. This new code is not part of our project sources, but we can access it once it has been generated. This fact is used by libraries that use annotation processing. So, take a look at this class, which uses the Java `Mockito` library with an annotation processor:
              
              ```kotlin
              class DoctorServiceTest {
              
                  @Mock
                  lateinit var doctorRepository: DoctorRepository
              
                  lateinit var doctorService: DoctorService
              
                  @Before
                  fun init() {
                      MockitoAnnotations.initMocks(this)
                      doctorService = DoctorService(doctorRepository)
                  }
              
                  // ...
              }
              ```
              
              The `doctorRepository` property is annotated as `Mock`, which is interpreted by the Mock processor so that this variable can get a mock value. This processor generates a class that creates and sets a value for the `doctorRepository` property in `DoctorServiceTest`. Of course, this generated class will not work by itself as it needs to be started. This is what `MockitoAnnotations.initMocks(this)` is for: it uses reflection to call this generated class.
              
              Annotation processing is better described in *Advanced Kotlin*, in the *Annotation Processing* chapter.
          - type: "question-multiple-answer"
            stepId: "lesson-16_annotations-#-annotation-classes-q1"
            question: "Based on the section, which statements are true about annotations\
        \ and annotation processing?"
            explanation: "Annotations hold metadata only. Processors run at build time to\
        \ generate code. Libraries like Mockito then use reflection (e.g., initMocks)\
        \ to invoke that generated code. Generated code is not part of your sources,\
        \ and @Mock requires initialization."
            repeatable: true
            answers:
              - "Annotations by themselves do not change how code works; they only hold metadata."
              - "Annotation processors analyze code during build and can generate additional\
        \ code."
              - "Generated code is added to your project sources and must be committed."
              - "Some libraries use reflection at runtime to invoke code generated during\
        \ annotation processing."
              - "Annotating a property with @Mock automatically assigns it a mock at runtime\
        \ without any extra setup."
            correct:
              - "Annotations by themselves do not change how code works; they only hold metadata."
              - "Annotation processors analyze code during build and can generate additional\
        \ code."
              - "Some libraries use reflection at runtime to invoke code generated during\
        \ annotation processing."
          - type: "question-single-answer"
            stepId: "lesson-16_annotations-#-annotation-classes-q2"
            question: "Which pair correctly declares a Kotlin annotation with a required\
        \ String parameter and uses it on a function?"
            explanation: "Annotation parameters must be val properties with matching types;\
        \ usage can pass a positional argument. Options 2 (no val), 3 (var not allowed),\
        \ and 4 (type mismatch) are invalid."
            repeatable: false
            answers:
              - |-
                ```
                annotation class Label(val value: String)
                @Label("abc") fun f() {}
                ```
              - |-
                ```
                annotation class Label(value: String)
                @Label("abc") fun f() {}
                ```
              - |-
                ```
                annotation class Label(var value: String)
                @Label("abc") fun f() {}
                ```
              - |-
                ```
                annotation class Label(val value: Int)
                @Label("abc") fun f() {}
                ```
            correct: |-
              ```
              annotation class Label(val value: String)
              @Label("abc") fun f() {}
              ```
          - type: "text"
            stepId: "lesson-16_annotations-meta-annotations-text"
            repeatable: false
            text: |-
              Annotations that are used to annotate other annotations are known as meta-annotations. There are four key meta-annotations from Kotlin stdlib:
              * `Target` indicates the kinds of code elements that are possible targets of an annotation. As arguments, it accepts `AnnotationTarget` enum values, which include values like `CLASS`, `PROPERTY`, `FUNCTION`, etc.
              * `Retention` determines whether an annotation is stored in the binary output of compilation and is visible for reflection. By default, both are true.
              * `Repeatable` determines that an annotation is applicable twice or more in a single code element.
              * `MustBeDocumented` determines that an annotation is part of a public API and should therefore be included in the generated documentation for the element to which the annotation is applied.
              
              Here are example usages of some of these annotations:
              
              ```kotlin
              @MustBeDocumented
              @Target(AnnotationTarget.CLASS)
              annotation class Factory
              
              @Repeatable
              @Target(AnnotationTarget.FUNCTION)
              annotation class FactoryFunction(val name: String)
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-16_annotations-meta-annotations-q1"
            question: |-
              Given these declarations:
              
              ```kotlin
              @MustBeDocumented
              @Target(AnnotationTarget.CLASS)
              annotation class Factory
              
              @Repeatable
              @Target(AnnotationTarget.FUNCTION)
              annotation class FactoryFunction(val name: String)
              ```
              
              Which snippets compile?
            explanation: "Factory targets classes only; FactoryFunction targets functions\
        \ and is repeatable. So applying Factory to a class and FactoryFunction to\
        \ a function (even multiple times) compiles; using them on unsupported targets\
        \ does not."
            repeatable: true
            answers:
              - |-
                ```kotlin
                @Factory
                class A
                ```
              - |-
                ```kotlin
                @FactoryFunction("foo")
                fun build() {}
                ```
              - |-
                ```kotlin
                @FactoryFunction("a")
                @FactoryFunction("b")
                fun build() {}
                ```
              - |-
                ```kotlin
                @Factory
                fun build() {}
                ```
              - |-
                ```kotlin
                @FactoryFunction("x")
                class B
                ```
            correct:
              - |-
                ```kotlin
                @Factory
                class A
                ```
              - |-
                ```kotlin
                @FactoryFunction("foo")
                fun build() {}
                ```
              - |-
                ```kotlin
                @FactoryFunction("a")
                @FactoryFunction("b")
                fun build() {}
                ```
          - type: "question-single-answer"
            stepId: "lesson-16_annotations-meta-annotations-q2"
            question: "Which retention makes an annotation stored in the class file but\
        \ not visible via reflection?"
            explanation: "AnnotationRetention.BINARY stores the annotation in the binary\
        \ (.class) but it is not retained at runtime. SOURCE drops it before bytecode;\
        \ RUNTIME keeps it for reflection; the Kotlin default is effectively RUNTIME\
        \ per the text."
            repeatable: true
            answers:
              - "@Retention(AnnotationRetention.SOURCE)"
              - "@Retention(AnnotationRetention.BINARY)"
              - "@Retention(AnnotationRetention.RUNTIME)"
              - "No @Retention specified (default)"
            correct: "@Retention(AnnotationRetention.BINARY)"
          - type: "text"
            stepId: "lesson-16_annotations-annotating-the-primary-constructor-text"
            repeatable: false
            text: |-
              To annotate the primary constructor, it is necessary to use the `constructor` keyword as part of its definition, before the parentheses.
              
              ```kotlin
              // JvmOverloads annotates primary constructor
              class User @JvmOverloads constructor(
                  val name: String,
                  val surname: String,
                  val age: Int = -1,
              )
              ```
          - type: "question-single-answer"
            stepId: "lesson-16_annotations-annotating-the-primary-constructor-q1"
            question: "Which snippet correctly annotates the primary constructor (not the\
        \ class or its parameters) with @JvmOverloads?"
            explanation: "To annotate the primary constructor, place the annotation before\
        \ the explicit constructor keyword. Placing it before the class annotates\
        \ the class; on a parameter annotates that parameter; after the class name\
        \ is invalid."
            repeatable: false
            answers:
              - "@JvmOverloads class User(val name: String, val age: Int = -1)"
              - "class User @JvmOverloads constructor(val name: String, val age: Int = -1)"
              - "class @JvmOverloads User(val name: String, val age: Int = -1)"
              - "class User(val name: @JvmOverloads String, val age: Int = -1)"
            correct: "class User @JvmOverloads constructor(val name: String, val age: Int\
        \ = -1)"
          - type: "question-multiple-answer"
            stepId: "lesson-16_annotations-annotating-the-primary-constructor-q2"
            question: |-
              Given:
              
              ```kotlin
              class User @JvmOverloads constructor(
                  val name: String,
                  val surname: String,
                  val age: Int = -1,
              )
              ```
              Which statements are true on the JVM?
            explanation: "@JvmOverloads on the primary constructor generates overloads omitting\
        \ trailing defaulted parameters only. Here it adds User(String, String). Annotating\
        \ the class or a parameter does not affect constructor overloads, and no no-arg\
        \ constructor is generated."
            repeatable: false
            answers:
              - "Java sees two constructors: User(String, String) and User(String, String,\
        \ int)."
              - "Java also sees a no-arg constructor because Kotlin default values fill all\
        \ parameters."
              - "Only trailing default parameters produce overloads; here at most one extra\
        \ constructor is generated."
              - "Placing @JvmOverloads before the class keyword has the same effect as annotating\
        \ the primary constructor."
              - "Annotating a parameter with @JvmOverloads generates the same constructor\
        \ overloads."
            correct:
              - "Java sees two constructors: User(String, String) and User(String, String,\
        \ int)."
              - "Only trailing default parameters produce overloads; here at most one extra\
        \ constructor is generated."
          - type: "text"
            stepId: "lesson-16_annotations-list-literals-text"
            repeatable: false
            text: |-
              When we specify an annotation with an array value, we can use a special syntax called "array literal". This means that instead of using `arrayOf`, we can declare an array using square brackets.
              
              ```kotlin
              annotation class AnnotationWithList(
                  val elements: Array<String>
              )
              
              @AnnotationWithList(["A", "B", "C"])
              val str1 = "ABC"
              
              @AnnotationWithList(elements = ["D", "E"])
              val str2 = "ABC"
              
              @AnnotationWithList(arrayOf("F", "G"))
              val str3 = "ABC"
              ```
              
              This notation is only allowed for annotations and does not work for defining arrays in any other context in our code.
          - type: "question-multiple-answer"
            stepId: "lesson-16_annotations-list-literals-q1"
            question: |-
              Given:
              
              ```kotlin
              annotation class Tags(val value: Array<String>)
              ```
              
              Which of the following snippets compile?
            explanation: "The square-bracket array literal is a special syntax only for\
        \ annotation arguments. Both `[...]` and `arrayOf(...)` are valid in annotation\
        \ arguments for array-typed parameters. `listOf(...)` is not an `Array<String>`,\
        \ and `[...]` cannot be used to create arrays in regular code."
            repeatable: true
            answers:
              - "@Tags([\"a\", \"b\"])"
              - "@Tags(value = [\"x\"])"
              - "@Tags(arrayOf(\"u\", \"v\"))"
              - "val xs = [\"a\", \"b\"]"
              - "@Tags(listOf(\"a\", \"b\"))"
            correct:
              - "@Tags([\"a\", \"b\"])"
              - "@Tags(value = [\"x\"])"
              - "@Tags(arrayOf(\"u\", \"v\"))"
          - type: "question-single-answer"
            stepId: "lesson-16_annotations-list-literals-q2"
            question: "Where in Kotlin can you use the square-bracket array literal syntax\
        \ `[\"A\", \"B\"]`?"
            explanation: "The array literal with square brackets is a Kotlin-only convenience\
        \ for annotation arguments with array-typed parameters; it is not a general\
        \ array constructor."
            repeatable: false
            answers:
              - "Only in annotation arguments for array-typed parameters"
              - "Anywhere arrays are constructed, as an alternative to arrayOf"
              - "Only in Java interop code"
              - "In both annotation arguments and normal array declarations"
            correct: "Only in annotation arguments for array-typed parameters"
          - type: "text"
            stepId: "lesson-16_annotations-summary-text"
            repeatable: false
            text: |-
              Annotations are used to describe our code. They might be interpreted by annotation processors or by classes using runtime reflection. Tools and libraries use this to automate some actions for us. Annotations by themselves are a simple feature, but the possibilities offered by them are amazing.
              
              Let's now move on to a famous Kotlin feature that gives us the ability to extend any type with methods or properties: extensions.
          - type: "question-multiple-answer"
            stepId: "lesson-16_annotations-summary-q1"
            question: "Which statements about Kotlin annotations are correct according to\
        \ the summary?"
            explanation: "Annotations describe code and can be interpreted by annotation\
        \ processors (compile-time) or via runtime reflection. They do nothing by\
        \ themselves; tools/libraries act on them to automate actions."
            repeatable: false
            answers:
              - "They are used to describe code."
              - "They can be processed by annotation processors."
              - "They always change program behavior by themselves."
              - "They can be interpreted via runtime reflection."
              - "Tools and libraries use them to automate actions."
            correct:
              - "They are used to describe code."
              - "They can be processed by annotation processors."
              - "They can be interpreted via runtime reflection."
              - "Tools and libraries use them to automate actions."
          - type: "question-exact-text"
            stepId: "lesson-16_annotations-summary-q2"
            question: "Name the Kotlin feature that lets you extend any type with methods\
        \ or properties."
            explanation: "Kotlin provides extensions—extension functions and properties—\
        to add functionality to existing types."
            repeatable: false
            correct:
              - "extensions"
              - "extension functions"
              - "extension functions and properties"
              - "extension"
      - lessonId: "lesson-extensions"
        name: "Extensions"
        steps:
          - type: "text"
            stepId: "lesson-17_extensions-#-extensions-text"
            repeatable: false
            text: |-
              The most intuitive way to define methods and properties is inside classes. Such elements are called **class members** or, more concretely, **member functions** and **member properties**.
              
              ```kotlin
              class Telephone(
                  // member property
                  val number: String
              ) {
                  // member function
                  fun call() {
                      print("Calling $number")
                  }
              }
              
              fun main() {
                  // Usage
                  val telephone = Telephone("123456789")
                  println(telephone.number) // 123456789
                  telephone.call() // Calling 123456789
              }
              ```
              
              On the other hand, Kotlin allows another way to define functions and properties that are called on an instance: extensions. **Extension functions** are defined like regular functions, but they additionally have an extra type (and dot) before the function name. In the example below, the `call` function is defined as an extension function on `Telephone`, so it needs to be called on an instance of this type.
              
              ```kotlin
              class Telephone(
                  val number: String
              )
              
              fun Telephone.call() {
                  print("Calling $number")
              }
              
              fun main() {
                  // Usage
                  val telephone = Telephone("123456789")
                  telephone.call() // Calling 123456789
              }
              ```
              
              > Both member functions and extension functions are referred to as methods.
              
              Extension functions can be defined on types we don’t control, for instance `String`. This gives us the power to extend external APIs with our own functions.
              
              ```kotlin
              fun String.remove(value: String) = this.replace(value, "")
              
              fun main() {
                  println("Who Framed Roger Rabbit?".remove(" "))
                  // WhoFramedRogerRabbit?
              }
              ```
              
              Take a look at the example above. We defined the extension function `remove` on `String`, so we need to call this function on an object of type `String`. Inside the function, we reference this object using the `this` keyword, just like inside member functions. The `this` keyword can also be used implicitly.
              
              ```kotlin
              // explicit this
              fun String.remove(value: String) = this.replace(value, "")
              
              // implicit this
              fun String.remove(value: String) = replace(value, "")
              ```
              
              The `this` keyword is known as the **receiver**. Inside extension functions, we call it an **extension receiver**. Inside member functions, we call it a **dispatch receiver**. The type we extend with the extension function is called the **receiver type**.
              
              ![](207_receiver_type.png)
              
              Extension functions behave a lot like member functions. When developers learn this, they are often concerned about objects' safety, but this isn’t a problem as extensions do not have any special access to class elements. The only difference between top-level extension functions and other top-level functions is that they are called on an instance instead of receiving this instance as a regular argument. To see this more clearly, let's take a look under the hood of extension functions.
          - type: "question-multiple-answer"
            stepId: "lesson-17_extensions-#-extensions-q1"
            question: "Which statements about Kotlin extension functions are true?"
            explanation: "Extensions can be added to external types and use the receiver\
        \ as this. They don’t gain special access to private members. Conceptually,\
        \ a top-level extension differs from a regular top-level function only in\
        \ call-site syntax: the receiver is passed implicitly."
            repeatable: true
            answers:
              - "They can be defined for types you don’t control (e.g., String)."
              - "Inside an extension on T, this refers to the receiver instance of type T."
              - "They can access private members of the receiver type."
              - "Compared to other top-level functions, the only difference is call-site syntax:\
        \ the receiver is passed implicitly instead of as a regular parameter."
              - "They must be declared inside the class being extended."
            correct:
              - "They can be defined for types you don’t control (e.g., String)."
              - "Inside an extension on T, this refers to the receiver instance of type T."
              - "Compared to other top-level functions, the only difference is call-site syntax:\
        \ the receiver is passed implicitly instead of as a regular parameter."
          - type: "question-single-answer"
            stepId: "lesson-17_extensions-#-extensions-q2"
            question: |-
              Which declaration makes the following print WhoFramedRogerRabbit?
              
              ```kotlin
              println("Who Framed Roger Rabbit?".remove(" "))
              ```
            explanation: "A is a proper extension returning the new String. B is not an\
        \ extension; C returns Unit; D is not how you extend String and wouldn’t apply\
        \ to string literals."
            repeatable: false
            answers:
              - "fun String.remove(value: String) = replace(value, \"\")"
              - "fun remove(str: String, value: String) = str.replace(value, \"\")"
              - "fun String.remove(value: String) { replace(value, \"\") }"
              - "class String { fun remove(value: String) = replace(value, \"\") }"
            correct: "fun String.remove(value: String) = replace(value, \"\")"
          - type: "text"
            stepId: "lesson-17_extensions-extension-functions-under-the-hood-text"
            repeatable: false
            text: |-
              To understand extension functions, let's again use "Tools > Kotlin > Show Kotlin bytecode" and "Decompile" (as explained in chapter *Your first program in Kotlin* in section *What is under the hood on JVM?*). We will compile and decompile to Java our `remove` function definition and its call:
              
              ```kotlin
              fun String.remove(value: String) = this.replace(value, "")
              
              fun main() {
                  println("A B C".remove(" ")) // ABC
              }
              ```
              
              As a result, you should see the following code:
              
              ```java
              public final class PlaygroundKt {
                  @NotNull
                  public static final String remove(
                          @NotNull String $this$remove,
                          @NotNull String value
                  ) {
                      // parameters not-null checks
                      return StringsKt.replace$default(
                              $this$remove,
                              value,
                              ""
                              // plus default values
                      );
                  }
              
                  public static final void main(@NotNull String[] args) {
                      // parameter not-null check
                      String var1 = remove("A B C", " ");
                      System.out.println(var1);
                  }
              }
              ```
              
              Notice what happened to the receiver type: it became a parameter. You can also see that, under the hood, `remove` is not called on an object. It is just a regular static function.
              
              When you define an extension function, you do not really add anything to a class. It is just syntactic sugar. Let's compare the two following implementations of `remove`.
              
              ```kotlin
              fun remove(text: String, value: String) = text.replace(value, "")
              
              fun String.remove(value: String) = this.replace(value, "")
              ```
              
              Under the hood, they are nearly identical. The difference is in how Kotlin expects them to be called. Regular functions receive all their arguments in regular argument positions. Extension functions are called "on" a value.
          - type: "question-single-answer"
            stepId: "lesson-17_extensions-extension-functions-under-the-hood-q1"
            question: |-
              Given a Kotlin file named `Playground.kt` containing:
              
              ```kotlin
              fun String.remove(value: String): String = this.replace(value, "")
              ```
              Which Java declaration most closely matches the decompiled form?
            explanation: "Extension functions compile to static methods in the file’s class,\
        \ with the receiver as the first parameter."
            repeatable: true
            answers:
              - "public final class PlaygroundKt { public static String remove(String $this$remove,\
        \ String value) { ... } }"
              - "public final class String { public String remove(String value) { ... } }"
              - "public final class PlaygroundKt { public String remove(String receiver, String\
        \ value) { ... } }"
              - "public interface StringExtensions { static String remove(String receiver,\
        \ String value); }"
            correct: "public final class PlaygroundKt { public static String remove(String\
        \ $this$remove, String value) { ... } }"
          - type: "question-multiple-answer"
            stepId: "lesson-17_extensions-extension-functions-under-the-hood-q2"
            question: "Select all true statements about Kotlin extension functions under\
        \ the hood on the JVM:"
            explanation: "Extensions are syntactic sugar: compiled as static methods on\
        \ the file class, with the receiver passed as the first argument. They do\
        \ not modify or extend the receiver class."
            repeatable: true
            answers:
              - "The receiver object becomes a regular parameter of the generated static method."
              - "The extension function is invoked as a static method; it is not actually\
        \ called on the instance at bytecode level."
              - "Defining an extension function adds a new method to the receiver class at\
        \ runtime."
              - "A top-level function `fun remove(text: String, value: String)` produces nearly\
        \ the same bytecode as `fun String.remove(value: String)`."
              - "The compiler generates a subclass of the receiver type to host the new method."
            correct:
              - "The receiver object becomes a regular parameter of the generated static method."
              - "The extension function is invoked as a static method; it is not actually\
        \ called on the instance at bytecode level."
              - "A top-level function `fun remove(text: String, value: String)` produces nearly\
        \ the same bytecode as `fun String.remove(value: String)`."
          - type: "text"
            stepId: "lesson-17_extensions-extension-properties-text"
            repeatable: false
            text: |-
              An extension cannot hold a state, so it cannot have fields. Although properties do not need fields, they can be defined by their getters and setters. This is why we can define extension properties if they do not need a backing field and are defined by accessors.
              
              ```kotlin
              val <T> List<T>.lastIndex: Int
                  get() = size - 1
              ```
              
              Extension properties are very popular on Android, where accessing different services is complex and repetitive. Defining extension properties lets us do this much more easily.
              
              ```kotlin
              val Context.inflater: LayoutInflater
                  get() = getSystemService(Context.LAYOUT_INFLATER_SERVICE)
                      as LayoutInflater
              
              val Context.notificationManager: NotificationManager
                  get() = getSystemService(Context.NOTIFICATION_SERVICE)
                      as NotificationManager
              
              val Context.alarmManager: AlarmManager
                  get() = getSystemService(Context.ALARM_SERVICE)
                      as AlarmManager
              ```
              
              Extension properties can define both a getter and a setter. Here is an extension property that provides a different representation of a user birthdate:
              
              ```kotlin
              class User {
                  // ...
                  var birthdateMillis: Long? = null
              }
              
              var User.birthdate: Date?
                  get() {
                      val millis = birthdateMillis
                      return if (millis == null) null else Date(millis)
                  }
                  set(value) {
                      birthdateMillis = value?.time
                  }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-17_extensions-extension-properties-q1"
            question: "Which of the following Kotlin extension property declarations compile?"
            explanation: "Extension properties cannot have backing fields or initializers;\
        \ they must be defined via accessors. Using `field` is illegal in extension\
        \ accessors."
            repeatable: true
            answers:
              - "val <T> List<T>.lastIndex: Int get() = size - 1"
              - "var StringBuilder.lastChar: Char get() = this[length - 1] set(value) { this.setCharAt(length\
        \ - 1, value) }"
              - "val String.lengthInDouble: Double = length.toDouble()"
              - "var List<Int>.sum: Int get() = fold(0) { acc, e -> acc + e } set(value) {\
        \ field = value }"
              - "val Context.inflater: LayoutInflater get() = getSystemService(Context.LAYOUT_INFLATER_SERVICE)\
        \ as LayoutInflater"
            correct:
              - "val <T> List<T>.lastIndex: Int get() = size - 1"
              - "var StringBuilder.lastChar: Char get() = this[length - 1] set(value) { this.setCharAt(length\
        \ - 1, value) }"
              - "val Context.inflater: LayoutInflater get() = getSystemService(Context.LAYOUT_INFLATER_SERVICE)\
        \ as LayoutInflater"
          - type: "question-single-answer"
            stepId: "lesson-17_extensions-extension-properties-q2"
            question: "Which statement about Kotlin extension properties is true?"
            explanation: "Extensions cannot store state; they only provide syntactic sugar\
        \ over functions via accessors. No backing fields are possible, so `field`\
        \ cannot be used."
            repeatable: false
            answers:
              - "They can have backing fields and use `field` in accessors."
              - "They must be declared inside the class they extend."
              - "They can have custom getters/setters but cannot store state."
              - "A `val` extension property can have a setter if the receiver is mutable."
            correct: "They can have custom getters/setters but cannot store state."
          - type: "text"
            stepId: "lesson-17_extensions-extensions-vs-members-text"
            repeatable: false
            text: |-
              The biggest difference between members and extensions in terms of use is that **extensions need to be imported separately**. For this reason, they can be located in a different package. This fact is used when we cannot add a member ourselves. It is also used in projects designed to separate data and behavior. Properties with fields need to be located in a class, but methods can be located separately as long as they only access the public API of the class.
              
              Thanks to the fact that extensions need to be imported, we can have many extensions with the same name for the same type. This is good because different libraries can provide extra methods without causing a conflict. On the other hand, it would be dangerous to have two extensions with the same name but different behaviors. If you have such a situation, it is a code smell and is a clue that someone has abused the extension function capability.
              
              Another significant difference is that **extensions are not virtual**, meaning that they cannot be redefined in derived classes. This is why if you have an extension defined on both a supertype and a subtype, the compiler decides which function is chosen based on how the variable is typed, not what its actual class is.
              
              ```kotlin
              open class View
              class Button : View()
              
              fun View.printMe() {
                  println("I'm a View")
              }
              
              fun Button.printMe() {
                  println("I'm a Button")
              }
              
              fun main() {
                  val button: Button = Button()
                  button.printMe() // I'm a Button
                  val view: View = button
                  view.printMe() // I'm a View
              }
              ```
              
              The behavior of extension functions is different from member functions. Member functions are *virtual*, so up-casting the type of an object does not influence which member function is chosen.
              
              ```kotlin
              open class View {
                 open fun printMe() {
                     println("I'm a View")
                 }
              }
              class Button: View() {
                 override fun printMe() {
                     println("I'm a Button")
                 }
              }
              
              fun main() {
                 val button: Button = Button()
                 button.printMe() // I'm a Button
                 val view: View = button
                 view.printMe() // I'm a Button
              }
              ```
              
              This behavior is the result of the fact that extension functions are compiled under the hood into normal functions in which the extension’s receiver is placed as the first argument:
              
              ```kotlin
              open class View
              class Button : View()
              
              fun printMe(view: View) {
                  println("I'm a View")
              }
              
              fun printMe(button: Button) {
                  println("I'm a Button")
              }
              
              fun main() {
                  val button: Button = Button()
                  printMe(button) // I'm a Button
                  val view: View = button
                  printMe(view) // I'm a View
              }
              ```
              
              Another consequence of what extensions are under the hood is that **we define extensions on types, not on classes**. This gives us more freedom. For instance, we can define an extension on a nullable or generic type:
              
              ```kotlin
              inline fun CharSequence?.isNullOrBlank(): Boolean {
                  // (skipped contract definition)
                  return this == null || this.isBlank()
              }
              
              fun Iterable<Int>.sum(): Int {
                  var sum: Int = 0
                  for (element in this) {
                      sum += element
                  }
                  return sum
              }
              ```
              
              The last important difference is that **extensions are not listed as members in the class reference**. This is why they are not considered by annotation processors; it is also why, when we process a class using annotation processing, we cannot extract elements that should be processed into extensions. On the other hand, if we extract non-essential elements into extensions, we don’t need to worry about them being seen by those processors. We don’t need to hide them because they are not in the class they extend anyway.
          - type: "question-multiple-answer"
            stepId: "lesson-17_extensions-extensions-vs-members-q1"
            question: "Which statements about Kotlin extensions vs members are correct?\
        \ Choose all that apply."
            explanation: "Extensions are statically resolved, can target types (including\
        \ nullable/generic), need explicit imports across packages, and aren’t class\
        \ members; they are not virtual."
            repeatable: true
            answers:
              - "Extension dispatch is based on the variable’s static type, not the runtime\
        \ type."
              - "Extensions can be defined on nullable or generic types (e.g., `String?`,\
        \ `Iterable<T>`)."
              - "Extensions are not listed as class members and are generally ignored by annotation\
        \ processors targeting the class."
              - "Extensions from other packages must be imported explicitly; members don’\
        t require a separate import beyond the class."
              - "Extensions are virtual and can be overridden in subclasses."
            correct:
              - "Extension dispatch is based on the variable’s static type, not the runtime\
        \ type."
              - "Extensions can be defined on nullable or generic types (e.g., `String?`,\
        \ `Iterable<T>`)."
              - "Extensions are not listed as class members and are generally ignored by annotation\
        \ processors targeting the class."
              - "Extensions from other packages must be imported explicitly; members don’\
        t require a separate import beyond the class."
          - type: "question-single-answer"
            stepId: "lesson-17_extensions-extensions-vs-members-q2"
            question: |-
              What does this program print?
              
              ```kotlin
              open class View
              class Button : View()
              
              fun View.kind() = "View"
              fun Button.kind() = "Button"
              
              fun main() {
                  val b: Button = Button()
                  val v: View = b
                  println("${b.kind()} / ${v.kind()}")
              }
              ```
            explanation: "Extension functions are resolved by the static type of the receiver:\
        \ `b` is `Button`, `v` is `View` (even though it holds a `Button`)."
            repeatable: true
            answers:
              - "Button / View"
              - "Button / Button"
              - "View / View"
              - "View / Button"
            correct: "Button / View"
          - type: "text"
            stepId: "lesson-17_extensions-extension-functions-on-object-declarations-text"
            repeatable: false
            text: |-
              We can define extensions on object declarations.
              
              ```kotlin
              object A
              
              fun A.foo() {}
              
              fun main() {
                  A.foo()
              
                  val a: A = A
                  a.foo()
              }
              ```
              
              To define an extension function on a companion object, we need to use the companion object's real name. If this name is not set explicitly, the default one is "Companion". To define an extension function on a companion object, this companion object must exist. This is why some classes define companion objects without bodies.
              
              ```kotlin
              class A {
                  companion object
              }
              
              fun A.Companion.foo() {}
              
              fun main() {
                  A.foo()
              
                  val a: A.Companion = A
                  a.foo()
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-17_extensions-extension-functions-on-object-declarations-q1"
            question: |-
              Given:
              
              ```kotlin
              class A { companion object Named }
              ```
              Which declaration correctly defines an extension so it can be invoked as `A.foo()`?
            explanation: "You must extend the companion object's real name. With a named\
        \ companion `Named`, the correct receiver is `A.Named`. Calling via `A.foo()`\
        \ works because companion members/extensions are accessible through the class\
        \ name."
            repeatable: true
            answers:
              - "fun A.Companion.foo() {}"
              - "fun A.Named.foo() {}"
              - "fun Named.foo() {}"
              - "fun A.foo() {}"
            correct: "fun A.Named.foo() {}"
          - type: "question-multiple-answer"
            stepId: "lesson-17_extensions-extension-functions-on-object-declarations-q2"
            question: |-
              Given:
              
              ```kotlin
              object O
              fun O.bar() {}
              
              class C { companion object }
              fun C.Companion.baz() {}
              ```
              Which lines compile? Choose all that apply.
            explanation: "`O` is an object, so its extension is called as `O.bar()`. `C`\
        \ has a companion, so an extension on `C.Companion` can be called via both\
        \ `C.baz()` and `C.Companion.baz()`. The value `C` denotes the companion object,\
        \ so `val comp: C.Companion = C` compiles, but `val r: C = C` does not."
            repeatable: false
            answers:
              - "O.bar()"
              - "C.baz()"
              - "C.Companion.baz()"
              - "val r: C = C"
              - "val comp: C.Companion = C"
            correct:
              - "O.bar()"
              - "C.baz()"
              - "C.Companion.baz()"
              - "val comp: C.Companion = C"
          - type: "text"
            stepId: "lesson-17_extensions-member-extension-functions-text"
            repeatable: false
            text: "It is possible to define extension functions inside classes. Such functions\
        \ are known as **member extension functions**.\n\n```kotlin\nclass Telephone\
        \ {\n    fun String.call() { \n        // ...\n    }\n}\n```\n\nMember extension\
        \ functions are considered a code smell, and we should avoid using them if\
        \ we don’t have a good reason. For a deeper explanation, see *Effective Kotlin*,\
        \ *Item 46: Avoid member extensions*."
          - type: "question-single-answer"
            stepId: "lesson-17_extensions-member-extension-functions-q1"
            question: |-
              Given:
              
              ```kotlin
              class Telephone {
                  fun String.call() { /* ... */ }
              }
              ```
              Which statement is correct?
            explanation: "`fun String.call()` inside a class is a member extension function.\
        \ The book advises avoiding member extensions unless you have a good reason."
            repeatable: false
            answers:
              - "It defines a member extension function; such functions are generally a code\
        \ smell unless justified."
              - "It defines a regular member function on String that is visible globally."
              - "It defines a top-level extension on String in the Telephone package."
              - "Member extension functions are the recommended way to declare extensions\
        \ in Kotlin."
            correct: "It defines a member extension function; such functions are generally\
        \ a code smell unless justified."
          - type: "text"
            stepId: "lesson-17_extensions-use-cases-text"
            repeatable: false
            text: |-
              The most important use-case for extensions is adding methods and properties to APIs that we don't control. A good example is displaying a toast or hiding a view on Android. Both these operations are unnecessarily complicated, so we like to define extensions to simplify them.
              
              ```kotlin
              fun Context.toast(message: String) {
                  Toast.makeText(this, message, Toast.LENGTH_LONG).show()
              }
              
              fun View.hide() {
                  this.visibility = View.GONE
              }
              ```
              
              However, there are also cases where we prefer to use extensions instead of members. Consider the `Iterable` interface, which has only one member function, `iterator`; however, it has many methods, which are defined in the standard library as extensions, like `onEach` or `joinToString`. The fact that these are defined as extensions allows for smaller and more concise interfaces.
              
              ```kotlin
              interface Iterable<out T> {
                  operator fun iterator(): Iterator<T>
              }
              ```
              
              ![](iterable_methods.png)
              
              Extension functions are also more elastic than regular functions. This is mainly because they are defined on types, so we can define extensions on types like `Iterable<Int>` or `Iterable<T>`.
              
              ```kotlin
              fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {
                  if (this is Collection) {
                      if (size <= 1) return this.toList()
                      @Suppress("UNCHECKED_CAST")
                      return (toTypedArray<Comparable<T>>() as Array<T>)
                          .apply { sort() }
                          .asList()
                  }
                  return toMutableList().apply { sort() }
              }
              
              fun Iterable<Int>.sum(): Int {
                  var sum: Int = 0
                  for (element in this) {
                      sum += element
                  }
                  return sum
              }
              ```
              
              In bigger projects, we often have similar classes for different parts of our application. Let's say that you implement a backend for an online shop, and you have a class `Product` to represent all the products.
              
              ```kotlin
              import java.math.BigDecimal
              
              class Product(
                  val id: String,
                  val title: String,
                  val imgSrc: String,
                  val description: String,
                  val price: BigDecimal,
                  val type: ProductType,
                  // ...
              )
              ```
              
              You also have a similar (but not identical) class called `ProductJson`, which is used to represent the objects you use in your application API responses or that you read from API requests.
              
              ```kotlin
              class ProductJson(
                  val id: String,
                  val title: String,
                  val img: String,
                  val desc: String,
                  val price: String,
                  val type: String,
                  // ...
              )
              ```
              
              Instances of `Product` are used in your application, and instances of `ProductJson` are used in the API. These objects need to be separated because, for instance, you don’t want to change your API response when you change a property name in an internal class. Yet, we often need to transform between `Product` and `ProductJson`. For this, we could define a member function `toProduct`.
              
              ```kotlin
              class ProductJson(
                  val id: String,
                  val title: String,
                  val img: String,
                  val desc: String,
                  val price: String,
                  val type: String,
                  // ...
              ) {
                  fun toProduct() = Product(
                      id = this.id,
                      title = this.title,
                      imgSrc = this.img,
                      description = this.desc,
                      price = BigDecimal(price),
                      type = enumValueOf<ProductType>(this.type)
                  )
              }
              ```
              
              Not everyone likes this solution as it makes `ProductJson` bigger and more complicated. It is also not useful in transforming from `Product` to `ProductJson` because in most modern architectures we don’t want domain classes (like `Product`) to be aware of details such as their API representation. A better solution is to define both `toProduct` and `toProductJson` as extension functions, then locate them together next to the `ProductJson` class. It is good to locate those transformation functions next to each other, because they have a lot in common.
              
              ```kotlin
              class ProductJson(
                  val id: String,
                  val title: String,
                  val img: String,
                  val desc: String,
                  val price: String,
                  val type: String,
                  // ...
              )
              
              fun ProductJson.toProduct() = Product(
                  id = this.id,
                  title = this.title,
                  imgSrc = this.img,
                  description = this.desc,
                  price = BigDecimal(this.price),
                  type = enumValueOf<ProductType>(this.type)
              )
              
              fun Product.toProductJson() = ProductJson(
                  id = this.id,
                  title = this.title,
                  img = this.imgSrc,
                  desc = this.description,
                  price = this.price.toString(),
                  type = this.type.name
              )
              ```
              
              This seems to be a popular pattern, both on the backend and in Android applications.
          - type: "question-single-answer"
            stepId: "lesson-17_extensions-use-cases-q1"
            question: |-
              Which declaration correctly defines an extension `sorted` on `Iterable` where elements must be `Comparable`?
              
              ```kotlin
              // Choose one
              fun Iterable<T : Comparable<T>>.sorted(): List<T>
              fun <T : Comparable<T>> Iterable<T>.sorted(): List<T>
              fun <T> Iterable<T : Comparable<T>>.sorted(): List<T>
              fun Iterable<Comparable<T>>.sorted(): List<T>
              ```
            explanation: "Type parameters and their bounds must be declared before the function\
        \ name. You cannot introduce `T` inside the receiver type. Correct form: `fun\
        \ <T : Comparable<T>> Iterable<T>.sorted(): List<T>`."
            repeatable: true
            answers:
              - "fun Iterable<T : Comparable<T>>.sorted(): List<T>"
              - "fun <T : Comparable<T>> Iterable<T>.sorted(): List<T>"
              - "fun <T> Iterable<T : Comparable<T>>.sorted(): List<T>"
              - "fun Iterable<Comparable<T>>.sorted(): List<T>"
            correct: "fun <T : Comparable<T>> Iterable<T>.sorted(): List<T>"
          - type: "question-multiple-answer"
            stepId: "lesson-17_extensions-use-cases-q2"
            question: "According to the section, which are solid reasons to prefer extension\
        \ functions over member functions in these examples?"
            explanation: "Extensions let you: add functionality to types you don't control,\
        \ keep core interfaces (like `Iterable`) small, target specific type arguments\
        \ or bounded generics, and co-locate mapping functions without bloating domain/API\
        \ classes. They do not dynamically override members."
            repeatable: false
            answers:
              - "Add functions to types you don't control (e.g., `Context.toast`, `View.hide`)."
              - "Keep interfaces like `Iterable` small while providing rich APIs."
              - "Define functions for specific type arguments or with bounds (e.g., `Iterable<Int>.sum()`,\
        \ `<T: Comparable<T>> Iterable<T>.sorted()`)."
              - "Because extension functions dynamically override member functions at runtime."
              - "Keep domain entities unaware of API representations by placing both conversions\
        \ as extensions near `ProductJson`."
            correct:
              - "Add functions to types you don't control (e.g., `Context.toast`, `View.hide`)."
              - "Keep interfaces like `Iterable` small while providing rich APIs."
              - "Define functions for specific type arguments or with bounds (e.g., `Iterable<Int>.sum()`,\
        \ `<T: Comparable<T>> Iterable<T>.sorted()`)."
              - "Keep domain entities unaware of API representations by placing both conversions\
        \ as extensions near `ProductJson`."
          - type: "text"
            stepId: "lesson-17_extensions-summary-text"
            repeatable: false
            text: |-
              In this chapter, we've learned about extensions - a powerful Kotlin feature that is often used to create convenient and meaningful utils and to control our code better. However, with great power comes great responsibility. We should not be worried about using extensions, but we should use them consciously and only where they make sense.
              
              In the next chapter, we will finally introduce collections so that we can talk about lists, sets, maps, and arrays. There’s a lot ahead, so get ready.
          - type: "question-single-answer"
            stepId: "lesson-17_extensions-summary-q1"
            question: "Which is an appropriate, responsible use of Kotlin extensions based\
        \ on the guidance in this chapter?"
            explanation: "Extensions are great for convenient, meaningful utilities when\
        \ they make sense—especially on types you can’t modify. They shouldn’t be\
        \ used to bypass visibility, hide behavioral changes, or replace clearer designs."
            repeatable: false
            answers:
              - "Add a well-named extension function on a third-party type to express a domain-specific,\
        \ frequently used operation you can’t add as a member."
              - "Create an extension to access or modify private members you couldn’t otherwise\
        \ reach."
              - "Prefer extensions for all helpers by default, even when a top-level function\
        \ or member would be clearer."
              - "Use extensions to silently change behavior of an existing API without reviewers\
        \ noticing."
            correct: "Add a well-named extension function on a third-party type to express\
        \ a domain-specific, frequently used operation you can’t add as a member."
      - lessonId: "lesson-collections"
        name: "Collections"
        steps:
          - type: "text"
            stepId: "lesson-18_collections-#-collections-text"
            repeatable: false
            text: |-
              Collections are one of the most important concepts in programming. They are types that represent groups of elements. In Kotlin, the most important collection types are:
              
              * `List`, which represents an ordered collection of elements. The same elements can occur multiple times. A list’s elements can be accessed by indices (zero-based integer numbers that reflect elements’ positions). An example might be a list of songs in a queue: the order of the songs is important, and each song can appear in multiple places.
              
              * `Set`, which represents a collection of unique elements. It reflects the mathematical abstraction of a set: a group of objects without repetitions. Sets might not respect element order (however, the default set used by Kotlin does respect element order). An example might be a set of winning numbers in a lottery: they must be unique, but their order does not matter.
              
              * `Map` (known as a dictionary in some other languages), which represents a set of key-value pairs. Keys must be unique, and each of them points to exactly one value. Multiple keys can be associated with the same values. Maps are useful for expressing logical connections between elements.
              
              There are also arrays, which are typically considered a low-level primitive used by other collections under the hood.
              
              In this chapter, we will cover the most important topics regarding collections, starting from how they are organized, how they are created, special kinds of collections, and how all these kinds of collections are used in practice. This is a long chapter, so let's get started.
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-#-collections-q1"
            question: "Which statements are true about Kotlin collections according to this\
        \ section?"
            explanation: "Lists are ordered and indexable; Sets contain unique elements\
        \ and, by default in Kotlin, respect element order; Maps require unique keys\
        \ and allow multiple keys to reference the same value."
            repeatable: true
            answers:
              - "List elements can be accessed by zero-based indices."
              - "A Set allows duplicate elements."
              - "By default, Kotlin's Set implementation respects element order."
              - "In a Map, keys must be unique."
              - "Different keys in a Map may point to the same value."
            correct:
              - "List elements can be accessed by zero-based indices."
              - "By default, Kotlin's Set implementation respects element order."
              - "In a Map, keys must be unique."
              - "Different keys in a Map may point to the same value."
          - type: "text"
            stepId: "lesson-18_collections-the-hierarchy-of-interfaces-text"
            repeatable: false
            text: |-
              In Kotlin, a whole hierarchy of interfaces is used to represent different kinds of collections. Take a look at the diagram below.
              
              ![Relations between interfaces representing collections. Blue elements are read-only. Orange elements are mutable. Classes like `ArrayList` or `HashSet` implement mutable variants but can be up-casted to read-only.](collections_interfaces.png)
              
              At the top of the hierarchy, there is `Iterable`, which represents a sequence of elements that can be iterated over. We can iterate over `Iterable` objects using a for-loop thanks to its `iterator` method.
              
              ```kotlin
              interface Iterable<out T> {
                  operator fun iterator(): Iterator<T>
              }
              ```
              
              The next type is `Collection`, which represents a collection of elements. Its methods are read-only (no methods for manipulating the elements are available), so this interface does not allow any modifications.
              
              ```kotlin
              interface Collection<out E> : Iterable<E> {
                  val size: Int
                  fun isEmpty(): Boolean
                  operator fun contains(element: E): Boolean
                  override fun iterator(): Iterator<E>
                  fun containsAll(elements: Collection<E>): Boolean
              }
              ```
              
              Notice that only `List` and `Set` are subtypes of `Collection` and `Iterable`. `Map` and arrays are not part of this hierarchy; however, we can also iterate over them using a for-loop.
              
              All the interfaces described so far are read-only, so they have methods that allow what is inside to be read (like `get`, `contains`, `size`) but not modified. `MutableIterable`, `MutableCollection` and `MutableList` are sub-interfaces of, respectively, `Iterable`, `Collection` and `List`, which add methods for modifying elements (like `remove`, `clear`, `add`).
              
              The actual classes used when we operate on collections are platform-specific. For instance, if you create a list using the `listOf("A", "B")` function on Kotlin/JVM version 1.7.20, the actual class is `Arrays.ArrayList` from the Java Standard Library; however, if you use Kotlin/JS version 1.7.20, the actual class is a JavaScript array. The point is to expect not a concrete class but an object that represents a list (and therefore implements a `List` interface). This is an application of a general idea: use abstractions to make it easier to change the underlying representations (e.g., for performance reasons) without pushing breaking changes.
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-the-hierarchy-of-interfaces-q1"
            question: |-
              Given:
              
              ```kotlin
              fun f1(c: Collection<Int>) {}
              fun f2(c: Iterable<Int>) {}
              fun f3(c: Collection<Number>) {}
              ```
              Which calls compile?
            explanation: |-
              - `List` is both a `Collection` and `Iterable`.
              - `Collection`/`Iterable` are covariant (`out`), so `List<Int>` fits `Collection<Number>`.
              - `Array` and `Map` are not subtypes of `Collection`/`Iterable`.
            repeatable: true
            answers:
              - "f1(mutableListOf(1, 2))"
              - "f1(arrayOf(1, 2))"
              - "f2(mapOf(1 to \"a\"))"
              - "f3(listOf(1, 2))"
              - "f2(listOf(1, 2))"
            correct:
              - "f1(mutableListOf(1, 2))"
              - "f3(listOf(1, 2))"
              - "f2(listOf(1, 2))"
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-the-hierarchy-of-interfaces-q2"
            question: "Which Kotlin types are NOT subtypes of `Collection`, yet can still\
        \ be iterated with a `for`-loop?"
            explanation: "`Map` and arrays are outside the `Iterable`/`Collection`/`List`/`Set`\
        \ hierarchy but provide `iterator` support for `for`-loops."
            repeatable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "Map"
              - "Array"
          - type: "text"
            stepId: "lesson-18_collections-mutable-vs-read-only-types-text"
            repeatable: false
            text: |-
              The distinction between mutable and read-only interfaces is very important. For instance, the `listOf` function returns `List`, which represents a read-only collection. `List` does not have any functions that would allow its modification (functions like `add` or `remove`). This means a collection object cannot mutate, but this doesn’t mean we cannot update a variable that contains a collection.
              
              It’s a similar story with `Int` or `String`. Both are immutable, so they cannot change internally; however, we update their values with operators like plus.
              
                ```kotlin
              fun main() {
                  var a = 100
                  a = a + 10
                  a += 1
                  println(a) // 111
              
                  var str = "A"
                  str = str + "B"
                  str += "C"
                  println(str) // ABC
              }
              ```
              
              The same goes for read-only collections: we can use operators to create a new collection with an updated value.
              
              ```kotlin
              fun main() {
                  var list = listOf("A", "B")
                  list = list + "C"
                  println(list) // [A, B, C]
                  list = list + listOf("D", "E")
                  println(list) // [A, B, C, D, E]
                  list = listOf("Z") + list
                  println(list)  // [Z, A, B, C, D, E]
              }
              ```
              
              In contrast to read-only lists, mutable lists can be modified internally. So, if you create a collection using the `mutableListOf` function, the result object is `MutableList`, which supports operations like `add`, `clear` or `remove`.
              
              ```kotlin
              fun main() {
                  val mutable = mutableListOf("A", "B")
                  mutable.add("C")
                  mutable.remove("A")
                  println(mutable) // [B, C]
              }
              ```
              
              You can easily transform between a mutable and a read-only list with `toList` and `toMutableList`. However, you often do not need to explicitly transform from a `MutableList` to a `List`. `MutableList` is a subtype of `List`, so a `MutableList` can be used as a `List`.
              
              In the upcoming sections, we will see the most important operators for modifying read-only collections, and methods that can be used to modify mutable collections.
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-mutable-vs-read-only-types-q1"
            question: |-
              Given:
              
              ```kotlin
              fun read(xs: List<String>) {}
              fun mutate(xs: MutableList<String>) { xs.add("X") }
              
              val r: List<String> = listOf("A", "B")
              val m: MutableList<String> = mutableListOf("A", "B")
              ```
              Which calls compile?
            explanation: "MutableList is a subtype of List, so it can be passed where List\
        \ is expected. A read-only List cannot be passed to a function expecting MutableList\
        \ unless converted via toMutableList."
            repeatable: true
            answers:
              - "read(r)"
              - "read(m)"
              - "mutate(r)"
              - "mutate(m)"
              - "mutate(r.toMutableList())"
            correct:
              - "read(r)"
              - "read(m)"
              - "mutate(m)"
              - "mutate(r.toMutableList())"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-mutable-vs-read-only-types-q2"
            question: |-
              What does the following print?
              
              ```kotlin
              fun main() {
                  var list = listOf("A")
                  list + "B"
                  println(list)
              }
              ```
            explanation: "`+` on a read-only List creates a new List; the original is unchanged\
        \ unless you reassign. Here the result of `list + \"B\"` is ignored."
            repeatable: false
            answers:
              - "[A]"
              - "[A, B]"
              - "Compilation error at `list + \"B\"`"
              - "Runtime exception"
            correct: "[A]"
          - type: "text"
            stepId: "lesson-18_collections-creating-collections-text"
            repeatable: false
            text: |-
              Most languages have support for a feature called a "collection literal", which is special syntax for creating a certain collection type based on the provided list of elements.
              
              ```
              // JavaScript
              const arr = ["A", "B"] // an array of strings
              // Python
              numbers = [1, 2, 3] // a list of numbers
              names = {"Alex", "Barbara"} // a set of strings
              ```
              
              In Kotlin, this role is performed by top-level functions. By convention, their names start with the name of the type they produce (starting from lower case) and the `Of` suffix. Here are a few examples.
              
              ```kotlin
              fun main() {
                  // We create `List` using `listOf` function.
                  val list: List<String> = listOf("A", "B", "C")
                  // We create `MutableList` using `mutableListOf` function.
                  val mutableList: MutableList<Int> = mutableListOf(1, 2, 3)
              
                  // We create `Set` using `setOf` function.
                  val set: Set<Double> = setOf(3.14, 7.11)
                  // We create `MutableSet` using `mutableSetOf` function.
                  val mutableSet: MutableSet<Char> = mutableSetOf('A', 'B')
              
                  // We create `Map` using `mapOf` function.
                  val map: Map<Char, String> =
                      mapOf('A' to "Alex", 'B' to "Ben")
                  // We create `MutableMap` using `mutableMapOf` function.
                  val mutableMap: MutableMap<Int, Char> =
                      mutableMapOf(1 to 'A', 2 to 'B')
              
                  // We create `Array` using `arrayOf` function.
                  val array: Array<String> = arrayOf("Dukaj", "Sapkowski")
                  // We create `IntArray` using `intArrayOf` function.
                  val intArray: IntArray = intArrayOf(9, 8, 7)
              
                  // We create `ArrayList` using `arrayListOf` function.
                  val arrayList: ArrayList<String> = arrayListOf("M", "N")
              }
              ```
              
              To all these classes, we provide initial elements as arguments. The only exception is map, which is a set of key-value pairs, so we specify the initial pairs using `Pair`, which we typically create using the `to` function (as explained in the chapter *Data classes*).
              
              We can also transform one collection into another. This can often be done using a method whose name is the type we want to achieve, preceded by the `to` prefix.
              
              ```kotlin
              fun main() {
                  val list: List<Char> = listOf('A', 'B', 'C')
                  val mutableList: MutableList<Char> = list.toMutableList()
                  val set: Set<Char> = mutableList.toSet()
                  val mutableSet: MutableList<Char> = set.toMutableList()
                  val array: Array<Char> = mutableSet.toTypedArray()
                  val charArray: CharArray = array.toCharArray()
                  val list2: List<Char> = charArray.toList()
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-18_collections-creating-collections-q1"
            question: "Which expression has the static type `ArrayList<String>`?"
            explanation: "`arrayListOf` returns `java.util.ArrayList`. `mutableListOf` and\
        \ `toMutableList()` return `MutableList`, and `arrayOf` returns `Array<T>`."
            repeatable: true
            answers:
              - "`arrayListOf(\"M\", \"N\")`"
              - "`mutableListOf(\"M\", \"N\")`"
              - "`listOf(\"M\", \"N\").toMutableList()`"
              - "`arrayOf(\"M\", \"N\").toMutableList()`"
            correct: "`arrayListOf(\"M\", \"N\")`"
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-creating-collections-q2"
            question: "Which declarations compile?"
            explanation: "`arrayOf(1, 2, 3)` returns `Array<Int>`; `intArrayOf(1, 2, 3)`\
        \ returns `IntArray`. These types are distinct and not interchangeable."
            repeatable: true
            answers:
              - "`val a: Array<Int> = arrayOf(1, 2, 3)`"
              - "`val b: Array<Int> = intArrayOf(1, 2, 3)`"
              - "`val c: IntArray = arrayOf(1, 2, 3)`"
              - "`val d: IntArray = intArrayOf(1, 2, 3)`"
            correct:
              - "`val a: Array<Int> = arrayOf(1, 2, 3)`"
              - "`val d: IntArray = intArrayOf(1, 2, 3)`"
          - type: "text"
            stepId: "lesson-18_collections-lists-text"
            repeatable: false
            text: |-
              **List** is the most basic type of collection. You can treat it as the default collection type. It represents an ordered list of elements.
              
              ```kotlin
              fun main() {
                  val list = listOf("A", "B", "C")
                  println(list) // [A, B, C]
              }
              ```
              
              `List` is a generic class. The result type of `listOf` is `List<T>`, where `T` is the type of the elements in this list. Since we have a list with string values in the code above, the type is `List<String>`. More about generic classes in the chapter *Generics*.
              
              ```kotlin
              fun main() {
                  val list: List<String> = listOf("A", "B", "C")
                  println(list) // [A, B, C]
                  val ints: List<Int> = listOf(1, 2, 3)
                  println(ints) // [1, 2, 3]
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-18_collections-lists-q1"
            question: |-
              What is the inferred type of the variable below?
              
              ```kotlin
              val xs = listOf(1, 2.0, 3L)
              ```
            explanation: "`listOf` is generic and infers the common supertype of its elements.\
        \ For Int, Double, and Long, the most specific common supertype is `Number`."
            repeatable: true
            answers:
              - "List<Number>"
              - "List<Double>"
              - "List<Any>"
              - "List<Int>"
            correct: "List<Number>"
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-lists-q2"
            question: "Which declarations compile?"
            explanation: "`listOf` returns `List<T>` with `T` inferred from elements. a\
        \ and b match their element types. d infers `T` as `Any` for mixed elements,\
        \ so `List<Any>` fits. c mismatches numbers with `List<String>`. e requires\
        \ `List<String?>` to allow `null`."
            repeatable: false
            answers:
              - "val a: List<String> = listOf(\"A\", \"B\")"
              - "val b: List<Int> = listOf(1, 2, 3)"
              - "val c: List<String> = listOf(1, 2, 3)"
              - "val d: List<Any> = listOf(\"A\", 1)"
              - "val e: List<String> = listOf(\"A\", \"B\", null)"
            correct:
              - "val a: List<String> = listOf(\"A\", \"B\")"
              - "val b: List<Int> = listOf(1, 2, 3)"
              - "val d: List<Any> = listOf(\"A\", 1)"
          - type: "text"
            stepId: "lesson-18_collections-modifying-lists-text"
            repeatable: false
            text: |-
              When you need to modify the elements of a list, you have two options:
              1. Use a read-only list in a `var` variable, and modify it using operators like plus or minus.
              2. Use a mutable list in a `val` variable, and modify it using `MutableList` methods like `add`, `addAll` or `remove`.
              
              ```kotlin
              fun main() {
                  var list = listOf("A", "B")
                  list = list + "C"
                  println(list) // [A, B, C]
                  list = list + listOf("D", "E")
                  println(list) // [A, B, C, D, E]
                  list = listOf("Z") + list
                  println(list) // [Z, A, B, C, D, E]
                  list = list - "A"
                  println(list) // [Z, B, C, D, E]
              
                  val mutable = mutableListOf("A", "B")
                  mutable.add("C")
                  println(mutable) // [A, B, C]
                  mutable.addAll(listOf("D", "E"))
                  println(mutable) // [A, B, C, D, E]
                  mutable.add(0, "Z") // The first number is index
                  println(mutable) // [Z, A, B, C, D, E]
                  mutable.remove("A")
                  println(mutable) // [Z, B, C, D, E]
              }
              ```
              
              Since the beginning of Kotlin, there have been discussions about which of these two approaches should be preferred. The first gives more freedom, but the second is considered more efficient.
              
              You can also use the `+=` operator to add an element or a collection to a `var` variable that points to a read-only list, or to a `val` variable that points to a mutable list.
              
              ```kotlin
              fun main() {
                  var list = listOf("A", "B")
                  list += "C"
                  println(list) // [A, B, C]
              
                  val mutable = mutableListOf("A", "B")
                  mutable += "C"
                  println(mutable) // [A, B, C]
              }
              ```
              
              However, using `+=` for read-only lists results in a warning that a new collection has been created under the hood, which can lead to performance issues when we are dealing with large lists.
              
              ![](plusAssign.png)
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-modifying-lists-q1"
            question: |-
              Given:
              
              ```kotlin
              var ro: List<String> = listOf("A", "B")
              val m: MutableList<String> = mutableListOf("A", "B")
              ```
              Select all options that both compile and do NOT create a new list instance.
            explanation: "`+=` on a MutableList uses `plusAssign` and mutates in place (no\
        \ new list). On a read-only `List`, `+=` falls back to `list = list + ...`\
        \ (new list) and often shows a warning. `m = m + \"C\"` doesn’t compile because\
        \ `m + \"C\"` returns a `List`, not a `MutableList`."
            repeatable: true
            answers:
              - "ro += \"C\""
              - "ro = ro + \"C\""
              - "m += \"C\""
              - "m += listOf(\"D\", \"E\")"
              - "m = m + \"C\""
            correct:
              - "m += \"C\""
              - "m += listOf(\"D\", \"E\")"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-modifying-lists-q2"
            question: "When repeatedly adding many elements to build a large list, which\
        \ approach is generally more efficient?"
            explanation: "Using a `MutableList` and mutating it (`add`, `addAll`, or `+=`)\
        \ avoids creating new collections on each addition, unlike `List` with `+`/`+=`\
        \ which allocates new lists."
            repeatable: false
            answers:
              - "Use a var List and add elements with + or +="
              - "Use a val MutableList and add elements with add/addAll or +="
              - "Use a val List and +="
              - "No difference; both allocate the same"
            correct: "Use a val MutableList and add elements with add/addAll or +="
          - type: "text"
            stepId: "lesson-18_collections-checking-a-list’s-size-or-if-it-is-empty-text"
            repeatable: false
            text: |-
              You can get the number of elements in a list using the `size` property.
              
              ```kotlin
              fun main() {
                  val list = listOf("A", "B", "C")
                  println(list.size) // 3
              }
              ```
              
              A list is considered empty when its size is `0`. You can also check this using the `isEmpty` method.
              
              ```kotlin
              fun main() {
                  val list = listOf("A", "B", "C")
                  println(list.size == 0) // false
                  println(list.isEmpty()) // false
              
                  val empty: Set<Int> = setOf()
                  println(empty.size == 0) // true
                  println(empty.isEmpty()) // true
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-checking-a-list’s-size-or-if-it-is-empty-q1"
            question: "You have a non-null list `val l: List<Int> = ...`. Select all expressions\
        \ that correctly check that `l` is empty in O(1) time."
            explanation: "`size` is the element count and `isEmpty()` delegates to checking\
        \ `size == 0`, both O(1). `count()` and `sumOf { ... }` iterate the elements\
        \ (O(n))."
            repeatable: true
            answers:
              - "l.size == 0"
              - "l.isEmpty()"
              - "l.count() == 0"
              - "l.sumOf { 1 } == 0"
            correct:
              - "l.size == 0"
              - "l.isEmpty()"
          - type: "text"
            stepId: "lesson-18_collections-lists-and-indices-text"
            repeatable: false
            text: |-
              Lists allow elements to be retrieved by their index, which is a number that represents the element’s position. The index of the first element is always 0, and each next element in the list has the next index. You can imagine a list to be like an infinite shelf for items, where there is a label with a number below each item.
              
              ![](shelf.png)
              
              To get an element by an index, we use the box bracket. This is a synonym of the `get` method. Both these methods throw an `IndexOutOfBoundsException` when you try to get an element at an index that does not exist.
              
              ```kotlin
              fun main() {
                  val list = listOf("A", "B")
                  println(list[1]) // B
                  println(list.get(1)) // B
                  println(list[3]) // Runtime error
              }
              ```
              
              If you are not sure if an index is correct, it is safer to use either `getOrNull`, which returns `null` in the case of an incorrect index, or `getOrElse`, which specifies the default value.
              
              ```kotlin
              fun main() {
                  val list = listOf("A", "B")
                  println(list.getOrNull(1)) // B
                  println(list.getOrElse(1) { "X" }) // B
              
                  println(list.getOrNull(3)) // null
                  println(list.getOrElse(3) { "X" }) // X
              }
              ```
              
              There is also a useful function `getOrPut`, that can only be called on `MutableMap`, that tries to find an element by key, and if it is not there, it is creating it, adding it to the map and returning it. This operation is useful when we use a map to cache some values, so to keep values in local memory so that we do not need to fetch or calculate them again.
              
              ```kotlin
              fun main() {
                  val map = mutableMapOf("A" to 1, "B" to 2)
                  println(map.getOrPut("A") { 3 }) // 1
                  println(map.getOrPut("C") { 3 }) // 3
                  println(map) // {A=1, B=2, C=3}
              }
              ```
              
              You can find the index of an element using the `indexOf` method. It returns `-1` when there is no matching element in the list.
              
              ```kotlin
              fun main() {
                  val list = listOf("A", "B")
                  println(list.indexOf("A")) // 0
                  println(list.indexOf("B")) // 1
                  println(list.indexOf("Z")) // -1
              }
              ```
              
              In a mutable list, you can modify an element at a certain index using the box bracket in an assignment, or using the `set` method.
              
              ```kotlin
              fun main() {
                  val mutable = mutableListOf("A", "B", "C")
                  mutable[1] = "X"
                  println(mutable) // [A, X, C]
                  mutable.set(1, "Y")
                  println(mutable) // [A, Y, C]
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-lists-and-indices-q1"
            question: "Given `val list = listOf(\"A\", \"B\")`, which statements are correct?"
            explanation: |-
              - list[1] and list.get(1) are equivalent and can throw IndexOutOfBoundsException if the index is invalid.
              - getOrNull returns null for an out-of-range index (type is T?).
              - getOrElse uses the default lambda only when the index is out of range.
              - indexOf returns -1 when not found, not null.
              - Assignment via [index] works only on MutableList.
            repeatable: true
            answers:
              - "list[1] and list.get(1) are equivalent and may throw IndexOutOfBoundsException\
        \ for an invalid index."
              - "list.getOrNull(3) returns null when index 3 is out of range."
              - "list.getOrElse(3) { \"x\" } returns \"x\" when index 3 is out of range."
              - "list.indexOf(\"Z\") returns null when \"Z\" is not found."
              - "In a MutableList<String>, you can assign with list[1] = \"X\"."
            correct:
              - "list[1] and list.get(1) are equivalent and may throw IndexOutOfBoundsException\
        \ for an invalid index."
              - "list.getOrNull(3) returns null when index 3 is out of range."
              - "list.getOrElse(3) { \"x\" } returns \"x\" when index 3 is out of range."
              - "In a MutableList<String>, you can assign with list[1] = \"X\"."
          - type: "question-single-answer"
            stepId: "lesson-18_collections-lists-and-indices-q2"
            question: |-
              What does the following program print?
              
              ```kotlin
              fun main() {
                  val map = mutableMapOf("A" to 1, "B" to 2)
                  val x = map.getOrPut("A") { 10 }
                  val y = map.getOrPut("C") { x + 1 }
                  println("$x ${map["A"]} $y ${map["C"]}")
              }
              ```
            explanation: "getOrPut on an existing key returns the existing value and does\
        \ not invoke the lambda (x=1, A stays 1). For a missing key, it computes,\
        \ inserts, and returns the lambda result (y=2, C becomes 2)."
            repeatable: true
            answers:
              - "1 1 2 2"
              - "10 1 2 2"
              - "1 10 2 2"
              - "1 1 11 11"
              - "10 10 11 11"
            correct: "1 1 2 2"
          - type: "text"
            stepId: "lesson-18_collections-checking-if-a-list-contains-an-element-text"
            repeatable: false
            text: |-
              You can check if a list contains an element using the `contains` method or the `in` operator.
              
              ```kotlin
              fun main() {
                  val letters = listOf("A", "B", "C")
                  println(letters.contains("A")) // true
                  println(letters.contains("Z")) // false
                  println("A" in letters) // true
                  println("Z" in letters) // false
              }
              ```
              
              You can also check whether a collection does not contain an element using the `!in` operator.
              
              ```kotlin
              fun main() {
                  val letters = listOf("A", "B", "C")
                  println("A" !in letters) // false
                  println("Z" !in letters) // true
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-checking-if-a-list-contains-an-element-q1"
            question: |-
              Given:
              
              ```kotlin
              val letters = listOf("A", "B", "C")
              ```
              Which expressions are valid and correctly check that "Z" is not in letters? Choose all that apply.
            explanation: "`in` translates to `contains`; `!in` is a dedicated negated operator.\
        \ You can also negate the boolean result. `letters !contains \"Z\"` doesn't\
        \ exist, and `!(\"Z\") in letters` tries to negate a String (compile error)."
            repeatable: false
            answers:
              - "\"Z\" !in letters"
              - "!(\"Z\" in letters)"
              - "!letters.contains(\"Z\")"
              - "letters !contains \"Z\""
              - "!(\"Z\") in letters"
            correct:
              - "\"Z\" !in letters"
              - "!(\"Z\" in letters)"
              - "!letters.contains(\"Z\")"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-checking-if-a-list-contains-an-element-q2"
            question: |-
              Given:
              
              ```kotlin
              val xs: List<Any> = listOf(1, "1", 1L)
              ```
              Which expression evaluates to false?
            explanation: "`contains`/`in` use structural equality. The list holds Int 1,\
        \ String \"1\", and Long 1L. Char '1' is not present."
            repeatable: false
            answers:
              - "\"1\" in xs"
              - "1 in xs"
              - "1L in xs"
              - "'1' in xs"
            correct: "'1' in xs"
          - type: "text"
            stepId: "lesson-18_collections-iterating-over-a-list-text"
            repeatable: false
            text: |-
              You can iterate over a list using a for-loop. Just place the list on the right side of `in`.
              
              ```kotlin
              fun main() {
                  val letters = listOf("A", "B", "C")
                  for (letter in letters) {
                      print(letter)
                  }
              }
              ```
              
              Since `MutableList` implements `List`, all these operations can also be used on mutable lists.
              
              These are the most basic operations on lists. We will cover more of them in the book: *Functional Kotlin*.
          - type: "question-single-answer"
            stepId: "lesson-18_collections-iterating-over-a-list-q1"
            question: "Which snippet correctly iterates directly over the elements of a\
        \ `List<String>` and prints `ABC` using a Kotlin for-loop?"
            explanation: "Kotlin’s for-loop syntax is `for (element in iterable)`, with\
        \ the list on the right side of `in`. Option A iterates elements directly.\
        \ B uses indices, C is invalid syntax, and D is not a valid Kotlin call."
            repeatable: false
            answers:
              - |-
                ```kotlin
                val letters = listOf("A", "B", "C")
                for (letter in letters) print(letter)
                ```
              - |-
                ```kotlin
                val letters = listOf("A", "B", "C")
                for (i in letters.indices) print(letters[i])
                ```
              - |-
                ```kotlin
                val letters = listOf("A", "B", "C")
                for (letter: String in letters) print(letter)
                ```
              - |-
                ```kotlin
                val letters = listOf("A", "B", "C")
                forEach(letters) { print(it) }
                ```
            correct: |-
              ```kotlin
              val letters = listOf("A", "B", "C")
              for (letter in letters) print(letter)
              ```
          - type: "text"
            stepId: "lesson-18_collections-sets-text"
            repeatable: false
            text: |-
              We use **sets** instead of lists when:
              1. we want to ensure that elements in our collection are unique (sets keep only unique elements),
              2. we frequently look for an element in a collection (finding elements in a set is much more efficient than doing so in a list).
              
              Sets are quite similar to lists, which is why similar methods are used to operate on them. However, sets do not treat order as seriously as lists, and some kinds of sets do not respect order at all. This is why we cannot get elements by index.
              
              We create a set using the `setOf` function; then we specify its values using arguments.
              
              ```kotlin
              fun main() {
                  val set = setOf('A', 'B', 'C')
                  println(set) // [A, B, C]
              }
              ```
              
              `Set` is a generic class. The result type of `setOf` is `Set<T>`, where `T` is the type of elements in this set. Since we have a set with char values in the code above, the type is `Set<Char>`.
              
              ```kotlin
              fun main() {
                  val set: Set<Char> = setOf('A', 'B', 'C')
                  println(set) // [A, B, C]
                  val ints: Set<Long> = setOf(1L, 2L, 3L)
                  println(ints) // [1, 2, 3]
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-18_collections-sets-q1"
            question: |-
              Given:
              
              ```kotlin
              val s = setOf('A', 'A', 'B')
              ```
              Which line does NOT compile?
            explanation: "Sets ensure uniqueness and do not support indexing. There is no\
        \ get(index) operator for Set; use membership checks or iteration-based functions\
        \ instead."
            repeatable: true
            answers:
              - "println(s.size)"
              - "println('B' in s)"
              - "println(s[0])"
              - "println(s.contains('A'))"
            correct: "println(s[0])"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-sets-q2"
            question: "What is the inferred type of the value returned by `setOf(1L, 2L,\
        \ 3L)`?"
            explanation: "`setOf` produces a read-only `Set<T>`; here `T` is `Long`, so\
        \ the type is `Set<Long>`."
            repeatable: false
            answers:
              - "Set<Int>"
              - "Set<Long>"
              - "List<Long>"
              - "MutableSet<Long>"
            correct: "Set<Long>"
          - type: "text"
            stepId: "lesson-18_collections-modifying-sets-text"
            repeatable: false
            text: |-
              You can add elements to a read-only set in the same way as to a read-only list: using plus or minus.
              
              ```kotlin
              fun main() {
                  var set = setOf("A", "B")
                  set = set + "C"
                  println(set) // [A, B, C]
                  set = set + setOf("D", "E")
                  println(set) // [A, B, C, D, E]
                  set = setOf("Z") + set
                  println(set) // [Z, A, B, C, D, E]
                  set = set - "A"
                  println(set) // [Z, B, C, D, E]
              }
              ```
              
              You can also use a mutable set and its `add`, `addAll` or `remove` methods.
              
              ```kotlin
              fun main() {
                  val mutable = mutableSetOf("A", "B")
                  mutable.add("C")
                  println(mutable) // [A, B, C]
                  mutable.addAll(listOf("D", "E"))
                  println(mutable) // [A, B, C, D, E]
                  mutable.remove("B")
                  println(mutable) // [A, C, D, E]
              }
              ```
          - type: "text"
            stepId: "lesson-18_collections-elements-in-a-set-are-unique-text"
            repeatable: false
            text: |-
              Sets accept only unique elements. If elements repeat during set creation, only the first occurrence will be present in the set.
              
              ```kotlin
              fun main() {
                  val set = setOf("A", "B", "C", "B")
                  println(set) // [A, B, C]
              }
              ```
              
              Adding an element that is equal to an element already present in a set is ignored.
              
              ```kotlin
              fun main() {
                  val set = setOf("A", "B", "C")
                  println(set + "D") // [A, B, C, D]
                  println(set + "B") // [A, B, C]
              
                  val mutable = mutableSetOf("A", "B", "C")
                  mutable.add("D")
                  mutable.add("B")
                  println(mutable) // [A, B, C, D]
              }
              ```
              
              Two elements are considered different when comparing them using the double equality sign returns `false`.
              
              ```kotlin
              // by default, each object from a regular class is unique
              class Cat(val name: String)
              
              // if the data modifier is used,
              // two instances with the same properties are equal
              data class Dog(val name: String)
              
              fun main() {
                  val cat1 = Cat("Garfield")
                  val cat2 = Cat("Garfield")
                  println(cat1 == cat2) // false
                  println(setOf(cat1, cat2)) // [Cat@4eec7777, Cat@3b07d329]
              
                  val dog1 = Dog("Rex")
                  val dog2 = Dog("Rex")
                  println(dog1 == dog2) // true
                  println(setOf(dog1, dog2)) // [Dog(name=Rex)]
              }
              ```
              
              The most efficient way to remove duplicates from a list is by transforming it into a set.
              
              ```kotlin
              fun main() {
                  val names = listOf("Jake", "John", "Jake", "James", "Jan")
                  println(names) // [Jake, John, Jake, James, Jan]
                  val unique = names.toSet()
                  println(unique) // [Jake, John, James, Jan]
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-18_collections-elements-in-a-set-are-unique-q1"
            question: |-
              What does the following print?
              
              ```kotlin
              class Cat(val name: String)
              data class Dog(val name: String)
              
              fun main() {
                  val s = setOf(Cat("X"), Cat("X"), Dog("Y"), Dog("Y"))
                  println(s.size)
              }
              ```
            explanation: "Set uniqueness is based on `==`. Two `Cat(\"X\")` are not equal\
        \ (regular class), so both are kept; two `Dog(\"Y\")` are equal (data class),\
        \ so only one remains. Total = 3."
            repeatable: true
            answers:
              - "2"
              - "3"
              - "4"
              - "Compilation error"
            correct: "3"
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-elements-in-a-set-are-unique-q2"
            question: "Given `val base = setOf(\"A\", \"B\", \"C\")`, which expressions\
        \ produce a set containing exactly the elements A, B, C, D (no duplicates)?"
            explanation: "`+` on a set adds new unique elements; adding an existing one\
        \ changes nothing. Converting a list with duplicates to a set removes duplicates.\
        \ The `apply` example ends with a set containing A, B, C, D."
            repeatable: false
            answers:
              - "base + \"D\""
              - "base + \"B\""
              - "mutableSetOf(\"A\", \"B\", \"C\").apply { add(\"D\"); add(\"B\") }"
              - "listOf(\"A\", \"B\", \"C\", \"D\", \"D\").toSet()"
              - "setOf(\"A\", \"B\", \"C\").plus(setOf(\"B\"))"
            correct:
              - "base + \"D\""
              - "mutableSetOf(\"A\", \"B\", \"C\").apply { add(\"D\"); add(\"B\") }"
              - "listOf(\"A\", \"B\", \"C\", \"D\", \"D\").toSet()"
          - type: "text"
            stepId: "lesson-18_collections-checking-a-set’s-size-or-if-it-is-empty-text"
            repeatable: false
            text: |-
              You can always check the number of elements in a set using the `size` property.
              
              ```kotlin
              fun main() {
                  val set = setOf('A', 'B', 'C')
                  println(set.size) // 3
              }
              ```
              
              To check if a set is empty, you can compare its size to `0`, or you can use the `isEmpty` method.
              
              ```kotlin
              fun main() {
                  val set = setOf('A', 'B', 'C')
                  println(set.size == 0) // false
                  println(set.isEmpty()) // false
              
                  val empty: Set<Int> = setOf()
                  println(empty.size == 0) // true
                  println(empty.isEmpty()) // true
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-18_collections-checking-a-set’s-size-or-if-it-is-empty-q1"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  val s1 = setOf(1, 2, 2, 3)
                  val s2 = setOf<Int>()
                  println(s1.size)
                  println(s1.isEmpty())
                  println(s2.size == 0)
                  println(s2.isEmpty())
              }
              ```
            explanation: "Sets keep unique elements, so `setOf(1,2,2,3)` has size 3. `isEmpty()`\
        \ is true only for an empty set. Both `size == 0` and `isEmpty()` are equivalent\
        \ checks for emptiness."
            repeatable: false
            answers:
              - |-
                3
                false
                true
                true
              - |-
                4
                false
                true
                true
              - |-
                3
                true
                false
                true
              - |-
                4
                false
                false
                true
            correct: |-
              3
              false
              true
              true
          - type: "text"
            stepId: "lesson-18_collections-checking-if-a-set-contains-an-element-text"
            repeatable: false
            text: |-
              You can check if a set contains a certain element by using the `contains` method or the `in` operator. Both these options return `true` if there is an element equal to the element you are looking for in the set; otherwise, it returns `false`.
              
              ```kotlin
              fun main() {
                  val letters = setOf('A', 'B', 'C')
                  println(letters.contains('A')) // true
                  println(letters.contains('Z')) // false
                  println('A' in letters) // true
                  println('Z' in letters) // false
              }
              ```
              
              You can also check whether a set does not contain an element using the `!in` operator.
              
              ```kotlin
              fun main() {
                  val letters = setOf("A", "B", "C")
                  println("A" !in letters) // false
                  println("Z" !in letters) // true
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-checking-if-a-set-contains-an-element-q1"
            question: |
              Given the set below, which expressions evaluate to true?
              
              ```kotlin
              val s: Set<Number> = setOf(1, 2L, 3.0)
              ```
            explanation: "`in` delegates to `contains`, which uses `equals`. Numeric types\
        \ are not coerced across types (`1 != 1L`), so only elements with both the\
        \ same value and type match."
            repeatable: true
            answers:
              - "1 in s"
              - "1L in s"
              - "2 in s"
              - "2L in s"
              - "3.0 in s"
              - "3 in s"
            correct:
              - "1 in s"
              - "2L in s"
              - "3.0 in s"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-checking-if-a-set-contains-an-element-q2"
            question: |
              What does the program print?
              
              ```kotlin
              class Point(val x: Int, val y: Int)
              data class DPoint(val x: Int, val y: Int)
              
              fun main() {
                  val a = setOf(Point(1, 2))
                  val b = setOf(DPoint(1, 2))
                  println(Point(1, 2) in a)
                  println(DPoint(1, 2) in b)
              }
              ```
            explanation: "`in` uses `contains`, which relies on `equals`. `Point` doesn't\
        \ override `equals` (reference equality), so the new instance isn't found.\
        \ `DPoint` is a data class with structural `equals`, so it is found."
            repeatable: true
            answers:
              - "false then true"
              - "true then true"
              - "false then false"
              - "true then false"
            correct: "false then true"
          - type: "text"
            stepId: "lesson-18_collections-iterating-over-sets-text"
            repeatable: false
            text: |-
              You can iterate over a set using a for-loop. Just place the set on the right side of `in`.
              
              ```kotlin
              fun main() {
                  val letters = setOf('A', 'B', 'C')
                  for (letter in letters) {
                      print(letter)
                  }
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-iterating-over-sets-q1"
            question: |-
              Given:
              
              ```kotlin
              val nums: Set<Int> = setOf(10, 20, 30)
              ```
              Which of the following for-loops compile in Kotlin?
            explanation: |-
              - You iterate a Set with `for (item in set)`; the loop variable type is inferred (no explicit type allowed).
              - Sets are not indexable (`nums[i]` is invalid) and have no `indices`.
              - Destructuring works with `withIndex()` (elements are `IndexedValue`, destructurable to `(index, value)`), but not with plain `Set<Int>` elements.
            repeatable: true
            answers:
              - "for (n in nums) print(n)"
              - "for (n: Int in nums) print(n)"
              - "for ((i, v) in nums.withIndex()) print(\"$i:$v\")"
              - "for (i in 0 until nums.size) print(nums[i])"
              - "for ((a, b) in nums) print(\"$a $b\")"
            correct:
              - "for (n in nums) print(n)"
              - "for ((i, v) in nums.withIndex()) print(\"$i:$v\")"
          - type: "text"
            stepId: "lesson-18_collections-maps-text"
            repeatable: false
            text: |-
              We use maps to keep associations from keys to their values. For instance:
              * From user id to an object representing this user.
              * From a website to its IP address.
              * From a configuration name to data stored in this configuration.
              
              ```kotlin
              class CachedApiArticleRepository(
                  val articleApi: ArticleApi
              ) {
                  val articleCache: MutableMap<String, String> =
                      mutableMapOf()
              
                  fun getContent(key: String) =
                      articleCache.getOrPut(key) {
                          articleApi.fetchContent(key)
                      }
              }
              
              class DeliveryMethodsConfiguration(
                  val deliveryMethods: Map<String, DeliveryMethod>
              )
              
              class TokenRepository {
                  private var tokenToUser: Map<String, User> = mapOf()
              
                  fun getUser(token: String) = tokenToUser[token]
              
                  fun addToken(token: String, user: User) {
                      tokenToUser[token] = user
                  }
              }
              ```
              
              You can create a map using the `mapOf` function and then use key-value pairs as arguments to specify key-value associations. For instance, I might define a map that associates countries with their capitals. Pairs can be defined using a constructor or the `to` function.
              
              ```kotlin
              fun main() {
                  val capitals = mapOf(
                      "USA" to "Washington DC",
                      "Poland" to "Warsaw",
                  )
              //    val capitals = mapOf(
              //        Pair("USA", "Washington DC"),
              //        Pair("Poland", "Warsaw"),
              //    )
                  println(capitals) // {USA=Washington DC, Poland=Warsaw}
              }
              ```
              
              `Map` is a generic class. The result type is `Map<K, V>`, where `K` is the key type, and `V` is the value type. In the case of the map from the `capitals` variable above, both the keys and the values are of type `String`, so the map type is `Map<String, String>`. However,a key does not need to be the same type as its value. Consider a map with associations between letters and their positions in the English alphabet, as in the example below. Its type is `Map<Char, Int>` because its keys are characters and its values are integers.
              
              ```kotlin
              fun main() {
                  val capitals: Map<String, String> = mapOf(
                      "USA" to "Washington DC",
                      "Poland" to "Warsaw",
                  )
                  println(capitals) // {USA=Washington DC, Poland=Warsaw}
              
                  val alphabet: Map<Char, Int> =
                      mapOf('A' to 1, 'B' to 2, 'C' to 3)
                  println(alphabet) // {A=1, B=2, C=3}
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-maps-q1"
            question: |-
              Given the code:
              
              ```kotlin
              class TokenRepository {
                  private var tokenToUser: Map<String, User> = mapOf()
              
                  fun getUser(token: String) = tokenToUser[token]
              
                  fun addToken(token: String, user: User) {
                      tokenToUser[token] = user
                  }
              }
              ```
              Which changes make this compile and allow adding tokens?
            explanation: "In Kotlin, Map is read-only; you can't assign via [key] = value.\
        \ You must either use a MutableMap or replace the whole Map with a new one.\
        \ getOrPut is defined for MutableMap."
            repeatable: true
            answers:
              - "Change tokenToUser to MutableMap and initialize with mutableMapOf()"
              - "Keep tokenToUser as Map but change addToken to: tokenToUser = tokenToUser\
        \ + (token to user)"
              - "Keep everything, it compiles as Map supports set via []"
              - "Only change initialization to mapOf(token to user)"
              - "Use getOrPut in addToken without changing the type"
            correct:
              - "Change tokenToUser to MutableMap and initialize with mutableMapOf()"
              - "Keep tokenToUser as Map but change addToken to: tokenToUser = tokenToUser\
        \ + (token to user)"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-maps-q2"
            question: |-
              Consider:
              
              ```kotlin
              val cache: MutableMap<String, String> = mutableMapOf()
              
              fun getContent(key: String) =
                  cache.getOrPut(key) { expensiveFetch(key) }
              ```
              What does getOrPut do for a given key?
            explanation: "getOrPut checks if the key exists; if yes, it returns the existing\
        \ value. Otherwise it computes the lambda, stores the result under the key,\
        \ and returns it."
            repeatable: true
            answers:
              - "Returns existing value if present; otherwise computes the lambda, stores\
        \ it, and returns it"
              - "Always computes the lambda, overwrites the value, and returns it"
              - "Returns null if the key is absent without calling the lambda"
              - "Throws an exception if the key is already present"
            correct: "Returns existing value if present; otherwise computes the lambda,\
        \ stores it, and returns it"
          - type: "text"
            stepId: "lesson-18_collections-finding-a-value-by-a-key-text"
            repeatable: false
            text: |-
              To find a value by a key, you can use the `get` function or box brackets with the key. For instance, to find the value for the key `'A'` in the `alphabet` map, use `alphabet.get('A')` or `alphabet['A']`. The result has a nullable value type, which is `Int?` in this case. Why nullable? If the key you asked for is not in the map, then `null` will be returned.
              
              ```kotlin
              fun main() {
                  val alphabet: Map<Char, Int> =
                      mapOf('A' to 1, 'B' to 2, 'C' to 3)
                  val number: Int? = alphabet['A']
                  println(number) // 1
                  println(alphabet['B']) // 2
                  println(alphabet['&']) // null
              }
              ```
              
              All the basic maps are optimized to make finding a value by a key a very fast operation.
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-finding-a-value-by-a-key-q1"
            question: |-
              Given:
              
              ```kotlin
              val alphabet: Map<Char, Int> = mapOf('A' to 1, 'B' to 2)
              ```
              Which statements are true about accessing values by key?
            explanation: "Both `get` and `[]` are equivalent and return a nullable value\
        \ type (`V?`). If a key is absent, they return `null`. Basic map lookups are\
        \ optimized and do not require iterating all entries."
            repeatable: true
            answers:
              - "alphabet.get('A') and alphabet['A'] are equivalent"
              - "alphabet['Z'] has type Int? and evaluates to null"
              - "alphabet['A'] has type Int (non-null)"
              - "If a key is missing, get throws an exception"
              - "Lookup via [] always iterates all entries"
            correct:
              - "alphabet.get('A') and alphabet['A'] are equivalent"
              - "alphabet['Z'] has type Int? and evaluates to null"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-finding-a-value-by-a-key-q2"
            question: "What is the compile-time type of `alphabet['A']` when `val alphabet:\
        \ Map<Char, Int> = mapOf('A' to 1)`?"
            explanation: "Map access returns `V?` because the key may be absent, so `Int?`\
        \ here."
            repeatable: false
            answers:
              - "Int"
              - "Int?"
              - "Char?"
              - "Nothing?"
              - "Any?"
            correct: "Int?"
          - type: "text"
            stepId: "lesson-18_collections-adding-elements-to-a-map-text"
            repeatable: false
            text: |-
              Just like a regular list or a regular set, a regular map is read-only, so it does not have methods that would allow elements to be added or removed. However, you can use the plus sign to create a new map with new entries. If you add a pair to a map, the result is a map with the new entry. If you add two maps together, the result is a merge of these two maps.
              
              ```kotlin
              fun main() {
                  val map1 = mapOf('A' to "Alex", 'B' to "Bob")
                  val map2 = map1 + ('C' to "Celina")
                  println(map1) // {A=Alex, B=Bob}
                  println(map2) // {A=Alex, B=Bob, C=Celina}
                  val map3 = mapOf('D' to "Daniel", 'E' to "Ellen")
                  val map4 = map2 + map3
                  println(map3) // {D=Daniel, E=Ellen}
                  println(map4)
                  // {A=Alex, B=Bob, C=Celina, D=Daniel, E=Ellen}
              }
              ```
              
              Beware that duplicate keys are not allowed; so, when you add a new value with an existing key, it replaces the old value.
              
              ```kotlin
              fun main() {
                  val map1 = mapOf('A' to "Alex", 'B' to "Bob")
                  val map2 = map1 + ('B' to "Barbara")
                  println(map1) // {A=Alex, B=Bob}
                  println(map2) // {A=Alex, B=Barbara}
              }
              ```
              
              You can also remove a key from a map using the minus sign.
              
              ```kotlin
              fun main() {
                  val map1 = mapOf('A' to "Alex", 'B' to "Bob")
                  val map2 = map1 - 'B'
                  println(map1) // {A=Alex, B=Bob}
                  println(map2) // {A=Alex}
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-adding-elements-to-a-map-q1"
            question: "Which statements about Kotlin's `Map` `+` and `-` operators are correct?"
            explanation: |-
              - `map + ('K' to v)` creates a new map; the original isn't modified.
              - In `map1 + map2`, the right-hand map's values override duplicates.
              - `map - key` returns a new map without that key; if absent, the result is effectively unchanged.
              - `+` never mutates a `MutableMap` in place; it still returns a new `Map`.
              - Re-adding an existing key replaces its value in the result.
            repeatable: true
            answers:
              - "`map + ('K' to v)` returns a new map; the original is unchanged."
              - "When merging `map1 + map2`, keys present in both maps take the value from\
        \ `map1`."
              - "The `-` operator returns a new map without the given key; if the key is missing,\
        \ the result is effectively the same as the original."
              - "`+` on a `MutableMap` mutates it in place."
              - "Adding a pair with an existing key replaces the value for that key in the\
        \ result."
            correct:
              - "`map + ('K' to v)` returns a new map; the original is unchanged."
              - "The `-` operator returns a new map without the given key; if the key is missing,\
        \ the result is effectively the same as the original."
              - "Adding a pair with an existing key replaces the value for that key in the\
        \ result."
          - type: "question-single-answer"
            stepId: "lesson-18_collections-adding-elements-to-a-map-q2"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  val m1 = mapOf('A' to 1, 'B' to 2)
                  val m2 = m1 + ('B' to 3) - 'A'
                  val m3 = mapOf('B' to 4)
                  val m4 = m2 + m3
                  println(m4)
              }
              ```
            explanation: "`m1 + ('B' to 3)` yields `{A=1, B=3}`; removing `'A'` gives `{B=3}`.\
        \ Merging with `{B=4}` keeps the right-hand value for duplicate keys, so `{B=4}`\
        \ is printed."
            repeatable: false
            answers:
              - "{B=4}"
              - "{A=1, B=4}"
              - "{B=3}"
              - "{A=1, B=3}"
            correct: "{B=4}"
          - type: "text"
            stepId: "lesson-18_collections-checking-if-a-map-contains-a-key-text"
            repeatable: false
            text: |-
              You can check if your map contains a key using the `in` keyword or the `containsKey` method.
              
              ```kotlin
              fun main() {
                  val map = mapOf('A' to "Alex", 'B' to "Bob")
                  println('A' in map) // true
                  println(map.containsKey('A')) // true
                  println('Z' in map) // false
                  println(map.containsKey('Z')) // false
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-checking-if-a-map-contains-a-key-q1"
            question: |-
              Given:
              
              ```kotlin
              val map = mapOf(1 to "one", 2 to "two")
              ```
              Which expressions evaluate to true?
            explanation: "For Map, `in` uses `containsKey`, so it checks keys. To check\
        \ values, use `containsValue` or `in map.values`."
            repeatable: true
            answers:
              - "2 in map"
              - "map.containsKey(1)"
              - "\"one\" in map.values"
              - "map.containsValue(\"two\")"
              - "3 in map"
              - "\"three\" in map.values"
            correct:
              - "2 in map"
              - "map.containsKey(1)"
              - "\"one\" in map.values"
              - "map.containsValue(\"two\")"
          - type: "text"
            stepId: "lesson-18_collections-checking-map-size-text"
            repeatable: false
            text: |-
              You can check how many entries you have in a map using the `size` property.
              
              ```kotlin
              fun main() {
                  val map = mapOf('A' to "Alex", 'B' to "Bob")
                  println(map.size) // 2
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-18_collections-checking-map-size-q1"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  val map = mapOf(
                      'A' to "Alex",
                      'A' to "Alice",
                      'B' to "Bob"
                  )
                  println(map.size)
              }
              ```
            explanation: "A Map holds unique keys. The second 'A' overwrites the first,\
        \ so there are 2 entries: 'A' and 'B'. The size property reports the number\
        \ of entries."
            repeatable: false
            answers:
              - "1"
              - "2"
              - "3"
              - "Compilation error"
            correct: "2"
          - type: "text"
            stepId: "lesson-18_collections-iterating-over-maps-text"
            repeatable: false
            text: |-
              You can iterate over a map using a for-loop. You iterate over entries that contain `key` and `value` properties.
              
              ```kotlin
              fun main() {
                  val map = mapOf('A' to "Alex", 'B' to "Bob")
                  for (entry in map) {
                      println("${entry.key} is for ${entry.value}")
                  }
              }
              // A is for Alex
              // B is for Bob
              ```
              
              You can also destructure each entry into two variables. Kotlin supports destructuring in a for-loop. Take a look at the example below.
              
              ```kotlin
              fun main() {
                  val map = mapOf('A' to "Alex", 'B' to "Bob")
                  for ((letter, name) in map) {
                      println("$letter is for $name")
                  }
              }
              // A is for Alex
              // B is for Bob
              ```
          - type: "question-single-answer"
            stepId: "lesson-18_collections-iterating-over-maps-q1"
            question: "Which loop correctly destructures map entries into key and value\
        \ in Kotlin?"
            explanation: "Iterating a Map yields Map.Entry<K, V>. Destructuring in a for-loop\
        \ uses parentheses around the variables: `for ((k, v) in map)`. It’s not `for\
        \ (k, v in map)`, and entries aren’t `Pair`."
            repeatable: false
            answers:
              - "for ((k, v) in map) println(\"$k is for $v\")"
              - "for (k, v in map) println(\"$k is for $v\")"
              - "for (k to v in map) println(\"$k is for $v\")"
              - "for (entry: Pair<Char, String> in map) println(\"${entry.first} is for ${entry.second}\"\
        )"
            correct: "for ((k, v) in map) println(\"$k is for $v\")"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-iterating-over-maps-q2"
            question: "In `for (entry in mapOf('A' to \"Alex\"))`, what is the type of `entry`\
        \ and which properties does it expose?"
            explanation: "A `Map` iteration yields `Map.Entry<K, V>` with `key` and `value`\
        \ properties. It is not a `Pair`, which would have `first` and `second`."
            repeatable: false
            answers:
              - "Map.Entry<Char, String>, properties: key and value"
              - "Pair<Char, String>, properties: first and second"
              - "Char, property: code"
              - "Entry<Char, String>, properties: left and right"
            correct: "Map.Entry<Char, String>, properties: key and value"
          - type: "text"
            stepId: "lesson-18_collections-mutable-maps-text"
            repeatable: false
            text: |-
              You can create a mutable map using `mutableMapOf`. The result type is `MutableMap`, which supports methods that modify this object. Using it we can:
              * add new entries to the map using the `put` method, or box brackets and assignment,
              * remove an entry by key using the `remove` method.
              
              ```kotlin
              fun main() {
                  val map: MutableMap<Char, String> =
                      mutableMapOf('A' to "Alex", 'B' to "Bob")
                  map.put('C', "Celina")
                  map['D'] = "Daria"
                  println(map) // {A=Alex, B=Bob, D=Daria, C=Celina}
                  map.remove('B')
                  println(map) // {A=Alex, D=Daria, C=Celina}
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-mutable-maps-q1"
            question: |-
              Given:
              
              ```kotlin
              val map: MutableMap<Char, String> = mutableMapOf('A' to "Alex")
              ```
              Which lines both compile and mutate the same map instance (do not create a new map)? Choose all that apply.
            explanation: "`MutableMap.put`, bracket assignment `map[key] = value`, and `remove(key)`\
        \ mutate the map. The `+` operator creates a new map, and `add` doesn't exist\
        \ on `MutableMap`."
            repeatable: true
            answers:
              - "map.put('B', \"Bob\")"
              - "map['C'] = \"Celina\""
              - "map.remove('A')"
              - "val newMap = map + ('D' to \"Daria\")"
              - "map.add('E', \"Eva\")"
            correct:
              - "map.put('B', \"Bob\")"
              - "map['C'] = \"Celina\""
              - "map.remove('A')"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-mutable-maps-q2"
            question: "Which expression is idiomatic Kotlin and equivalent to calling `map.put('X',\
        \ \"Y\")` on a `MutableMap`?"
            explanation: "`map[key] = value` uses the `set` operator on `MutableMap` and\
        \ is equivalent to `put`. The other forms are invalid for this purpose."
            repeatable: false
            answers:
              - "map['X'] = \"Y\""
              - "map('X') = \"Y\""
              - "map.set('X' to \"Y\")"
              - "map.add('X', \"Y\")"
            correct: "map['X'] = \"Y\""
          - type: "text"
            stepId: "lesson-18_collections-using-arrays-in-practice-text"
            repeatable: false
            text: |-
              **Array** is a very basic data structure that strongly relates to how memory is organized. Our computer's memory is like a big parking lot, where each place has a sequential number. An array is like a reservation for a number of adherent spaces. With such a reservation, it is really easy to iterate over the cars you own. It is also easy to find a car with a specific index.
              
              Let's say that an array starts at position 1024 in your memory, and you need to find the element at index 100 in the array. You also know that each element takes 4 positions (an array reserves constant space for its elements, which in most cases is the size of the memory reference). This is an easy problem: our element starts at the position 1024 + 100 * 4 = 1424. Accessing an element at a certain position is a very simple and efficient operation, which is a big advantage of using arrays.
              
              Using arrays directly is harder than using other kinds of collections. They have a constant size, a limited number of operations, they do not implement any interface, and they do not override the `toString`, `equals` or `hashCode` methods. However, arrays are used by many other data structures under the hood. For instance, when you use `mutableListOf` on Kotlin/JVM, the result object is `ArrayList`, which keeps elements in an array. This is why finding an element at an index in the default list is so efficient. So, `ArrayList` has the advantages of arrays, but it offers much more. Arrays have a constant size, so you cannot add more elements than their size allows. When you add an element to an `ArrayList` and its internal array is full already, it creates a bigger one and fills it with the previous values. We consider lists a preferred option to arrays, and we restrict the usage of arrays to performance-critical parts of our applications.
              
              Arrays are also used by the default `Set` and `Map` that we use in Kotlin. Both are based on a hash table algorithm that needs to use an array to work efficiently.
              
              Nevertheless, let's see how arrays can be used directly. We create an array using the `arrayOf` function. This creates an instance of class `Array` and of type `Array<T>`, where `T` is the type of the elements. To get an element at a certain index, we can use box brackets or the `get` method. To modify an element at a certain position, you can use box brackets or the `set` method. You can also get an array’s size using the `size` property or by iterating over the array using a for-loop.
              
              ```kotlin
              fun main() {
                  val arr: Array<String> = arrayOf("A", "B", "C")
                  println(arr[0]) // A
                  println(arr.get(0)) // A
                  println(arr[1]) // B
                  arr[1] = "D"
                  println(arr[1]) // D
                  arr.set(2, "E")
                  println(arr[2]) // E
                  println(arr.size) // 3
                  for (e in arr) {
                      print(e)
                  }
                  // ADE
              }
              ```
              
              All the above operations are the same as for `MutableList`, but this is where the list of basic array operations ends. Arrays do not support equality, so two arrays with the same elements are not considered equal. Another problem with arrays is that their `toString` method, which is used to transform an object into a `String`, does not print elements. It only prints the array type and the hash of its memory reference.
              
              ```kotlin
              fun main() {
                  val arr1 = arrayOf("A", "B", "C")
                  val arr2 = arrayOf("A", "B", "C")
                  println(arr1 == arr2) // false
                  println(arr1) // [Ljava.lang.String;@4f023edb
                  println(arr2) // [Ljava.lang.String;@3a71f4dd
              }
              ```
              
              To cheer up those who like using arrays, the Kotlin standard library offers a number of extension functions that allow many kinds of array transformations.
              
              ![](array_operations.png)
              
              Notice that there is a `plus` method that allows a new element to be added to an array. Just like the `plus` method on a list, it does not modify the array but creates a new one with a larger size.
              
              ```kotlin
              // JVM implementation
              operator fun <T> Array<T>.plus(element: T): Array<T> {
                  val index = size
                  val result = java.util.Arrays.copyOf(this, index + 1)
                  result[index] = element
                  return result
              }
              
              fun main() {
                  val arr = arrayOf("A", "B", "C")
                  println(arr.size) // 3
                  val arr2 = arr + "D"
                  println(arr.size) // 3
                  println(arr2.size) // 4
              }
              ```
              
              You can transform an array to a list or a set using the `toList` and `toSet` methods. To transfer the other way around, use `toTypedArray`.
              
              ```kotlin
              fun main() {
                  val arr1: Array<String> = arrayOf("A", "B", "C")
                  val list: List<String> = arr1.toList()
                  val arr2: Array<String> = list.toTypedArray()
                  val set: Set<String> = arr2.toSet()
                  val arr3: Array<String> = set.toTypedArray()
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-using-arrays-in-practice-q1"
            question: |-
              Given:
              
              ```kotlin
              val arr = arrayOf("A", "B", "C")
              val arr2 = arr + "D"
              ```
              Which statements are correct?
            explanation: "The plus operator creates a new array by copying and appending.\
        \ Arrays do not override equals and their toString prints the type and hash,\
        \ not elements."
            repeatable: false
            answers:
              - "arr.size == 3 and arr2.size == 4"
              - "arr2[3] == \"D\""
              - "Changing arr[1] later will not change arr2[1]"
              - "arr == arrayOf(\"A\", \"B\", \"C\")"
              - "println(arr) prints: [A, B, C]"
            correct:
              - "arr.size == 3 and arr2.size == 4"
              - "arr2[3] == \"D\""
              - "Changing arr[1] later will not change arr2[1]"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-using-arrays-in-practice-q2"
            question: "On Kotlin/JVM, what is the time complexity of `arr + element` for\
        \ `Array<T>`?"
            explanation: "It copies the entire array using `Arrays.copyOf`, which is linear\
        \ in the array size."
            repeatable: true
            answers:
              - "O(1)"
              - "O(log n)"
              - "O(n)"
              - "Amortized O(1)"
            correct: "O(n)"
          - type: "text"
            stepId: "lesson-18_collections-arrays-of-primitives-text"
            repeatable: false
            text: |-
              Some kinds of Kotlin value types, like `Int` or `Char`, can be represented in a more basic way than a regular object. This form is known as a primitive and is a Kotlin optimization that does not affect the usage of values; however, it makes primitive values take less memory and their use more efficient. The problem is that primitives cannot be kept in regular collections, but we can store them in special arrays. For each value that has a primitive form, there is a dedicated array type. These are:
              * `IntArray`, which represents an array of primitive `Int` values.
              * `LongArray`, which represents an array of primitive `Long` values.
              * `DoubleArray`, which represents an array of primitive `Double` values.
              * `FloatArray`, which represents an array of primitive `Float` values.
              * `CharArray`, which represents an array of primitive `Char` values.
              * `BooleanArray`, which represents an array of primitive `Boolean` values.
              * `ShortArray`, which represents an array of primitive `Short` values.
              * `ByteArray`, which represents an array of primitive `Byte` values.
              
              Each of these arrays can be created in two ways:
              * Using the `xxxOf` function and initial elements as arguments, where `xxx` is the decapitalized name of the array. For example, to create `DoubleArray`, you can use the `doubleArrayOf` function with arguments of type `Double`.
              * By transforming another kind of collection into an array of primitives using the `toXXX` method, where `XXX` is the name of the array. For instance, you can transform `List<Boolean>` into `BooleanArray` using the `toBooleanArray` method.
              
              ```kotlin
              fun main() {
                  val doubles: DoubleArray = doubleArrayOf(2.71, 3.14, 9.8)
                  val chars: CharArray = charArrayOf('X', 'Y', 'Z')
              
                  val accepts: List<Boolean> = listOf(true, false, true)
                  val acceptsArr: BooleanArray = accepts.toBooleanArray()
              
                  val ints: Set<Int> = setOf(2, 4, 8, 10)
                  val intsArr: IntArray = ints.toIntArray()
              }
              ```
              
              Arrays of primitives are not used often in most real-life projects. They are generally treated as low-level performance or memory use optimizations.
          - type: "question-single-answer"
            stepId: "lesson-18_collections-arrays-of-primitives-q1"
            question: "Which snippet creates a primitive DoubleArray containing 2.71, 3.14,\
        \ and 9.8?"
            explanation: "`doubleArrayOf(...)` constructs a primitive DoubleArray. `arrayOf`/`toTypedArray`\
        \ create Array<Double> (boxed), not a primitive array."
            repeatable: false
            answers:
              - "val a: DoubleArray = doubleArrayOf(2.71, 3.14, 9.8)"
              - "val a = arrayOf(2.71, 3.14, 9.8)"
              - "val a: Array<Double> = arrayOf(2.71, 3.14, 9.8)"
              - "val a: DoubleArray = listOf(2.71, 3.14, 9.8).toTypedArray()"
            correct: "val a: DoubleArray = doubleArrayOf(2.71, 3.14, 9.8)"
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-arrays-of-primitives-q2"
            question: "Which calls convert a Kotlin collection into a primitive array (no\
        \ boxing)?"
            explanation: "`toXXXArray()` (e.g., `toIntArray`, `toLongArray`, `toBooleanArray`)\
        \ on collections builds primitive arrays. `toTypedArray()` creates boxed `Array<T>`,\
        \ and `Array<Int>` has no `toIntArray()`."
            repeatable: true
            answers:
              - "listOf(true, false).toBooleanArray()"
              - "setOf(1, 2, 3).toIntArray()"
              - "listOf(1.0, 2.0).toTypedArray()"
              - "mutableListOf(1L, 2L).toLongArray()"
              - "arrayOf(1, 2).toIntArray()"
            correct:
              - "listOf(true, false).toBooleanArray()"
              - "setOf(1, 2, 3).toIntArray()"
              - "mutableListOf(1L, 2L).toLongArray()"
          - type: "text"
            stepId: "lesson-18_collections-vararg-parameters-and-array-functions-text"
            repeatable: false
            text: |-
              As mentioned in the chapter *Functions*, we can use the `vararg` modifier for a parameter to make it accept any number of arguments. This modifier turns a parameter into an array. Consider the `markdownList` function from the example below. Its `lines` parameter has `String` type specified, but since it has the modifier `vararg`, the actual type of `lines` is `Array<String>`. This is why we can iterate over it using a for loop.
              
              ```kotlin
              fun markdownList(vararg lines: String): String {
                  // the type of lines is Array<String>
                  var str = ""
                  for ((i, line) in lines.withIndex()) {
                      str += " * $line"
                      if (i != lines.size) {
                          str += "\n"
                      }
                  }
                  return str
              }
              
              fun main() {
                  print(markdownList("A", "B", "C"))
                  // * A
                  // * B
                  // * C
              }
              ```
              
              The basic functions used to create collections, like `listOf` or `setOf`, can have any number of arguments because they use the `vararg` modifier.
              
              ```kotlin
              fun <T> listOf(vararg elements: T): List<T> =
                  if (elements.size > 0) elements.asList() else emptyList()
              
              fun <T> setOf(vararg elements: T): Set<T> =
                  if (elements.size > 0) elements.toSet() else emptySet()
              ```
              
              You can also spread an array into vararg arguments using the `*` symbol.
              
              ```kotlin
              fun main() {
                  val arr = arrayOf("B", "C")
                  print(markdownList("A", *arr, "D"))
                  // * A
                  // * B
                  // * C
                  // * D
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-18_collections-vararg-parameters-and-array-functions-q1"
            question: |-
              In the snippet below, what are the inferred types of r1 and r2?
              
              ```kotlin
              val arr = arrayOf("B", "C")
              val r1 = listOf(arr)
              val r2 = listOf(*arr)
              ```
            explanation: "listOf uses a vararg. Without spread, the array is a single element\
        \ (T = Array<String>). With spread, elements are unpacked (T = String)."
            repeatable: true
            answers:
              - "r1: List<Array<String>>, r2: List<String>"
              - "r1: List<String>, r2: List<String>"
              - "r1: Array<List<String>>, r2: List<String>"
              - "r1: List<String>, r2: List<Array<String>>"
            correct: "r1: List<Array<String>>, r2: List<String>"
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-vararg-parameters-and-array-functions-q2"
            question: "Given `fun markdownList(vararg lines: String): String` and `val arr\
        \ = arrayOf(\"B\", \"C\")`, which calls both compile and produce the order\
        \ A, B, C, D?"
            explanation: "Use the spread operator `*` to unpack arrays into vararg. Without\
        \ spread (`arr`) it's a single element. The order of vararg arguments matters\
        \ for the resulting sequence."
            repeatable: false
            answers:
              - "markdownList(\"A\", *arr, \"D\")"
              - "markdownList(*arrayOf(\"A\", *arr, \"D\"))"
              - "markdownList(\"A\", arr, \"D\")"
              - "markdownList(*arr, \"A\", \"D\")"
              - "markdownList(\"A\", *arr + \"D\")"
            correct:
              - "markdownList(\"A\", *arr, \"D\")"
              - "markdownList(*arrayOf(\"A\", *arr, \"D\"))"
          - type: "text"
            stepId: "lesson-18_collections-summary-text"
            repeatable: false
            text: |-
              In this chapter we've seen the most important kinds of Kotlin collections and their typical use-cases:
              
              * `List` represents an ordered collection of elements. It is the most basic way to keep a collection of elements.
              * `Set` represents a collection of unique elements. We use it when we want to make sure that elements in our collection are unique, or when we often need to look for a certain element.
              * `Map` is a set of key-value pairs. We use it to keep associations from keys to values.
              
              Arrays are rarely used directly in Kotlin as we prefer to use other kinds of collections.
          - type: "question-multiple-answer"
            stepId: "lesson-18_collections-summary-q1"
            question: "In which scenarios is a Kotlin Set the most appropriate choice?"
            explanation: "Set keeps unique elements and is ideal when you often need to\
        \ check membership. It’s not for ordered sequences with duplicates or key–\
        value associations."
            repeatable: true
            answers:
              - "Deduplicating a list of email addresses before sending a newsletter"
              - "Repeatedly checking if an incoming SKU appears on a blacklist"
              - "Keeping todos in the order they were added and allowing duplicates"
              - "Mapping airport IATA codes to airport names"
              - "Maintaining a history of user actions with possible repeats"
            correct:
              - "Deduplicating a list of email addresses before sending a newsletter"
              - "Repeatedly checking if an incoming SKU appears on a blacklist"
          - type: "question-single-answer"
            stepId: "lesson-18_collections-summary-q2"
            question: "You need to store language code → display name associations and look\
        \ them up by code. Which Kotlin collection should you choose?"
            explanation: "Map stores key–value pairs and is the idiomatic choice for associations\
        \ from keys to values."
            repeatable: false
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct: "Map"
      - lessonId: "lesson-operator-overloading"
        name: "Operator overloading"
        steps:
          - type: "text"
            stepId: "lesson-19_operators-#-operator-overloading-text"
            repeatable: false
            text: |-
              In Kotlin, we can add an element to a list using the `+` operator. In the same way, we can add two strings together. We can check if a collection contains an element using the `in` operator. We can also add, subtract or multiply elements of type `BigDecimal`, which is a JVM class that is used to represent possibly big numbers with unlimited precision.
              
              ```kotlin
              import java.math.BigDecimal
              
              fun main() {
                  val list: List<String> = listOf("A", "B")
                  val newList: List<String> = list + "C"
                  println(newList) // [A, B, C]
              
                  val str1: String = "AB"
                  val str2: String = "CD"
                  val str3: String = str1 + str2
                  println(str3) // ABCD
              
                  println("A" in list) // true
                  println("C" in list) // false
              
                  val money1: BigDecimal = BigDecimal("12.50")
                  val money2: BigDecimal = BigDecimal("3.50")
                  val money3: BigDecimal = money1 * money2
                  println(money3) // 43.7500
              }
              ```
              
              Using operators between objects is possible thanks to the Kotlin feature called *operator overloading*, which allows special kinds of methods to be defined that can be used as operators. Let's see this in a custom class example.
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-#-operator-overloading-q1"
            question: "In Kotlin operator overloading, which rewrites are correct? Select\
        \ all that apply."
            explanation: "`a + b` calls `a.plus(b)`, `a * b` calls `a.times(b)`, and `x\
        \ in coll` calls `coll.contains(x)`. The other options reverse receiver/argument\
        \ and are incorrect."
            repeatable: true
            answers:
              - "`a + b`  ->  `a.plus(b)`"
              - "`a * b`  ->  `a.times(b)`"
              - "`x in coll`  ->  `coll.contains(x)`"
              - "`a + b`  ->  `b.plus(a)`"
              - "`x in coll`  ->  `x.contains(coll)`"
            correct:
              - "`a + b`  ->  `a.plus(b)`"
              - "`a * b`  ->  `a.times(b)`"
              - "`x in coll`  ->  `coll.contains(x)`"
          - type: "question-single-answer"
            stepId: "lesson-19_operators-#-operator-overloading-q2"
            question: |-
              Given:
              
              ```kotlin
              val list = listOf("A", "B")
              val newList = list + "C"
              ```
              Which statement is true?
            explanation: "`+` on `List` returns a new list and does not mutate the original\
        \ immutable `List`."
            repeatable: false
            answers:
              - "`list` is unchanged; `newList` is [A, B, C]."
              - "`list` becomes [A, B, C] and `newList` is the same instance."
              - "Compilation error: `+` cannot be used with `List`."
              - "`+` works only with `MutableList`, not `List`."
            correct: "`list` is unchanged; `newList` is [A, B, C]."
          - type: "text"
            stepId: "lesson-19_operators-an-example-of-operator-overloading-text"
            repeatable: false
            text: |-
              Let's say that you need to represent complex numbers in your application. These are special kinds of numbers in mathematics that are represented by two parts: real and imaginary. Complex numbers are useful for a variety of kinds of calculations in physics and engineering.
              
              ```kotlin
              data class Complex(val real: Double, val imaginary: Double)
              ```
              
              In mathematics, there is a range of operations that we can do on complex numbers. For instance, you can add two complex numbers or subtract a complex number from another complex number. This is done using the `+` and `-` operators. Therefore, it is reasonable that we should support these operators for our `Complex` class. To support the `+` operator, we need to define a method that has an `operator` modifier that is called `plus` and a single parameter. To support the `-` operator, we need to define a method that has an `operator` modifier called `minus` and a single parameter.
              
              ```kotlin
              data class Complex(val real: Double, val imaginary: Double) {
              
                  operator fun plus(another: Complex) = Complex(
                      real + another.real,
                      imaginary + another.imaginary
                  )
              
                  operator fun minus(another: Complex) = Complex(
                      real = real - another.real,
                      imaginary = imaginary - another.imaginary
                  )
              }
              
              // example usage
              fun main() {
                  val c1 = Complex(1.0, 2.0)
                  val c2 = Complex(2.0, 3.0)
                  println(c1 + c2) // Complex(real=3.0, imaginary=5.0)
                  println(c2 - c1) // Complex(real=1.0, imaginary=1.0)
              }
              ```
              
              Using the `+` and `-` operators is equivalent to calling the `plus` and `minus` functions. These two can be used interchangeably.
              
              ```kotlin
              c1 + c2 // under the hood is c1.plus(c2)
              c1 - c2 // under the hood is c1.minus(c2)
              ```
              
              Kotlin defines a concrete set of operators, for each of which there is a specific name and a number of supported arguments. Additionally, all operators need to be a method (so, either a member function or an extension function), and these methods need the `operator` modifier.
              
              Well-used operators can help us improve our code readability as much as poorly used operators can harm it. Let's discuss all the Kotlin operators.
          - type: "question-single-answer"
            stepId: "lesson-19_operators-an-example-of-operator-overloading-q1"
            question: "You cannot modify the `Complex` class, but you want `c1 + c2` to\
        \ work for two `Complex` values. Which declaration enables this?"
            explanation: "Operator overloading must be provided by a member or an extension\
        \ function marked with `operator`. Since the class cannot be modified, an\
        \ extension operator with a `Complex` receiver and one `Complex` parameter\
        \ is required."
            repeatable: false
            answers:
              - "operator fun Complex.plus(other: Complex): Complex"
              - "operator fun plus(a: Complex, b: Complex): Complex"
              - "infix fun Complex.plus(other: Complex): Complex"
              - "operator fun Complex.plus(): Complex"
            correct: "operator fun Complex.plus(other: Complex): Complex"
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-an-example-of-operator-overloading-q2"
            question: "Which statements about Kotlin operator overloading are true?"
            explanation: "In Kotlin, `a + b` desugars to `a.plus(b)` when an applicable\
        \ operator function exists. Such functions must be marked with `operator`,\
        \ and can be either member or extension functions. You cannot back `+` with\
        \ a non-operator function, nor define arbitrary operator names/arity."
            repeatable: true
            answers:
              - "The expression `a + b` translates to `a.plus(b)` if an applicable operator\
        \ function exists."
              - "Operator functions must be marked with the `operator` modifier."
              - "Any function named `plus` (even without `operator`) can back the `+` operator."
              - "You can define operators with arbitrary names and arity."
              - "Operator overloads can be declared as member functions or as extension functions."
            correct:
              - "The expression `a + b` translates to `a.plus(b)` if an applicable operator\
        \ function exists."
              - "Operator functions must be marked with the `operator` modifier."
              - "Operator overloads can be declared as member functions or as extension functions."
          - type: "text"
            stepId: "lesson-19_operators-arithmetic-operators-text"
            repeatable: false
            text: |-
              Let's start with arithmetic operators, like plus or times. These are easiest for the Kotlin compiler because it just needs to transform the left column to the right.
              
              | Expression | Translates to     |
              |------------|-------------------|
              | `a + b`    | `a.plus(b)`       |
              | `a - b`    | `a.minus(b)`      |
              | `a * b`    | `a.times(b)`      |
              | `a / b`    | `a.div(b)`        |
              | `a % b`    | `a.rem(b)`        |
              | `a..b `    | `a.rangeTo(b)`    |
              | `a..<b `   | `a.rangeUntil(b)` |
              
              Notice that `%` translates to `rem`, which is a short form of "remainder". This operator returns the remainder left over when one operand is divided by a second operand, so it is similar to the modulo operation.
              
              ```kotlin
              fun main() {
                  println(13 % 4) // 1
                  println(7 % 4)  // 3
                  println(1 % 4)  // 1
                  println(0 % 4)  // 0
                  println(-1 % 4) // -1
                  println(-5 % 4) // -1
                  println(-7 % 4) // -3
              }
              ```
              
              It is also worth mentioning `..` and `..<` operators, that are used to create ranges. We can use them between integers to create `IntRange`, over which we can iterate in for-loop. We can also use those operators between any values that implement `Comparable` interface, to define a range by extremes of this range.
              
              ```kotlin
              fun main() {
                  val intRange: IntRange = 1..10
                  val comparableRange: ClosedRange<String> = "A".."Z"
                  val openEndRange: OpenEndRange<Double> = 1.0..<2.0
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-arithmetic-operators-q1"
            question: "Which translations are correct for Kotlin arithmetic/range operators?"
            explanation: "`%` desugars to `rem`, `/` to `div`, `*` to `times`. `..` maps\
        \ to `rangeTo`, while `..<` maps to `rangeUntil`."
            repeatable: true
            answers:
              - "`a % b` -> `a.rem(b)`"
              - "`a ..< b` -> `a.rangeTo(b)`"
              - "`a / b` -> `a.div(b)`"
              - "`a * b` -> `a.times(b)`"
              - "`a .. b` -> `a.rangeUntil(b)`"
            correct:
              - "`a % b` -> `a.rem(b)`"
              - "`a / b` -> `a.div(b)`"
              - "`a * b` -> `a.times(b)`"
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-arithmetic-operators-q2"
            question: "Which declarations compile as written?"
            explanation: "`..` creates a closed range: `IntRange` for ints and `ClosedRange<T>`\
        \ for `Comparable<T>`. `..<` creates an `OpenEndRange<T>`, so `1..<10` is\
        \ not an `IntRange` nor a `ClosedRange<Int>`."
            repeatable: true
            answers:
              - "val r1: IntRange = 1..10"
              - "val r2: OpenEndRange<Double> = 1.0..<2.0"
              - "val r3: ClosedRange<String> = \"A\"..\"Z\""
              - "val r4: IntRange = 1..<10"
              - "val r5: ClosedRange<Int> = 1..<10"
            correct:
              - "val r1: IntRange = 1..10"
              - "val r2: OpenEndRange<Double> = 1.0..<2.0"
              - "val r3: ClosedRange<String> = \"A\"..\"Z\""
          - type: "text"
            stepId: "lesson-19_operators-the-`in`-operator-text"
            repeatable: false
            text: |-
              One of my favorite operators is `in`. The expression `a in b` translates to `b.contains(a)`. There is also `!in`, which translates to negation.
              
              | Expression | Translates to    |
              |------------|------------------|
              | `a in b`   | `b.contains(a)`  |
              | `a !in b`  | `!b.contains(a)` |
              
              There are a few ways to use this operator. Firstly, for collections, instead of checking if a list contains an element, you can check if the element is in the list.
              
              ```kotlin
              fun main() {
                  val letters = setOf("A", "B", "C")
                  println("A" in letters) // true
                  println("D" in letters) // false
                  println(letters.contains("A")) // true
                  println(letters.contains("D")) // false
              }
              ```
              
              Why would you do that? Primarily for readability. Would you ask "Does the fridge contain a beer?" or "Is there a beer in the fridge?"? Using the `in` operator gives us the possibility to choose.
              
              We also often use the `in` operator together with ranges. The expression `1..10` produces an object of type `IntRange`, which has a `contains` method. This is why you can use `in` and a range to check if a number is in this range.
              
              ```kotlin
              fun main() {
                  println(5 in 1..10) // true
                  println(11 in 1..10) // false
              }
              ```
              
              You can make a range from any objects that are comparable, and the result `ClosedRange` also has a `contains` method. This is why you can use a range check for any objects that are comparable, such as big numbers or objects representing time.
              
              ```kotlin
              import java.math.BigDecimal
              import java.time.LocalDateTime
              
              fun main() {
                  val amount = BigDecimal("42.80")
                  val minPrice = BigDecimal("5.00")
                  val maxPrice = BigDecimal("100.00")
                  val correctPrice = amount in minPrice..maxPrice
                  println(correctPrice) // true
              
                  val now = LocalDateTime.now()
                  val actionStarts = LocalDateTime.of(1410, 7, 15, 0, 0)
                  val actionEnds = actionStarts.plusDays(1)
                  println(now in actionStarts..actionEnds) // false
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-19_operators-the-`in`-operator-q1"
            question: |-
              Given a generic container class:
              
              ```kotlin
              data class Bag<T>(val items: Set<T>)
              ```
              
              To enable type-safe usage of `e in bag` (where `e` must be of type `T`) as a member function, which declaration should you add to `Bag`?
            explanation: "`a in b` translates to `b.contains(a)`. For a custom right-hand\
        \ type, implement `operator fun contains(element: T): Boolean` as a member\
        \ (or extension) to enable type-safe membership tests."
            repeatable: true
            answers:
              - "operator fun contains(element: T): Boolean"
              - "operator fun contains(element: Bag<T>): Boolean"
              - "fun contains(element: T): Boolean"
              - "operator fun T.contains(bag: Bag<T>): Boolean"
            correct: "operator fun contains(element: T): Boolean"
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-the-`in`-operator-q2"
            question: |-
              Consider the following code:
              
              ```kotlin
              val letters = setOf("A", "B", "C")
              val nums = 1..3
              val start = java.time.LocalDateTime.of(2020, 1, 1, 0, 0)
              val end = start.plusDays(1)
              val mid = java.time.LocalDateTime.of(2020, 1, 1, 12, 0)
              ```
              
              Which expressions evaluate to true?
            explanation: |-
              - `in` calls `contains` on the right-hand side.
              - `IntRange` (`1..3`) includes both ends → `3 in nums` is true, so `3 !in nums` is false; `4 !in nums` is true.
              - `LocalDateTime` is `Comparable`, so `start..end` forms a `ClosedRange` inclusive of endpoints, and `mid` lies within it.
            repeatable: true
            answers:
              - "\"B\" in letters"
              - "\"D\" in letters"
              - "3 !in nums"
              - "4 !in nums"
              - "mid in start..end"
            correct:
              - "\"B\" in letters"
              - "4 !in nums"
              - "mid in start..end"
          - type: "text"
            stepId: "lesson-19_operators-the-iterator-operator-text"
            repeatable: false
            text: "You can use for-loop to iterate over any object that has an `iterator`\
        \ operator method. Every object that implements an `Iterable` interface must\
        \ support the `iterator` method. \n\n```kotlin\npublic interface Iterable<out\
        \ T> {\n    /**\n     * Returns an iterator over the elements of this object.\n\
        \     */\n    public operator fun iterator(): Iterator<T>\n}\n```\n\nYou can\
        \ define objects that can be iterated over, but do not implement `Iterable`\
        \ interface. `Map` is a great example. It does not implement the `Iterable`\
        \ interface, yet you can iterate over it using a for-loop. How so? It is thanks\
        \ to the `iterator` operator, which is defined as an extension function in\
        \ Kotlin stdlib.\n\n```kotlin\n// Part of Kotlin standard library\ninline\
        \ operator fun <K, V>\nMap<out K, V>.iterator(): Iterator<Map.Entry<K, V>>\
        \ =\n    entries.iterator()\n\nfun main() {\n    val map = mapOf('a' to \"\
        Alex\", 'b' to \"Bob\")\n    for ((letter, name) in map) {\n        println(\"\
        $letter like in $name\")\n    }\n}\n// a like in Alex\n// b like in Bob\n\
        ```\n\nTo better understand how a for-loop works, consider the code below.\n\
        \n```kotlin\nfun main() {\n    for (e in Tree()) {\n        // body\n    }\n\
        }\n\nclass Tree {\n    operator fun iterator(): Iterator<String> = ...\n}\n\
        ```\n\nUnder the hood, a for-loop is compiled into bytecode that uses a while-loop\
        \ to iterate over the object's iterator, as presented in the snippet below.\n\
        \n```kotlin\nfun main() {\n    val iterator = Tree().iterator()\n    while\
        \ (iterator.hasNext()) {\n        val e = iterator.next()\n        // body\n\
        \    }\n}\n```"
          - type: "question-single-answer"
            stepId: "lesson-19_operators-the-iterator-operator-q1"
            question: "In Kotlin, what element type does `for ((k, v) in map)` iterate over\
        \ for a `Map<K, V>`?"
            explanation: "Kotlin stdlib defines `operator fun Map<out K, V>.iterator():\
        \ Iterator<Map.Entry<K, V>> = entries.iterator()`. Destructuring then unwraps\
        \ each Map.Entry into key and value."
            repeatable: false
            answers:
              - "Map.Entry<K, V>"
              - "Pair<K, V>"
              - "K"
              - "V"
            correct: "Map.Entry<K, V>"
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-the-iterator-operator-q2"
            question: "Given `class Bag { /* no Iterable */ }`, which declarations make\
        \ `for (x in Bag())` compile without changing the loop site?"
            explanation: "A for-loop requires an operator `iterator()` on the receiver (member\
        \ or extension) returning an iterator (with `hasNext`/`next`). Non-operator\
        \ `iterator()` isn’t used by the loop, returning `Sequence` is the wrong return\
        \ type, and `asIterable()` isn’t invoked implicitly."
            repeatable: true
            answers:
              - "Add member: `operator fun iterator(): Iterator<String>`"
              - "Add top-level extension: `operator fun Bag.iterator(): Iterator<String>`"
              - "Add member: `fun iterator(): Iterator<String>`"
              - "Add member: `operator fun iterator(): Sequence<String>`"
              - "Add extension: `fun Bag.asIterable(): Iterable<String>`"
            correct:
              - "Add member: `operator fun iterator(): Iterator<String>`"
              - "Add top-level extension: `operator fun Bag.iterator(): Iterator<String>`"
          - type: "text"
            stepId: "lesson-19_operators-the-equality-and-inequality-operators-text"
            repeatable: false
            text: |-
              In Kotlin, there are two types of equality:
              
              * Structural equality - checked with the `equals` method or the `==` operator (and its negated counterpart `!=`). `a == b` translates to `a.equals(b)` when `a` is not nullable, otherwise it translates to `a?.equals(b) ?: (b === null)`. Structural equality is generally preferred over referential equality. The `equals` method can be overridden in custom class.
              
              * Referential equality - checked with the `===` operator (and its negated counterpart `!==`); returns `true` when both sides point to the same object. `===` and `!==` (identity checks) are not overloadable.
              
              Since `equals` is implemented in `Any`, which is the superclass of every class, we can check the equality of any two objects.
              
              | Expression | Translates to                     |
              |------------|-----------------------------------|
              | `a == b`   | `a?.equals(b) ?: (b === null)`    |
              | `a != b`   | `!(a?.equals(b) ?: (b === null))` |
          - type: "question-single-answer"
            stepId: "lesson-19_operators-the-equality-and-inequality-operators-q1"
            question: "For a nullable receiver `a` (any type), which rewrite matches Kotlin’\
        s translation of `a != b`?"
            explanation: "`a != b` is negation of the `==` translation: `a?.equals(b) ?:\
        \ (b === null)`, so it becomes `!(...)`."
            repeatable: true
            answers:
              - "!(a?.equals(b) ?: (b === null))"
              - "a?.equals(b) == false || (b === null)"
              - "a?.equals(b) ?: (b !== null)"
              - "a == null && b == null"
            correct: "!(a?.equals(b) ?: (b === null))"
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-the-equality-and-inequality-operators-q2"
            question: |-
              Given:
              
              ```kotlin
              class Box(val id: Int) {
                  override fun equals(other: Any?): Boolean =
                      other is Box && other.id == id
              }
              
              val b1 = Box(1)
              val b2 = Box(1)
              ```
              Which expressions evaluate to true?
            explanation: "Overridden equals makes structural equality true for same id (`b1\
        \ == b2`). Referential equality requires the same object (`b1 === b2` is false;\
        \ `b1 === b1` is true). `b1 == null` is false."
            repeatable: false
            answers:
              - "b1 == b2"
              - "b1 === b2"
              - "b1 != b2"
              - "b1 === b1"
              - "b1 == null"
            correct:
              - "b1 == b2"
              - "b1 === b1"
          - type: "text"
            stepId: "lesson-19_operators-comparison-operators-text"
            repeatable: false
            text: |-
              Some classes have natural order, which is the order that is used by default when we compare two instances of a given class. Numbers are a good example: 10 is a smaller number than 100. There is a popular Java convention that classes with natural order should implement a `Comparable` interface, which requires the `compareTo` method, which is used to compare two objects.
              
              ```kotlin
              public interface Comparable<in T> {
                  /**
                   * Compares this object with the specified object for
                   * order. Returns zero if this object is equal to the
                   * specified [other] object, a negative number if it's
                   * less than [other], or a positive number if it's
                   * greater than [other].
                   */
                  public operator fun compareTo(other: T): Int
              }
              ```
              
              As a result, there is a convention that we should compare two objects using the `compareTo` method. However, using the `compareTo` method directly is not very intuitive. Let's say that you see `a.compareTo(b) > 0` in code. What does it mean? Kotlin simplifies this by making `compareTo` an operator that can be replaced with intuitive mathematical comparison operators: `>`, `<`, `>=`, and `<=`.
              
              | Expression | Translates to         |
              |------------|-----------------------|
              | `a > b`    | `a.compareTo(b) > 0`  |
              | `a < b`    | `a.compareTo(b) < 0`  |
              | `a >= b`   | `a.compareTo(b) >= 0` |
              | `a <= b`   | `a.compareTo(b) <= 0` |
              
              I often use comparison operators to compare amounts kept in objects of type `BigDecimal` or `BigInteger`.
              
              ```kotlin
              import java.math.BigDecimal
              
              fun main() {
                  val amount1 = BigDecimal("42.80")
                  val amount2 = BigDecimal("5.00")
                  println(amount1 > amount2) // true
                  println(amount1 >= amount2) // true
                  println(amount1 < amount2) // false
                  println(amount1 <= amount2) // false
                  println(amount1 > amount1) // false
                  println(amount1 >= amount1) // true
                  println(amount1 < amount2) // false
                  println(amount1 <= amount2) // false
              }
              ```
              
              I also like to compare time references the same way.
              
              ```kotlin
              import java.time.LocalDateTime
              
              fun main() {
                  val now = LocalDateTime.now()
                  val actionStarts = LocalDateTime.of(2010, 10, 20, 0, 0)
                  val actionEnds = actionStarts.plusDays(1)
                  println(now > actionStarts) // true
                  println(now <= actionStarts) // false
                  println(now < actionEnds) // false
                  println(now >= actionEnds) // true
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-19_operators-comparison-operators-q1"
            question: "In Kotlin, what does the expression `a <= b` translate to (assuming\
        \ `a`'s type provides a valid `compareTo`)?"
            explanation: "`<=` is desugared to `compareTo(other) <= 0`. The other options\
        \ either flip the operands or change the relation."
            repeatable: false
            answers:
              - "a.compareTo(b) <= 0"
              - "a.compareTo(b) < 0"
              - "b.compareTo(a) >= 0"
              - "a.compareTo(b) == 0"
            correct: "a.compareTo(b) <= 0"
          - type: "question-single-answer"
            stepId: "lesson-19_operators-comparison-operators-q2"
            question: "Which declaration correctly enables using `>` between two `Money`\
        \ instances?"
            explanation: "Comparison operators require an `operator` `compareTo` returning\
        \ `Int`. Overriding `Comparable.compareTo` (already marked operator) suffices.\
        \ Boolean/Long return types or a non-operator member won't enable `>`."
            repeatable: true
            answers:
              - "class Money : Comparable<Money> { override fun compareTo(other: Money): Int\
        \ = /* ... */ }"
              - "class Money { operator fun compareTo(other: Money): Boolean = /* ... */ }"
              - "class Money : Comparable<Money> { operator fun compareTo(other: Money): Long\
        \ = /* ... */ }"
              - "class Money { fun compareTo(other: Money): Int = /* ... */ }"
            correct: "class Money : Comparable<Money> { override fun compareTo(other: Money):\
        \ Int = /* ... */ }"
          - type: "text"
            stepId: "lesson-19_operators-the-indexed-access-operator-text"
            repeatable: false
            text: |-
              In programming, there are two popular conventions for getting or setting elements in collections. The first uses box brackets, while the second uses the `get` and `set` methods. In Java, we use the first convention for arrays and the second one for other kinds of collections. In Kotlin, both conventions can be used interchangeably because the `get` and `set` methods are operators that can be used with box brackets.
              
              | Expression             | Translates to             |
              |------------------------|---------------------------|
              | `a[i]`                 | `a.get(i)`                |
              | `a[i, j]`              | `a.get(i, j)`             |
              | `a[i_1, ..., i_n]`     | `a.get(i_1, ..., i_n)`    |
              | `a[i] = b`             | `a.set(i, b)`             |
              | `a[i, j] = b`          | `a.set(i, j, b)`          |
              | `a[i_1, ..., i_n] = b` | `a.set(i_1, ..., i_n, b)` |
              
              ```kotlin
              fun main() {
                  val mutableList = mutableListOf("A", "B", "C")
                  println(mutableList[1]) // B
                  mutableList[2] = "D"
                  println(mutableList) // [A, B, D]
              
                  val animalFood = mutableMapOf(
                      "Dog" to "Meat",
                      "Goat" to "Grass"
                  )
                  println(animalFood["Dog"]) // Meat
                  animalFood["Cat"] = "Meat"
                  println(animalFood["Cat"]) // Meat
              }
              ```
              
              Square brackets are translated to `get` and `set` calls with appropriate numbers of arguments. Variants of `get` and `set` functions with more arguments might be used by data processing libraries. For instance, you could have an object that represents a table and use box brackets with two arguments: `x` and `y` coordinates.
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-the-indexed-access-operator-q1"
            question: |-
              Given the following code, which expressions compile?
              
              ```kotlin
              class Matrix {
                  operator fun get(x: Int, y: Int): Int = 0
                  operator fun set(x: Int, y: Int, value: Int) {}
                  operator fun get(index: Int): Int = 0
              }
              
              val m = Matrix()
              ```
            explanation: "`a[i, j]` maps to `get(i, j)` and `a[i, j] = v` maps to `set(i,\
        \ j, v)`. `a[i]` maps to `get(i)`. There is no `set(i, v)` and no 3-argument\
        \ `get`."
            repeatable: true
            answers:
              - "m[1, 2]"
              - "m[1, 2] = 3"
              - "m[0]"
              - "m[0] = 1"
              - "m[1, 2, 3]"
            correct:
              - "m[1, 2]"
              - "m[1, 2] = 3"
              - "m[0]"
          - type: "question-single-answer"
            stepId: "lesson-19_operators-the-indexed-access-operator-q2"
            question: "You are implementing a generic grid `class Grid<T>`. To support writing\
        \ `grid[x, y] = value`, which function signature must you add?"
            explanation: "`a[i, j] = v` translates to `a.set(i, j, v)`. It must be an `operator`\
        \ function with the indices first and the value last, returning `Unit`."
            repeatable: false
            answers:
              - "operator fun set(x: Int, y: Int, value: T): Unit"
              - "operator fun get(x: Int, y: Int, value: T): Unit"
              - "fun set(x: Int, y: Int, value: T): Unit"
              - "operator fun set(value: T, x: Int, y: Int): Unit"
            correct: "operator fun set(x: Int, y: Int, value: T): Unit"
          - type: "text"
            stepId: "lesson-19_operators-augmented-assignments-text"
            repeatable: false
            text: |-
              When we set a new value for a variable, this new value is often based on its previous value. For instance, we might want to add a value to the previous one. For this, augmented assignments were introduced. For example, `a += b` is a shorter notation of `a = a + b`. There are similar notations for other arithmetic operations.
              
              | Expression | Translates to |
              |------------|---------------|
              | `a += b`   | `a = a + b`   |
              | `a -= b`   | `a = a - b`   |
              | `a *= b`   | `a = a * b`   |
              | `a /= b`   | `a = a / b`   |
              | `a %= b`   | `a = a % b`   |
              
              Notice that augmented assignments can be used for all types that support the appropriate arithmetic operation, including lists or strings. Such augmented assignments need a variable to be read-write, namely `var`, and the result of the mathematical operation must have a proper type (to translate `a += b` to `a = a + b`, the variable `a` needs to be `var`, and `a + b` needs to be a subtype of type `a`).
              
              ```kotlin
              fun main() {
                  var str = "ABC"
                  str += "D" // translates to str = str + "D"
                  println(str) // ABCD
              
                  var l = listOf("A", "B", "C")
                  l += "D" // translates to l = l + "D"
                  println(l) // [A, B, C, D]
              }
              ```
              
              Augmented assignments can be used in another way: to modify a mutable object. For instance, we can use `+=` to add an element to a mutable list. In such a case, `a += b` translates to `a.plusAssign(b)`.
              
              | Expression | Translates to      |
              |------------|--------------------|
              | `a += b`   | `a.plusAssign(b)`  |
              | `a -= b`   | `a.minusAssign(b)` |
              | `a *= b`   | `a.timesAssign(b)` |
              | `a /= b`   | `a.divAssign(b)`   |
              | `a %= b`   | `a.remAssign(b)`   |
              
              ```kotlin
              fun main() {
                  val names = mutableListOf("Jake", "Ben")
                  names += "Jon"
                  names -= "Ben"
                  println(names) // [Jake, Jon]
              
                  val tools = mutableMapOf(
                      "Grass" to "Lawnmower",
                      "Nail" to "Hammer"
                  )
                  tools += "Screw" to "Screwdriver"
                  tools -= "Grass"
                  println(tools) // {Nail=Hammer, Screw=Screwdriver}
              }
              ```
              
              If both kinds of augmented assignment can be applied, Kotlin chooses to modify a mutable object by default.
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-augmented-assignments-q1"
            question: "Which of the following Kotlin snippets compile as-is?"
            explanation: "If no plusAssign is available, A += B desugars to A = A + B and\
        \ requires A to be var. If plusAssign exists (e.g., MutableList, MutableMap),\
        \ it’s used and A can be val."
            repeatable: false
            answers:
              - "val s = \"ABC\"; s += \"D\""
              - "var s = \"ABC\"; s += \"D\""
              - "val l = listOf(\"A\"); l += \"B\""
              - "var l = listOf(\"A\"); l += \"B\""
              - "val ml = mutableListOf(\"A\"); ml += \"B\""
              - "val tools = mutableMapOf(\"Nail\" to \"Hammer\"); tools += \"Screw\" to \"\
        Screwdriver\""
            correct:
              - "var s = \"ABC\"; s += \"D\""
              - "var l = listOf(\"A\"); l += \"B\""
              - "val ml = mutableListOf(\"A\"); ml += \"B\""
              - "val tools = mutableMapOf(\"Nail\" to \"Hammer\"); tools += \"Screw\" to \"\
        Screwdriver\""
          - type: "question-single-answer"
            stepId: "lesson-19_operators-augmented-assignments-q2"
            question: "When both operator functions plus and plusAssign are applicable for\
        \ an expression A += B, what does Kotlin choose?"
            explanation: "Kotlin prefers the in-place modification form: A += B resolves\
        \ to A.plusAssign(B) if available; otherwise it desugars to A = A + B."
            repeatable: true
            answers:
              - "It always uses plusAssign to modify the receiver."
              - "It always translates to A = A + B."
              - "It prefers plus if A is var and plusAssign otherwise."
              - "It is ambiguous and does not compile."
            correct: "It always uses plusAssign to modify the receiver."
          - type: "text"
            stepId: "lesson-19_operators-unary-prefix-operators-text"
            repeatable: false
            text: |-
              A plus, minus, or negation in front of a single value is also an operator. Operators that are used with only a single value are called **unary operators**. Kotlin supports operator overloading for the following unary operators:
              
              | Expression | Translates to    |
              |------------|------------------|
              | `+a`       | `a.unaryPlus()`  |
              | `-a`       | `a.unaryMinus()` |
              | `!a`       | `a.not()`        |
              
              Here is an example of overloading the `unaryMinus` operator.
              
              ```kotlin
              data class Point(val x: Int, val y: Int)
              
              operator fun Point.unaryMinus() = Point(-x, -y)
              
              fun main() {
                  val point = Point(10, 20)
                  println(-point)  // Point(x=-10, y=-20)
              }
              ```
              
              The `unaryPlus` operator is often used as part of Kotlin DSLs, which are described in detail in the book of this series, *Functional Kotlin*.
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-unary-prefix-operators-q1"
            question: |-
              Given:
              
              ```kotlin
              data class Point(val x: Int, val y: Int)
              ```
              Which declarations would make the expression `-point` valid? Choose all that apply.
            explanation: "`-a` maps to `a.unaryMinus()`. It must be named `unaryMinus`,\
        \ take no parameters, and be marked `operator`. It can be either a member\
        \ or an extension."
            repeatable: true
            answers:
              - "Top-level extension: `operator fun Point.unaryMinus() = Point(-x, -y)`"
              - "Member inside Point: `operator fun unaryMinus() = Point(-x, -y)`"
              - "Top-level extension: `fun Point.unaryMinus() = Point(-x, -y)`"
              - "Top-level extension: `operator fun Point.minus() = Point(-x, -y)`"
              - "Top-level extension: `operator fun Point.unaryMinus(other: Int) = Point(-x,\
        \ -y)`"
            correct:
              - "Top-level extension: `operator fun Point.unaryMinus() = Point(-x, -y)`"
              - "Member inside Point: `operator fun unaryMinus() = Point(-x, -y)`"
          - type: "question-single-answer"
            stepId: "lesson-19_operators-unary-prefix-operators-q2"
            question: "You want to support `!user` as an extension operator on class `User`.\
        \ Which signature is correct?"
            explanation: "`!a` maps to `a.not()`; for operator overloading it must be named\
        \ `not`, be marked `operator`, be an extension in this case, take no parameters,\
        \ and return `Boolean`."
            repeatable: false
            answers:
              - "operator fun User.not(): Boolean"
              - "operator fun User.not(): User"
              - "fun User.not(): Boolean"
              - "operator fun not(): Boolean"
              - "operator fun User.unaryNot(): Boolean"
            correct: "operator fun User.not(): Boolean"
          - type: "text"
            stepId: "lesson-19_operators-increment-and-decrement-text"
            repeatable: false
            text: |-
              As part of many algorithms used in older languages, we often needed to add or subtract the value `1` from a variable, which is why increment and decrement were invented. The `++` operator is used to add `1` to a variable; so, if `a` is an integer, then `a++` translates to `a = a + 1`. The `--` operator is used to subtract `1` from a variable; so, if `a` is an integer, then `a--` translates to `a = a - 1`.
              
              Both increment and decrement can be used before or after a variable, and this determines the value returned by this operation.
              * If you use `++` **before** a variable, it is called **pre-increment**; it increments the variable and then returns the result of this operation.
              * If you use `++` **after** a variable, it is called **post-increment**; it increments the variable but then returns the value before the operation.
              * If you use `--` **before** a variable, it is called **pre-decrement**; it decrements the variable and then returns the result of this operation.
              * If you use `--` **after** a variable, it is called **post-decrement**; it decrements the variable but then returns the value before the operation.
              
              ```kotlin
              fun main() {
                  var i = 10
                  println(i++) // 10
                  println(i) // 11
                  println(++i) // 12
                  println(i) // 12
              
                  i = 10
                  println(i--) // 10
                  println(i) // 9
                  println(--i) // 8
                  println(i) // 8
              }
              ```
              
              Based on the `inc` and `dec` methods, Kotlin supports increment and decrement overloading, which should increment or decrement a custom object. I have never seen this capability used in practice, so I think it is enough to know that it exists.
              
              | Expression | Translates to (simplified)      |
              |------------|---------------------------------|
              | `++a`      | `a = a.inc(); a`                |
              | `a++`      | `val tmp = a; a = a.inc(); tmp` |
              | `--a`      | `a = a.dec(); a`                |
              | `a--`      | `val tmp = a; a = a.dec(); tmp` |
          - type: "question-single-answer"
            stepId: "lesson-19_operators-increment-and-decrement-q1"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  var i = 5
                  val a = i++
                  val b = ++i
                  val c = i--
                  val d = --i
                  println("$a $b $c $d $i")
              }
              ```
            explanation: "Post-increment returns the old value and then increments; pre-increment\
        \ increments first and returns the new value. Same for decrement. So: a=5\
        \ (i→6), b=7 (i→7), c=7 (i→6), d=5 (i→5)."
            repeatable: false
            answers:
              - "5 7 7 5 5"
              - "6 7 7 6 6"
              - "6 6 7 6 5"
              - "5 6 7 5 5"
            correct: "5 7 7 5 5"
          - type: "question-single-answer"
            stepId: "lesson-19_operators-increment-and-decrement-q2"
            question: |-
              Given operator overloading via `inc/dec`, what is the output?
              
              ```kotlin
              data class Box(val n: Int) {
                  operator fun inc() = Box(n + 1)
                  operator fun dec() = Box(n - 1)
              }
              
              fun main() {
                  var b = Box(10)
                  val p = b++
                  val q = ++b
                  val r = b--
                  val s = --b
                  println(listOf(p.n, q.n, r.n, s.n, b.n))
              }
              ```
            explanation: "For custom types, `++a` translates to `a = a.inc(); a` and `a++`\
        \ to `val tmp = a; a = a.inc(); tmp`. Tracking values: p=10, b=11; q=12, b=12;\
        \ r=12, b=11; s=10, b=10 ⇒ [10, 12, 12, 10, 10]."
            repeatable: false
            answers:
              - "[10, 12, 12, 10, 10]"
              - "[11, 12, 12, 11, 10]"
              - "[10, 11, 12, 11, 10]"
              - "[10, 12, 11, 10, 10]"
            correct: "[10, 12, 12, 10, 10]"
          - type: "text"
            stepId: "lesson-19_operators-the-invoke-operator-text"
            repeatable: false
            text: |-
              Objects with the `invoke` operator can be called like functions, so with parentheses straight after the variable representing this object. Calling an object translates to the `invoke` method call with the same arguments.
              
              | Expression         | Translates to             |
              |--------------------|---------------------------|
              | `a()`              | `a.invoke()`              |
              | `a(i)`             | `a.invoke(i)`             |
              | `a(i, j)`          | `a.invoke(i, j)`          |
              | `a(i_1, ..., i_n)` | `a.invoke(i_1, ..., i_n)` |
              
              The `invoke` operator is used for objects that represent functions, such as lambda expressions or UseCases objects from Clean Architecture.
              
              ```kotlin
              class CheerUseCase {
                  operator fun invoke(who: String) {
                      println("Hello, $who")
                  }
              }
              
              fun main() {
                  val hello = {
                      println("Hello")
                  }
                  hello() // Hello
              
                  val cheerUseCase = CheerUseCase()
                  cheerUseCase("Reader") // Hello, Reader
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-the-invoke-operator-q1"
            question: "Which statements about Kotlin's invoke operator are true?"
            explanation: "Calling with parentheses desugars to `.invoke(...)`. Lambdas are\
        \ function objects whose `invoke` is callable directly. Any class can define\
        \ `operator fun invoke(...)` to be callable; it doesn't have to return Unit."
            repeatable: true
            answers:
              - "`a(i, j)` is syntax sugar for `a.invoke(i, j)`."
              - "Only lambdas and function types can be called with parentheses."
              - "Defining `operator fun invoke(who: String)` inside a class lets its instances\
        \ be called like `obj(\"Alice\")`."
              - "The invoke operator must return `Unit`."
              - "For `val hello = { println(\"Hello\") }`, `hello()` and `hello.invoke()`\
        \ are equivalent."
            correct:
              - "`a(i, j)` is syntax sugar for `a.invoke(i, j)`."
              - "Defining `operator fun invoke(who: String)` inside a class lets its instances\
        \ be called like `obj(\"Alice\")`."
              - "For `val hello = { println(\"Hello\") }`, `hello()` and `hello.invoke()`\
        \ are equivalent."
          - type: "question-single-answer"
            stepId: "lesson-19_operators-the-invoke-operator-q2"
            question: |-
              Which implementation makes all the calls compile and print exactly as annotated?
              
              ```kotlin
              class Counter { /* choose one implementation */ }
              
              fun main() {
                  val c = Counter()
                  c()           // prints: 0
                  c(5)          // prints: 5
                  c(2, 3)       // prints: 2 3
              }
              ```
            explanation: "Only option A defines member operator overloads matching each\
        \ arity and prints the required formats. Option B lacks the `operator` modifier,\
        \ C defines invoke on the companion (not instance), and D prints with a comma\
        \ and space."
            repeatable: false
            answers:
              - |-
                ```kotlin
                class Counter {
                    operator fun invoke() = println("0")
                    operator fun invoke(x: Int) = println(x)
                    operator fun invoke(x: Int, y: Int) = println("$x $y")
                }
                ```
              - |-
                ```kotlin
                class Counter {
                    fun invoke() = println("0")
                    fun invoke(x: Int) = println(x)
                    fun invoke(x: Int, y: Int) = println("$x $y")
                }
                ```
              - |-
                ```kotlin
                class Counter {
                    companion object {
                        operator fun invoke() = println("0")
                        operator fun invoke(x: Int) = println(x)
                        operator fun invoke(x: Int, y: Int) = println("$x $y")
                    }
                }
                ```
              - |-
                ```kotlin
                operator fun Counter.invoke(vararg xs: Int) {
                    if (xs.isEmpty()) println("0") else println(xs.joinToString(", "))
                }
                ```
            correct: |-
              ```kotlin
              class Counter {
                  operator fun invoke() = println("0")
                  operator fun invoke(x: Int) = println(x)
                  operator fun invoke(x: Int, y: Int) = println("$x $y")
              }
              ```
          - type: "text"
            stepId: "lesson-19_operators-precedence-text"
            repeatable: false
            text: |-
              What is the result of the expression `1 + 2 * 3`? The answer is `7`, not `9`, because in mathematics we multiply before adding. We say that multiplication has higher precedence than addition.
              
              Precedence is also extremely important in programming because when the compiler evaluates an expression such as `1 + 2 == 3`, it needs to know if it should first add `1` to `2`, or compare `2` and `3`. The following table compares the precedence of all the operators, including those that can be overloaded and those that cannot.
              
              | Precedence | Title           | Symbols                                  |
              |------------|-----------------|------------------------------------------|
              | Highest    | Postfix         | ++, --, . (regular call), ?. (safe call) |
              |            | Prefix          | -, +, ++, --, !                          |
              |            | Type casting    | as, as?                                  |
              |            | Multiplicative  | *, /, %                                  |
              |            | Additive        | +, -                                     |
              |            | Range           | ..                                       |
              |            | Infix function  | simpleIdentifier                         |
              |            | Elvis           | ?:                                       |
              |            | Named checks    | in, !in, is, !is                         |
              |            | Comparison      | <, >, <=, >=                             |
              |            | Equality        | ==, !=, ===, !==                         |
              |            | Conjunction     | &&                                       |
              |            | Disjunction     | \                                        |\|                  |
              |            | Spread operator | *                                        |
              | Lowest     | Assignment      | =, +=, -=, *=, /=, %=                    |
              
              On the basis of this table, can you predict what the following code will print?
              
              ```kotlin
              fun main() {
                  println(-1.plus(1))
              }
              ```
              
              This is a popular Kotlin puzzle. The answer is `-2`, not `0`, because a single minus in front of a function is an operator whose precedence is lower than an explicit `plus` method call. So, we first call the method and then call `unaryMinus` on the result, therefore we change from `2` to `-2`. To use `-1` literally, wrap it with parentheses.
              
              ```kotlin
              fun main() {
                  println((-1).plus(1)) // 0
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-19_operators-precedence-q1"
            question: |-
              What does this program print?
              
              ```kotlin
              fun main() {
                  println(1..2 + 3)
              }
              ```
            explanation: "`..` (Range) has higher precedence than `+` (Additive), so it\
        \ is parsed as `1..(2 + 3)` → `1..5`."
            repeatable: false
            answers:
              - "1..5"
              - "1..2"
              - "3..3"
              - "Compile-time error"
            correct: "1..5"
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-precedence-q2"
            question: "Which of the following expressions evaluate to true given Kotlin\
        \ operator precedence?"
            explanation: |-
              - Method call `.` (postfix) binds before unary `-` (prefix), so `-1.plus(1)` is `-(1.plus(1))` → `-2`.
              - Parentheses force `(-1).plus(1)` → `0`.
              - `..` (Range) binds before `+`, and `in` is lower than Range: `1 in 1..(2+2)` → `1 in 1..4` → true.
              - `-1..1` is `(-1)..1`, which is not equal to `0..1`.
              - `&&` binds before `||`: `(true && false) || true` → `false || true` → true.
            repeatable: true
            answers:
              - "`-1.plus(1) == -2`"
              - "`(-1).plus(1) == 0`"
              - "`1 in 1..2 + 2`"
              - "`-1..1 == 0..1`"
              - "`(1 + 2 == 3) && false || true`"
            correct:
              - "`-1.plus(1) == -2`"
              - "`(-1).plus(1) == 0`"
              - "`1 in 1..2 + 2`"
              - "`(1 + 2 == 3) && false || true`"
          - type: "text"
            stepId: "lesson-19_operators-summary-text"
            repeatable: false
            text: "We use a lot of operators in Kotlin, many of which can be overloaded.\
        \ This can be used to improve our code’s readability. From the cognitive standpoint,\
        \ using an intuitive operator can be a huge improvement over using methods\
        \ everywhere. Therefore, iit’s good to know what options are available and\
        \ to be open to using operators defined by Kotlin stdlib, but it’s also good\
        \ to be able to define our own operators."
          - type: "question-multiple-answer"
            stepId: "lesson-19_operators-summary-q1"
            question: "In Kotlin operator overloading, which statements are correct?"
            explanation: |-
              - Kotlin does not let you invent new symbols or change precedence.
              - `==` translates to the member `equals(Any?)`; extension `equals` is ignored for `==`.
              - `&&`/`||` are not overloadable (short-circuit semantics).
              - `in` maps to `contains`, and `()` maps to `invoke`.
            repeatable: true
            answers:
              - "You cannot introduce new operator symbols or change operator precedence."
              - "`==` uses `equals(Any?)` and an extension `equals` is ignored for `==`."
              - "Short-circuit logical operators `&&` and `||` can be overloaded via operator\
        \ functions."
              - "The `in` operator can be supported by defining `operator fun contains(...)`."
              - "The call operator `()` can be supported by defining `operator fun invoke(...)`."
            correct:
              - "You cannot introduce new operator symbols or change operator precedence."
              - "`==` uses `equals(Any?)` and an extension `equals` is ignored for `==`."
              - "The `in` operator can be supported by defining `operator fun contains(...)`."
              - "The call operator `()` can be supported by defining `operator fun invoke(...)`."
          - type: "question-single-answer"
            stepId: "lesson-19_operators-summary-q2"
            question: |-
              To support both reading and writing via bracket syntax with two indices:
              
              ```
              val x = matrix[1, 2]
              matrix[1, 2] = 5
              ```
              Which operator function signatures must `Matrix` provide?
            explanation: "`[]` maps to `get(...)` and `set(..., value)`. Two indices mean\
        \ two parameters; `set` adds the value as the last parameter."
            repeatable: true
            answers:
              - "operator fun get(row: Int, col: Int): Int and operator fun set(row: Int,\
        \ col: Int, value: Int)"
              - "operator fun get(index: Pair<Int, Int>): Int and operator fun set(index:\
        \ Pair<Int, Int>, value: Int)"
              - "operator fun invoke(row: Int, col: Int): Int and operator fun invokeAssign(row:\
        \ Int, col: Int, value: Int)"
              - "operator var get(row: Int, col: Int): Int"
            correct: "operator fun get(row: Int, col: Int): Int and operator fun set(row:\
        \ Int, col: Int, value: Int)"
      - lessonId: "lesson-the-beauty-of-kotlin’s-type-system"
        name: "The beauty of Kotlin’s type system"
        steps:
          - type: "text"
            stepId: "lesson-20_type_system-{sample:-true}-text"
            repeatable: false
            text: |-
              # The beauty of Kotlin’s type system
              
              The Kotlin type system is amazingly designed. Many features that look like special cases are just a natural consequence of how the type system is designed. For instance, thanks to the type system, in the example below the type of `surname` is `String`, the type of `age` is `Int`, and we can use `return` and `throw` on the right side of the Elvis operator.
              
              ```kotlin
              fun processPerson(person: Person?) {
                  val name = person?.name ?: "unknown"
              
                  val surname = person?.surname ?: return
              
                  val age = person?.age ?: throw Error("Person must have age")
              
                  // ...
              }
              ```
              
              The typing system also gives us very convenient nullability support, smart type inference, and much more. In this chapter, we will reveal a lot of Kotlin magic. I always love talking about this in my workshops because I see the stunning beauty of how Kotlin’s type system is so well designed that all these pieces fit perfectly together and give us a great programming experience. I find this topic fascinating, but I will also try to add some useful hints that show where this knowledge can be useful in practice. I hope you will enjoy discovering it as much as I did.
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-{sample:-true}-q1"
            question: |-
              Why does this compile?
              
              ```kotlin
              fun process(person: Person?) {
                  val surname = person?.surname ?: return
              }
              ```
            explanation: "In Kotlin, return and throw have type Nothing, which is a subtype\
        \ of all types. Thus they are valid RHS for ?: when a non-null value of any\
        \ type is expected."
            repeatable: true
            answers:
              - "Because return has type Nothing, a subtype of every type, so it fits the\
        \ expected non-null type."
              - "Because the Elvis operator treats any statement as a valid alternative."
              - "Because Kotlin automatically converts Unit to the expected type on the right\
        \ of ?:."
              - "Because smart cast rewrites return into a String at compile time."
            correct: "Because return has type Nothing, a subtype of every type, so it fits\
        \ the expected non-null type."
          - type: "question-multiple-answer"
            stepId: "lesson-20_type_system-{sample:-true}-q2"
            question: |-
              Which lines compile? Assume this function:
              
              ```kotlin
              fun f(s: String?): String {
                  // Choose all compiling lines (independent statements)
              }
              ```
            explanation: "RHS of ?: must be compatible with the expected type or be Nothing.\
        \ A String literal matches String. return and throw are Nothing, so they also\
        \ fit. println returns Unit (mismatch), and 0 is Int (mismatch)."
            repeatable: false
            answers:
              - "val a: String = s ?: \"unknown\""
              - "val b: String = s ?: return \"fallback\""
              - "val c: String = s ?: throw IllegalStateException()"
              - "val d: String = s ?: println(\"missing\")"
              - "val e: Int = s ?: 0"
            correct:
              - "val a: String = s ?: \"unknown\""
              - "val b: String = s ?: return \"fallback\""
              - "val c: String = s ?: throw IllegalStateException()"
          - type: "text"
            stepId: "lesson-20_type_system-what-is-a-type?-text"
            repeatable: false
            text: |-
              Before we start talking about the type system, we should first explain what a type is. Do you know the answer? Think about it for a moment.
              
              Types are commonly confused with classes, but these two terms represent totally different concepts. Take a look at the example below. You can see `User` used four times. Can you tell me which usages are classes, which are types, and which are something else?
              
              ![](typing_system_type_vs_class_question.png)
              
              After the `class` keyword, you define a class name. A class is a template for objects that defines a set of properties and methods. When we call a constructor, we create an object. Types are used here to specify what kind of objects we expect to have in the variables.
              
              ![](typing_system_type_vs_class.png)
          - type: "question-multiple-answer"
            stepId: "lesson-20_type_system-what-is-a-type?-q1"
            question: |-
              Given the code:
              
              ```kotlin
              class User(val name: String)
              
              val u: User = User("Ana")
              fun send(u: User) {}
              
              val users: List<User> = listOf(User("A"))
              val ctor = ::User
              ```
              Select all places where `User` is used as a type.
            explanation: "`class User` declares a class (a template). `User` in `val u:\
        \ User`, in parameter `u: User`, and as `List<User>` is a type annotation.\
        \ `::User` is a constructor reference, not a type."
            repeatable: true
            answers:
              - "In `class User(val name: String)`"
              - "In `val u: User = ...`"
              - "In `fun send(u: User) {}`"
              - "In `val users: List<User> = ...`"
              - "In `val ctor = ::User`"
            correct:
              - "In `val u: User = ...`"
              - "In `fun send(u: User) {}`"
              - "In `val users: List<User> = ...`"
          - type: "text"
            stepId: "lesson-20_type_system-why-do-we-have-types?-text"
            repeatable: false
            text: |-
              Let's do a thought experiment for a moment. Kotlin is a statically typed language, so all variables and functions must be typed. If we do not specify their types explicitly, they will be inferred. But let's take a step back and imagine that you are a language designer who is deciding what Kotlin should look like. It is possible to drop all these requirements and eliminate all types completely. The compiler does not really need them. It has classes that define how objects should be created, and it has objects that are used during execution. What do we lose if we get rid of types? Mostly safety and developers' convenience.
              
              ![](typing_system_type_vs_class_crossed.png)
              
              It is worth mentioning that many languages do support classes and objects but not types. Among them, there is JavaScript and (not long ago) Python - two of the most popular languages in the world. However, types do offer us value, which is why in the JavaScript community more and more people use TypeScript (which is basically JavaScript plus types), and Python has introduced support for types.
              
              So why do we have types? They are mainly for us, developers. A type tells us what methods or properties we can use on an object. A type tells us what kind of value can be used as an argument. Types prevent the use of incorrect objects, methods, or properties. They give us safety, and suggestions are provided by the IDE. The compiler also benefits from types as they are used to better optimize our code or to decide which function should be chosen when its name is overloaded. Still, it is developers who are the most important beneficent of types.
              
              So what is a type? **It can be considered as a set of things we can do with an object**. Typically, it is a set of methods and properties.
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-why-do-we-have-types?-q1"
            question: "In Kotlin, what is a \"type\" best understood as?"
            explanation: "In this chapter, a type is described as the set of things you\
        \ can do with a value—typically its accessible methods and properties."
            repeatable: true
            answers:
              - "A set of methods and properties you can use on a value"
              - "The concrete class used to allocate objects"
              - "The JVM memory layout of the value"
              - "The module or package a class belongs to"
            correct: "A set of methods and properties you can use on a value"
          - type: "question-multiple-answer"
            stepId: "lesson-20_type_system-why-do-we-have-types?-q2"
            question: "Which benefits do Kotlin’s types provide? Select all that apply."
            explanation: "Types give developer safety and IDE assistance, and they help\
        \ the compiler with overload resolution. They do not remove the need for classes\
        \ or guarantee resource reductions."
            repeatable: false
            answers:
              - "Compile-time prevention of using incorrect methods/properties"
              - "Better IDE suggestions and autocompletion"
              - "Helping the compiler choose between overloaded functions"
              - "Eliminating the need for classes and objects"
              - "Guaranteed lower memory usage in all programs"
            correct:
              - "Compile-time prevention of using incorrect methods/properties"
              - "Better IDE suggestions and autocompletion"
              - "Helping the compiler choose between overloaded functions"
          - type: "text"
            stepId: "lesson-20_type_system-the-relation-between-classes-and-types-text"
            repeatable: false
            text: |-
              We say that classes generate types. Think of the class `User`. It generates two types. Can you name them both? One is `User`, but the second is not `Any` (`Any` is already in the type hierarchy). The second new type generated by the class `User` is `User?`. Yes, the nullable variant is a separate type.
              
              There are classes that generate many more types: generic classes. The `Box<T>` class theoretically generates an infinite number of types.
              
              ![](typing_system_type_class_relation.png)
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-the-relation-between-classes-and-types-q1"
            question: "Declaring `class User` introduces which new types to the Kotlin type\
        \ system?"
            explanation: "Each class generates its non-nullable and nullable types. `Any`\
        \ is not introduced by the class; it already exists."
            repeatable: false
            answers:
              - "User and User?"
              - "Only User"
              - "User and Any"
              - "User, Any, and User?"
            correct: "User and User?"
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-the-relation-between-classes-and-types-q2"
            question: "How many distinct types can `class Box<T>` represent in Kotlin?"
            explanation: "A generic class yields a type for every admissible type argument\
        \ (and its nullable variant), so the set is unbounded."
            repeatable: false
            answers:
              - "Exactly two: Box<T> and Box<T>?"
              - "Finitely many, depending on T's bounds"
              - "Infinitely many, depending on type arguments and nullability"
              - "None until instantiated at runtime"
            correct: "Infinitely many, depending on type arguments and nullability"
          - type: "text"
            stepId: "lesson-20_type_system-class-vs-type-in-practice-text"
            repeatable: false
            text: |-
              This discussion might sound very theoretical, but it already has some practical implications. Note that classes cannot be nullable, but types can. Consider the initial example, where I asked you to point out where `User` is a type. Only in positions that represent types can you use `User?` instead of `User`.
              
              ![](typing_system_type_vs_class_nullable.png)
              
              Member functions are defined on classes, so their receiver cannot be nullable or have type arguments. Extension functions are defined on types, so they can be nullable or defined on a concrete generic type. Consider the `sum` function,, which is an extension of `Iterable<Int>`, or the `isNullOrBlank` function, which is an extension of `String?`.
              
              ```kotlin
              fun Iterable<Int>.sum(): Int {
                  var sum: Int = 0
                  for (element in this) {
                      sum += element
                  }
                  return sum
              }
              
              @OptIn(ExperimentalContracts::class)
              inline fun CharSequence?.isNullOrBlank(): Boolean {
                  // (skipped contract definition)
                  return this == null || this.isBlank()
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-20_type_system-class-vs-type-in-practice-q1"
            question: "Which of the following declarations compile in Kotlin? (Select all\
        \ that apply.)"
            explanation: "Extension functions are defined on types, so their receivers can\
        \ be nullable or concrete generic types (e.g., Iterable<Int>). Classes cannot\
        \ be nullable, and type parameters in class declarations cannot carry nullability\
        \ (no class Box<T?>)."
            repeatable: true
            answers:
              - "fun String?.isNullOrBlankEx(): Boolean = this == null || this.isBlank()"
              - "fun Iterable<Int>.sumEx(): Int = fold(0) { acc, e -> acc + e }"
              - "class User?"
              - "class Box<T?>"
            correct:
              - "fun String?.isNullOrBlankEx(): Boolean = this == null || this.isBlank()"
              - "fun Iterable<Int>.sumEx(): Int = fold(0) { acc, e -> acc + e }"
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-class-vs-type-in-practice-q2"
            question: "Which receivers in Kotlin can be nullable (e.g., String?)?"
            explanation: "Member functions are defined on classes (not nullable, no type\
        \ arguments), whereas extension receivers are types and may be nullable or\
        \ concrete generics."
            repeatable: false
            answers:
              - "Only extension function receivers."
              - "Only member function receivers."
              - "Both member and extension receivers."
              - "Neither."
            correct: "Only extension function receivers."
          - type: "text"
            stepId: "lesson-20_type_system-the-relationship-between-types-text"
            repeatable: false
            text: |-
              Let's say that we have a class `Dog` and its superclass `Animal`.
              
              ```kotlin
              open class Animal
              class Dog : Animal()
              ```
              
              Wherever an `Animal` type is expected, you can use a `Dog`, but not the other way around.
              
              ```kotlin
              fun petAnimal(animal: Animal) {}
              fun petDog(dog: Dog) {}
              
              fun main() {
                  val dog: Dog = Dog()
                  val dogAnimal: Animal = dog // works
                  petAnimal(dog) // works
                  val animal: Animal = Animal()
                  val animalDog: Dog = animal // compilation error
                  petDog(animal) // compilation error
              }
              ```
              
              Why? Because there is a concrete relationship between these types: `Dog` is a subtype of `Animal`. By rule, when A is a subtype of B, we can use A where B is expected. We might also say that `Animal` is a supertype of `Dog`, and a subtype can be used where a supertype is expected.
              
              {width: 25%, align: middle}
              ![](typing_system_A_B.png)
              
              There is also a relationship between nullable and non-nullable types. A non-nullable can be used wherever a nullable is expected.
              
              ```kotlin
              fun petDogIfPresent(dog: Dog?) {}
              fun petDog(dog: Dog) {}
              
              fun main() {
                  val dog: Dog = Dog()
                  val dogNullable: Dog? = dog
                  petDogIfPresent(dog) // works
                  petDogIfPresent(dogNullable) // works
                  petDog(dog) // works
                  petDog(dogNullable) // compilation error
              }
              ```
              
              This is because the non-nullable variant of each type is a subtype of the nullable variant.
              
              {width: 50%, align: middle}
              ![](typing_system_A_B_nullability.png)
              
              The superclass of all the classes in Kotlin is `Any`, which is similar to `Object` in Java. The supertype of all the types is not `Any`, it is `Any?`. `Any` is a supertype of all non-nullable types. We also have something that is not present in Java and most other mainstream languages: the subtype of all the types, which is called `Nothing`. We will talk about it soon.
              
              {width: 50%, align: middle}
              ![](typing_system_A_B_nullability_Any_Nothing.png)
              
              `Any` is only a supertype of non-nullable types. So, wherever `Any` is expected, nullable types will not be accepted. This fact is also used to set a type parameter’s upper boundary to accept only non-nullable types.
              
              ```kotlin
              fun <T : Any> String.parseJson(): T = ...
              ```
              
              `Unit` does not have any special place in the type hierarchy. It is just an object declaration that is used when a function does not specify a result type.
              
              ```kotlin
              object Unit {
                  override fun toString() = "kotlin.Unit"
              }
              ```
              
              Let's talk about a concept that has a very special place in the typing hierarchy: let's talk about `Nothing`.
          - type: "question-multiple-answer"
            stepId: "lesson-20_type_system-the-relationship-between-types-q1"
            question: |-
              Given:
              
              ```kotlin
              open class Animal
              class Dog : Animal()
              
              fun takesAnimal(a: Animal) {}
              fun takesDog(d: Dog) {}
              fun takesAny(a: Any) {}
              fun takesAnyQ(a: Any?) {}
              
              val dog: Dog = Dog()
              val animal: Animal = Animal()
              val dogQ: Dog? = dog
              val animalQ: Animal? = animal
              ```
              
              Which calls compile? Choose all that apply.
            explanation: "Subtype can be used where a supertype is expected. Non-nullable\
        \ is a subtype of its nullable variant. Any is the supertype of all non-nullable\
        \ types; Any? is the supertype of all types."
            repeatable: true
            answers:
              - "takesAnimal(dog)"
              - "takesDog(animal)"
              - "takesAny(dog)"
              - "takesAny(dogQ)"
              - "takesAnyQ(animalQ)"
            correct:
              - "takesAnimal(dog)"
              - "takesAny(dog)"
              - "takesAnyQ(animalQ)"
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-the-relationship-between-types-q2"
            question: |-
              Given the bound `T : Any`:
              
              ```kotlin
              fun <T : Any> String.parseJson(): T = TODO()
              ```
              Which invocation compiles?
            explanation: "`T : Any` forbids nullable type arguments. Only non-nullable types\
        \ (e.g., Boolean, Int, String, Any) are allowed; `Any?` and `T?` are not."
            repeatable: false
            answers:
              - "`\"true\".parseJson<Boolean>()`"
              - "`\"42\".parseJson<Int?>()`"
              - "`\"null\".parseJson<String?>()`"
              - "`\"dog\".parseJson<Any?>()`"
            correct: "`\"true\".parseJson<Boolean>()`"
          - type: "text"
            stepId: "lesson-20_type_system-the-subtype-of-all-the-types:-nothing-text"
            repeatable: false
            text: |-
              `Nothing` is a subtype of all the types in Kotlin. If we had an instance of this type, it could be used instead of everything else (like a Joker in the card game Rummy). It’s no wonder that such an instance does not exist. `Nothing` is an empty type (also known as a bottom type, zero type, uninhabited type, or never type), which means it has no values. It is literally impossible to make an instance of type `Nothing`, but this type is still really useful. I will tell you more: some functions declare `Nothing` as their result type. You've likely used such functions many times already. What functions are those? They declare `Nothing` as a result type, but they cannot return it because this type has no instances. But what can these functions do? Three things: they either need to run forever, end the program, or throw an exception. In all cases, they never return, so the `Nothing` type is not only valid but also really useful.
              
              ```kotlin
              fun runForever(): Nothing {
                  while (true) {
                      // no-op
                  }
              }
              
              fun endProgram(): Nothing {
                  exitProcess(0)
              }
              
              fun fail(): Nothing {
                  throw Error("Some error")
              }
              ```
              
              I have never found a good use case for a function that runs forever, and ending a program is not very common, but we often use functions that throw exceptions. Who hasn't ever used `TODO()`? This function throws a `NotImplementedError` exception. There is also the `error` function from the standard library, which throws an `IllegalStateException`.
              
              ```kotlin
              inline fun TODO(): Nothing = throw NotImplementedError()
              
              inline fun error(message: Any): Nothing =
                  throw IllegalStateException(message.toString())
              ```
              
              `TODO` is used as a placeholder in a place where we plan to implement some code.
              
              ```kotlin
              fun fib(n: Int): Int = TODO()
              ```
              
              `error` is used to signal an illegal situation:
              
              ```kotlin
              fun get(): T = when {
                  left != null -> left
                  right != null -> right
                  else -> error("Must have either left or right")
              }
              ```
              
              This result type is significant. Let’s say that you have an if-condition that returns either `Int` or `Nothing`. What should the inferred type be? The closest supertype of both `Int` and `Nothing` is `Int`. This is why the inferred type will be `Int`.
              
              ```kotlin
              // the inferred type of answer is Int
              val answer = if (timeHasPassed) 42 else TODO()
              ```
              
              The same rule applies when we use the Elvis operator, a when-expression, etc. In the example below, the type of both `name` and `fullName` is `String` because both `fail` and `error` declare `Nothing` as their result type. This is a huge convenience.
              
              ```kotlin
              fun processPerson(person: Person?) {
                  // the inferred type of name is String
                  val name = person?.name ?: fail()
                  // the inferred type of fullName is String
                  val fullName = when {
                      !person.middleName.isNullOrBlank() ->
                          "$name ${person.middleName} ${person.surname}"
                      !person.surname.isNullOrBlank() ->
                          "$name ${person.surname}"
                      else ->
                          error("Person must have a surname")
                  }
                  // ...
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-the-subtype-of-all-the-types:-nothing-q1"
            question: |-
              What is the inferred type of x?
              
              ```kotlin
              val x = listOf(1, 2).firstOrNull() ?: error("No elements")
              ```
            explanation: "`error(...)` returns `Nothing`, which is a subtype of all types.\
        \ The Elvis operator with `Int?` on the left and `Nothing` on the right yields\
        \ the non-nullable `Int`."
            repeatable: true
            answers:
              - "Int"
              - "Int?"
              - "Any"
              - "Nothing"
            correct: "Int"
          - type: "question-multiple-answer"
            stepId: "lesson-20_type_system-the-subtype-of-all-the-types:-nothing-q2"
            question: "Which functions can correctly declare return type `Nothing`?"
            explanation: "`Nothing` means the function never returns normally. Throwing,\
        \ exiting the process, or looping forever fit. Functions returning `Unit`\
        \ or `Int` do return, so they cannot be `Nothing`."
            repeatable: true
            answers:
              - "A function that always throws an exception."
              - "A function that calls `exitProcess(0)` unconditionally."
              - "A function that runs an infinite loop without breaking or returning."
              - "A function that returns `Unit` to indicate no meaningful value."
              - "A `suspend` function that computes and returns `Int` after a delay."
            correct:
              - "A function that always throws an exception."
              - "A function that calls `exitProcess(0)` unconditionally."
              - "A function that runs an infinite loop without breaking or returning."
          - type: "text"
            stepId: "lesson-20_type_system-the-result-type-from-return-and-throw-text"
            repeatable: false
            text: |-
              I will start this subchapter with something strange: did you know that you can place `return` or `throw` on the right side of a variable assignment?
              
              ```kotlin
              fun main() {
                  val a = return
                  val b = throw Error()
              }
              ```
              
              This doesn’t make any sense as both `return` and `throw` end the function, so we will never assign anything to such variables (like `a` and `b` in the example above). This assignment is an unreachable piece of code. In Kotlin, it just causes a warning.
              
              ![](typing_system_return_return_type.png)
              
              The code above is correct from the language point of view because both `return` and `throw` are expressions, which means they declare a result type. This type is `Nothing`.
              
              ```kotlin
              fun main() {
                  val a: Nothing = return
                  val b: Nothing = throw Error()
              }
              ```
              
              This explains why we can place `return` or `throw` on the right side of the Elvis operator or in a when-expression.
              
              ```kotlin
              fun processPerson(person: Person?) {
                  val name = person?.name ?: return
                  val fullName = when {
                      !person.middleName.isNullOrBlank() ->
                          "$name ${person.middleName} ${person.surname}"
                      !person.surname.isNullOrBlank() ->
                          "$name ${person.surname}"
                      else -> return
                  }
                  // ...
              }
              ```
              
              ```kotlin
              fun processPerson(person: Person?) {
                  val name = person?.name ?: throw Error("Name is required")
                  val fullName = when {
                      !person.middleName.isNullOrBlank() ->
                          "$name ${person.middleName} ${person.surname}"
                      !person.surname.isNullOrBlank() ->
                          "$name ${person.surname}"
                      else -> throw Error("Surname is required")
                  }
                  // ...
              }
              ```
              
              Both `return` and `throw` declare `Nothing` as their result type. As a consequence, Kotlin will infer `String` as the type of both `name` and `fullName` because `String` is the closest supertype of both `String` and `Nothing`.
              
              So, now you can say that you know `Nothing`. Just like John Snow.
              
              ![](Nothing_John_Snow.png)
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-the-result-type-from-return-and-throw-q1"
            question: "In Kotlin, what is the result type of both `return` and `throw` expressions?"
            explanation: "`return` and `throw` are expressions with the type `Nothing`—\
        a bottom type that is a subtype of every type. This allows them to appear\
        \ in places like the right side of `?:` and inside `when` branches."
            repeatable: true
            answers:
              - "Nothing"
              - "Unit"
              - "Any"
              - "Nothing?"
            correct: "Nothing"
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-the-result-type-from-return-and-throw-q2"
            question: |-
              Given:
              
              ```kotlin
              data class Person(val name: String)
              
              fun process(person: Person?) {
                  val name = person?.name ?: return
                  // What is the inferred type of `name`?
              }
              ```
              What is the inferred type of `name`?
            explanation: "The right side of `?:` is `return` (type `Nothing`), so the Elvis\
        \ expression refines the left side to non-null. Thus `name` is inferred as\
        \ `String`."
            repeatable: false
            answers:
              - "String"
              - "String?"
              - "Nothing"
              - "Any"
            correct: "String"
          - type: "text"
            stepId: "lesson-20_type_system-when-is-some-code-not-reachable?-text"
            repeatable: false
            text: |-
              When an element declares `Nothing` as a return type, it means that everything after its call is not reachable. This is reasonable: there are no instances of `Nothing`, so it cannot be returned. This means a statement that declares `Nothing` as its result type will never complete in a normal way, so the next statements are not reachable. This is why everything after either `fail` or `throw` will be unreachable.
              
              {width: 60%}
              ![](typing_system_fail_throw.png)
              
              It’s the same with `return`, `TODO`, `error`, etc. If a non-optional expression declares `Nothing` as its result type, everything after that is unreachable. This is a simple rule, but it’s useful for the compiler. It’s also useful for us since it gives us more possibilities. Thanks to this rule, we can use `TODO()` in a function instead of returning a value. Anything that declares `Nothing` as a result type ends the function (or runs forever), so this function will not end without returning or throwing first.
              
              ```kotlin
              fun fizzBuzz(): String {
                  TODO()
              }
              ```
              
              I would like to end this topic with a more advanced example that comes from the Kotlin Coroutines library. There is a `MutableStateFlow` class, which represents a mutable value whose state changes can be observed using the `collect` method. The thing is that `collect` suspends the current coroutine until whatever it observes is closed, but a StateFlow cannot be closed. This is why this `collect` function declares `Nothing` as its result type.
              
              ```kotlin
              public interface SharedFlow<out T> : Flow<T> {
                  public val replayCache: List<T>
                  override suspend fun collect(
                      collector: FlowCollector<T>
                  ): Nothing
              }
              ```
              
              That is very useful for developers who are not aware of how `collect` works. Thanks to the result type, IntelliJ informs them that the code they place after `collect` is unreachable.
              
              ![SharedFlow cannot be closed, so its `collect` function will never return, therefore it declares `Nothing` as its result type.](stateflow_unreachable.png)
          - type: "question-multiple-answer"
            stepId: "lesson-20_type_system-when-is-some-code-not-reachable?-q1"
            question: "Select all correct statements about Kotlin's Nothing type and reachability:"
            explanation: "Nothing has no instances and is a subtype of all types; any non-null\
        \ expression of type Nothing never completes normally, so following code is\
        \ unreachable; SharedFlow.collect never returns (StateFlow/SharedFlow cannot\
        \ be closed), hence it declares Nothing."
            repeatable: true
            answers:
              - "Nothing has no instances and is a subtype of every other type."
              - "After a non-null expression of type Nothing, subsequent statements are considered\
        \ unreachable."
              - "TODO() returns Unit, so using it in a function returning String requires\
        \ an explicit return."
              - "A function declared to return Nothing must always return null."
              - "SharedFlow.collect returns Nothing because it suspends until the flow is\
        \ closed, and SharedFlow cannot be closed."
            correct:
              - "Nothing has no instances and is a subtype of every other type."
              - "After a non-null expression of type Nothing, subsequent statements are considered\
        \ unreachable."
              - "SharedFlow.collect returns Nothing because it suspends until the flow is\
        \ closed, and SharedFlow cannot be closed."
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-when-is-some-code-not-reachable?-q2"
            question: |-
              Given the code:
              
              ```kotlin
              suspend fun consume(flow: SharedFlow<Int>) {
                  println("start")
                  flow.collect { value -> println(value) }
                  println("end")
              }
              ```
              What does the compiler/IDE report about `println("end")`?
            explanation: "`SharedFlow.collect` declares return type Nothing, meaning it\
        \ never completes normally. Therefore, the statement after it is unreachable\
        \ and flagged as such."
            repeatable: false
            answers:
              - "It is reported as unreachable because collect returns Nothing."
              - "It may execute if the flow completes normally, so no warning."
              - "It is only unreachable if the collector throws an exception."
              - "It is unreachable only on JVM; on JS/Native it may run."
            correct: "It is reported as unreachable because collect returns Nothing."
          - type: "text"
            stepId: "lesson-20_type_system-the-type-of-null-text"
            repeatable: false
            text: |-
              Let's see another peculiar thing. Did you know that you can assign `null` to a variable without setting an explicit type? What’s more, such a variable can be used wherever `null` is accepted.
              
              ```kotlin
              fun main() {
                  val n = null
                  val i: Int? = n
                  val d: Double? = n
                  val str: String? = n
              }
              ```
              
              This means that `null` has its type, which is a subtype of all nullable types. Take a look at the type hierarchy and guess what type this is.
              
              {width: 50%, align: middle}
              ![](typing_system_A_B_nullability_Any_Nothing.png)
              
              I hope you guessed that the type of `null` is `Nothing?`. Now think about the inferred type of `a` and `b` in the example below.
              
              ```kotlin
              val a = if (predicate) "A" else null
              
              val b = when {
                  predicate2 -> "B"
                  predicate3 -> "C"
                  else -> null
              }
              ```
              
              In the if-expression, we search for the closest supertype of the types from both branches. The closest supertype of `String` and `Nothing?` is `String?`. The same is true about the when-expression: the closest supertype of `String`, `String`, and `Nothing?` is `String?`. Everything makes sense.
              
              For the same reason, whenever we require `String?`, we can pass either `String` or `null`, whose type is `Nothing?`. This is clear when you take a look at the type hierarchy. `String` and `Nothing?` are the only non-empty subtypes of `String?`.
              
              ![](Socrates.png)
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-the-type-of-null-q1"
            question: |-
              What is the inferred type of `n` in Kotlin?
              
              ```kotlin
              val n = null
              ```
            explanation: "`null` has type `Nothing?`, which is a subtype of all nullable\
        \ types. `Any?` includes null but is not the type of `null`. `Nothing` is\
        \ non-null and uninhabited. `Null` is not a Kotlin type."
            repeatable: true
            answers:
              - "Nothing?"
              - "Any?"
              - "Nothing"
              - "Null"
            correct: "Nothing?"
          - type: "question-multiple-answer"
            stepId: "lesson-20_type_system-the-type-of-null-q2"
            question: |-
              Given:
              
              ```kotlin
              val n = null
              ```
              Which assignments compile?
            explanation: "`null` is `Nothing?`, a subtype of every `T?`, so it can be assigned\
        \ to `String?`, `List<Int>?`, and `Nothing?`. It cannot be assigned to non-null\
        \ types like `Any` or `String`."
            repeatable: false
            answers:
              - "val s: String? = n"
              - "val a: Any = n"
              - "val l: List<Int>? = n"
              - "val nn: Nothing? = n"
              - "val str: String = n"
            correct:
              - "val s: String? = n"
              - "val l: List<Int>? = n"
              - "val nn: Nothing? = n"
          - type: "text"
            stepId: "lesson-20_type_system-summary-text"
            repeatable: false
            text: |-
              In this chapter, we've learned the following:
              * A class is a template for creating objects. A type defines expectations and functionalities.
              * Every class generates a nullable and a non-nullable type.
              * A nullable type is a supertype of the non-nullable variant of this type.
              * The supertype of all types is `Any?`.
              * The supertype of non-nullable types is `Any`.
              * The subtype of all types is `Nothing`.
              * When a function declares `Nothing` as a return type, this means that it will throw an error or run infinitely.
              * Both `throw` and `return` declare `Nothing` as their result type.
              * The Kotlin compiler understands that when an expression declares `Nothing` as a result type, everything after that is unreachable.
              * The type of `null` is `Nothing?`, which is the subtype of all nullable types.
              
              In the next chapter, we are going to discuss generics, and we’ll see how they are important for our type system.
          - type: "question-multiple-answer"
            stepId: "lesson-20_type_system-summary-q1"
            question: "Which of the following Kotlin declarations compile? Choose all that\
        \ apply."
            explanation: |-
              - `String?` can hold `null`.
              - `Nothing?`'s only value is `null`.
              - `throw` has type `Nothing`, which is a subtype of every type, so it can appear where any type is expected.
              - A function returning `Nothing` may always throw.
              - `String` cannot hold `null`.
            repeatable: true
            answers:
              - "A) val a: String = null"
              - "B) val b: String? = null"
              - "C) val c: Nothing? = null"
              - "D) val d: Int = throw IllegalStateException()"
              - "E) fun never(): Nothing = throw IllegalStateException()"
            correct:
              - "B) val b: String? = null"
              - "C) val c: Nothing? = null"
              - "D) val d: Int = throw IllegalStateException()"
              - "E) fun never(): Nothing = throw IllegalStateException()"
          - type: "question-single-answer"
            stepId: "lesson-20_type_system-summary-q2"
            question: "What is the supertype of all non-nullable types in Kotlin?"
            explanation: "`Any` is the supertype of all non-nullable types. `Any?` is the\
        \ supertype of all types (including nullable ones)."
            repeatable: true
            answers:
              - "Any"
              - "Any?"
              - "Nothing"
              - "Nothing?"
              - "Unit"
            correct: "Any"
      - lessonId: "lesson-generics"
        name: "Generics"
        steps:
          - type: "text"
            stepId: "lesson-21_generics-#-generics-text"
            repeatable: false
            text: |-
              In the early days of Java, it was designed such that all lists had the same type `List`, instead of specific lists with specific parameter types, like `List<String>` or `List<Int>`. The `List` type in Java accepts all kinds of values; when you ask for a value at a certain position, the result type is `Object` (which, in Java, is the supertype of all the types).
              
              ```
              // Java
              List names = new ArrayList();
              names.add("Alex");
              names.add("Ben");
              names.add(123); // this is incorrect, but compiles
              for(int i = 0; i < names.size(); i++){
                 String name= (String) names.get(i); // exception at i==2
                 System.out.println(name.toUpperCase());
              }
              ```
              
              Such lists are hard to use. We much prefer to have a list with specified types of elements. Only then can we be sure that our list contains elements of the correct type, and only then do we not need to explicitly cast these elements when we get them from a list. This was one of the main reasons Java introduced generics in version 5. In Kotlin, we do not have this problem because it was designed with generics support from the beginning, and all lists are generic, so they must specify what kinds of elements they accept. Generics are an important feature of most modern programming languages; so, in this chapter, we will discuss what they are and how we use them in Kotlin.
              
              In Kotlin, we have three kinds of generic elements:
              * generic functions,
              * generic classes,
              * generic interfaces.
              
              Let's discuss them one by one.
          - type: "question-single-answer"
            stepId: "lesson-21_generics-#-generics-q1"
            question: |
              What happens when compiling and running the following Kotlin code?
              
              ```kotlin
              val names = mutableListOf<String>()
              names.add("Alex")
              names.add("Ben")
              names.add(123)
              ```
            explanation: "Kotlin enforces generic types at compile time. `MutableList<String>`\
        \ cannot accept an `Int`, so the call `add(123)` is a compile-time type mismatch.\
        \ Unlike early Java raw lists, no runtime cast is involved here."
            repeatable: true
            answers:
              - "It fails to compile at `names.add(123)` due to type mismatch."
              - "It compiles, but throws ClassCastException when reading the 3rd element as\
        \ String."
              - "It compiles; the list is inferred as MutableList<Any>."
              - "It fails only at runtime when calling String-specific methods."
            correct: "It fails to compile at `names.add(123)` due to type mismatch."
          - type: "question-single-answer"
            stepId: "lesson-21_generics-#-generics-q2"
            question: "Which set lists all kinds of generic elements Kotlin supports?"
            explanation: "Kotlin supports generic functions, generic classes, and generic\
        \ interfaces."
            repeatable: false
            answers:
              - "Functions, classes, interfaces"
              - "Classes, interfaces, enums"
              - "Functions, classes, annotations"
              - "Packages, modules, classes"
            correct: "Functions, classes, interfaces"
          - type: "text"
            stepId: "lesson-21_generics-generic-functions-text"
            repeatable: false
            text: |-
              Just as we can pass an argument value to a parameter, we can pass a type as a **type argument**. For this, a function needs to define one or more type parameters inside angle brackets immediately after the `fun` keyword. By convention, type parameter names are capitalized. When a function defines a type parameter, we have to specify the type arguments when calling this function. The type parameter is a placeholder for a concrete type; the type argument is the actual type that is used when a function is called. To specify type arguments explicitly, we also use angle brackets.
              
              ```kotlin
              fun <T> a() {} // T is type parameter
              a<Int>() // Int is used here as a type argument
              a<String>() // String is used here as a type argument
              ```
              
              There is a popular practice that a single type argument is called `T` (from "type"); if there are multiple type arguments, they are called `T` with consecutive numbers. However, this practice is not a fixed rule, and there are many other conventions for naming type parameters.
              
              ```kotlin
              fun <T> a() {}
              fun <T1, T2> b() {}
              ```
              
              When we call a generic function, all its type arguments must be clear for the Kotlin compiler. We can either specify them explicitly, or their values can be inferred from the compiler.
              
              ```kotlin
              fun <T> a() {}
              fun <T1, T2> b() {}
              fun <T> c(t: T) {}
              fun <T1, T2> d(a: T1, b: T2) {}
              fun <T> e(): T = TODO()
              
              fun main() {
                  // Type arguments specified explicitly
                  a<Int>()
                  a<String>()
                  b<Double, Char>()
                  b<Float, Long>()
              
                  // Inferred type arguments
                  c(10) // The inferred type of T is Int
                  d("AAA", 10.0)
                  // The inferred type of T1 is String, and of T2 is Double
                  val e: Boolean = e() // The inferred type of T is Boolean
              }
              ```
              
              So, how are these type parameters useful? We use them primarily to specify the relationship between the arguments and the result type. For instance, we can express that the result type is the same as an argument type or that we expect two arguments of the same type.
              
              ```kotlin
              import kotlin.random.Random
              
              // The result type is the same as the argument type
              fun <T> id(value: T): T = value
              
              // The result type is the closest supertype of arguments
              fun <T> randomOf(a: T, b: T): T =
                  if (Random.nextBoolean()) a else b
              
              fun main() {
                  val a = id(10) // Inferred a type is Int
                  val b = id("AAA") // Inferred b type is String
                  val c = randomOf("A", "B") // Inferred c type is String
                  val d = randomOf(1, 1.5) // Inferred d type is Number
              }
              ```
              
              Type parameters for functions are useful for the compiler since they allow it to check and correctly infer types; this makes our programs safer and makes programming more pleasurable for developers. Better parameter types and type suggestions protect us from using illegal operations and let our IDE give us better suggestions.
              
              In the book, *Functional Kotlin*, you will see plenty of generic function examples, especially for collection processing. Such functions are really important and useful. But, for now, let's get back to the initial motivation for introducing generics: let's talk about generic classes.
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-generic-functions-q1"
            question: |-
              Given these generic functions:
              
              ```kotlin
              fun <T> id(v: T): T = v
              fun <T> randomOf(a: T, b: T): T = if (true) a else b
              fun <T> make(): T = TODO()
              ```
              Which lines compile?
            explanation: |-
              - id returns the same type as its argument, so `id(42)` is Int; assigning it to Double fails.
              - `randomOf(1, 2.0)` infers T as the closest common supertype Number, so both inferring to `val c` and assigning to `Number` compile.
              - `make()` needs either an expected type or explicit type argument; without it, it doesn't compile; with `: String` it does.
            repeatable: true
            answers:
              - "val a = id(42)"
              - "val b: Double = id(42)"
              - "val c = randomOf(1, 2.0)"
              - "val d: Number = randomOf(1, 2.0)"
              - "val e = make()"
              - "val f: String = make()"
            correct:
              - "val a = id(42)"
              - "val c = randomOf(1, 2.0)"
              - "val d: Number = randomOf(1, 2.0)"
              - "val f: String = make()"
          - type: "question-single-answer"
            stepId: "lesson-21_generics-generic-functions-q2"
            question: "What is the inferred type of `val d = randomOf(1, 1.5)` given `fun\
        \ <T> randomOf(a: T, b: T): T`?"
            explanation: "Kotlin infers T as the closest common supertype (least upper bound)\
        \ of Int and Double, which is Number."
            repeatable: true
            answers:
              - "Int"
              - "Double"
              - "Number"
              - "Any"
            correct: "Number"
          - type: "text"
            stepId: "lesson-21_generics-generic-classes-text"
            repeatable: false
            text: |-
              We can make classes generic by adding a type parameter after the class name. Such a type parameter can be used all over the class body, especially to specify properties, parameters, and result types. A type parameter is specified when we define an instance, after which it remains unchanged. Thanks to that, when you declare `ValueWithHistory<String>` and then call `setValue` in the example below, you must use an object of type `String`; when you call `currentValue`, the result object will be typed as `String`; and when you call `history`, its result is of type `List<String>`. It’s the same for all other possible type arguments.
              
              ```kotlin
              class ValueWithHistory<T>(
                  private var value: T
              ) {
                  private var history: List<T> = listOf(value)
              
                  fun setValue(value: T) {
                      this.value = value
                      this.history += value
                  }
              
                  fun currentValue(): T = value
              
                  fun history(): List<T> = history
              }
              
              fun main() {
                  val letter = ValueWithHistory<String>("A")
                  // The type of letter is ValueWithHistory<String>
                  letter.setValue("B")
                  // letter.setValue(123) <- this would not compile
                  val l = letter.currentValue() // the type of l is String
                  println(l) // B
                  val h = letter.history() // the type of h is List<String>
                  println(h) // [A, B]
              }
              ```
              
              The constructor type argument can be inferred. In the above example, we specified it explicitly, but we did not need to. This type can be inferred from the argument type.
              
              ```kotlin
              val letter = ValueWithHistory("A")
              // The type of letter is ValueWithHistory<String>
              ```
              
              Type arguments can also be inferred from variable types. Let's say that we want to use `Any` as a type argument. We can specify this by specifying the type of variable `letter` as `ValueWithHistory<Any>`.
              
              ```kotlin
              val letter: ValueWithHistory<Any> = ValueWithHistory("A")
              // The type of letter is ValueWithHistory<Any>
              ```
              
              As I mentioned in the introduction to this chapter, the most important motivation for introducing generics was to make collections with certain types of elements. Consider the `ArrayList` class from the Standard Library (stdlib). It is generic, so when we create an instance from this class we need to specify the types of elements. Thanks to that, Kotlin protects us by expecting only values with accepted types to be added to the list, and Kotlin uses this type when we operate on the elements in the list.
              
              ```kotlin
              fun main() {
                  val letters = ArrayList<String>()
                  letters.add("A") // the argument must be of type String
                  letters.add("B") // the argument must be of type String
                  // The type of letters is List<String>
                  val a = letters[0] // the type of a is String
                  println(a) // A
                  for (l in letters) { // the type of l is String
                      println(l) // first A, then B
                  }
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-generic-classes-q1"
            question: |-
              Given the generic class:
              
              ```kotlin
              class ValueWithHistory<T>(private var value: T) {
                  private var history: List<T> = listOf(value)
                  fun setValue(value: T) { this.value = value; this.history += value }
                  fun currentValue(): T = value
                  fun history(): List<T> = history
              }
              
              val a = ValueWithHistory("A")
              val b: ValueWithHistory<Any> = ValueWithHistory("A")
              val c: ValueWithHistory<String> = ValueWithHistory("A")
              ```
              Which calls compile? Choose all that compile.
            explanation: "For a and c, T is String, so only String values are allowed. For\
        \ b, T is Any, so both String and Int are allowed."
            repeatable: true
            answers:
              - "a.setValue(1)"
              - "b.setValue(1)"
              - "c.setValue(1)"
              - "a.setValue(\"B\")"
              - "b.setValue(\"B\")"
              - "c.setValue(\"B\")"
            correct:
              - "b.setValue(1)"
              - "a.setValue(\"B\")"
              - "b.setValue(\"B\")"
              - "c.setValue(\"B\")"
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-generic-classes-q2"
            question: |-
              Using the same declarations:
              
              ```kotlin
              val a = ValueWithHistory("A")        // T inferred as String
              val b: ValueWithHistory<Any> = ValueWithHistory("A") // T is Any
              ```
              Which assignments compile? Choose all that compile.
            explanation: "currentValue() returns T. For a it's String; for b it's Any. Assigning\
        \ a String to Any is fine; assigning Any to String is not."
            repeatable: false
            answers:
              - "val s1: String = a.currentValue()"
              - "val s2: String = b.currentValue()"
              - "val any1: Any = a.currentValue()"
              - "val any2: Any = b.currentValue()"
            correct:
              - "val s1: String = a.currentValue()"
              - "val any1: Any = a.currentValue()"
              - "val any2: Any = b.currentValue()"
          - type: "text"
            stepId: "lesson-21_generics-generic-classes-and-nullability-text"
            repeatable: false
            text: |-
              Notice that type arguments can be nullable, so we could create `ValueWithHistory<String?>`. In such a case, the `null` value is a perfectly valid option.
              
              ```kotlin
              fun main() {
                  val letter = ValueWithHistory<String?>(null)
                  letter.setValue("A")
                  letter.setValue(null)
                  val l = letter.currentValue() // the type of l is String?
                  println(l) // null
                  val h = letter.history() // the type of h is List<String?>
                  println(h) // [null, A, null]
              
                  val letters = ArrayList<String?>()
                  letters.add("A")
                  letters.add(null)
                  println(letters) // [A, null]
                  val l2 = letters[1] // the type of l2 is String?
                  println(l2) // null
              }
              ```
              
              Another thing is that when you use generic parameters inside classes or functions, you can make them nullable by adding a question mark. See the example below. The type `T` might or might not be nullable, depending on the type argument, but the type `T?` is always nullable. We can assign `null` to variables of the type `T?`. Nullable generic type parameter `T?` must be unpacked before using it as `T`.
              
              ```kotlin
              class Box<T> {
                  var value: T? = null
              
                  fun getOrThrow(): T = value!!
              }
              ```
              
              The opposite can also be expressed. Since a generic type parameter might represent a nullable type (you can have `List<Int?>`), we might specify a definitely non-nullable variant of this type by adding `& Any` after the type parameter. In the example below, the method `orThrow` can be invoked on any value, but it unpacks nullable types into non-nullable ones.
              
              ```kotlin
              fun <T> T.orThrow(): T & Any = this ?: throw Error()
              
              fun main() {
                  val a: Int? = if (Random.nextBoolean()) 42 else null
                  val b: Int = a.orThrow()
                  val c: Int = b.orThrow()
                  println(b)
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-generic-classes-and-nullability-q1"
            question: "Which of the following declarations compile as-is in Kotlin? Choose\
        \ all that apply."
            explanation: |-
              - `T?` is always nullable, so you can assign `null` to it; `T` is not guaranteed to be nullable.
              - Assigning a `T` value to a `T?` variable is always safe.
              - From `List<T?>`, `first()` is `T?`, which cannot be returned as `T`.
              - `T & Any` produces a definitely non-null type, so `orThrow` compiles.
            repeatable: true
            answers:
              - "fun <T> a(t: T) { val x: T = null }"
              - "fun <T> b(t: T?) { val x: T? = null }"
              - "class Box<T>(var v: T?) { fun set(t: T) { v = t } }"
              - "fun <T> d(list: List<T?>): T = list.first()"
              - "fun <T> T.orThrow(): T & Any = this ?: error(\"Boom\")"
            correct:
              - "fun <T> b(t: T?) { val x: T? = null }"
              - "class Box<T>(var v: T?) { fun set(t: T) { v = t } }"
              - "fun <T> T.orThrow(): T & Any = this ?: error(\"Boom\")"
          - type: "question-single-answer"
            stepId: "lesson-21_generics-generic-classes-and-nullability-q2"
            question: "Given `fun <T> T.orThrow(): T & Any = this ?: error(\"Boom\")` and\
        \ `val a: String? = if (Random.nextBoolean()) \"K\" else null`, what is the\
        \ static type of `val x = a.orThrow()`?"
            explanation: "Here `T` is `String?`. The type `T & Any` is the definitely non-nullable\
        \ variant of `T`, which collapses to `String`. So `x` is `String`."
            repeatable: true
            answers:
              - "String"
              - "String?"
              - "String & Any"
              - "Nothing"
            correct: "String"
          - type: "text"
            stepId: "lesson-21_generics-generic-interfaces-text"
            repeatable: false
            text: |-
              Interfaces can also be generic, which has similar consequences as for classes: the specified type parameters can be used inside the interface body as types for properties, parameters, and result types. A good example is the `List` interface.
              
              ```kotlin
              interface List<out E> : Collection<E> {
                  override val size: Int
                  override fun isEmpty(): Boolean
                  override fun contains(element: @UnsafeVariance E): Boolean
                  override fun iterator(): Iterator<E>
                  override fun containsAll(
                      elements: Collection<@UnsafeVariance E>
                  ): Boolean
                  operator fun get(index: Int): E
                  fun indexOf(element: @UnsafeVariance E): Int
                  fun lastIndexOf(element: @UnsafeVariance E): Int
                  fun listIterator(): ListIterator<E>
                  fun listIterator(index: Int): ListIterator<E>
                  fun subList(fromIndex: Int, toIndex: Int): List<E>
              }
              ```
              
              > The `out` modifier and the `UnsafeVariance` annotation are explained in the book *Advanced Kotlin*.
              
              ![For `List<String>` type, methods like `contains` expect an argument of type `String`, and methods like `get` declare `String` as the result type.](list_str_suggestions.png)
              
              ![For `List<String>`, methods like `filter` can infer `String` as a lambda parameter.](list_suggestions.png)
              
              Generic interfaces are inherited by classes. Let's say that we have a class `Dog` that inherits from `Consumer<DogFood>`, as shown in the snippet below. The interface `Consumer` expects a method `consume` with the type parameter `T`. This means our `Dog` must override the `consume` method with an argument of type `DogFood`. It must be `DogFood` because we implement the `Consumer<DogFood>` type, and the parameter type in the interface `Consumer` must match the type argument `DogFood`. Now, when you have an instance of `Dog`, you can up-cast it to `Consumer<DogFood>`.
              
              ```kotlin
              interface Consumer<T> {
                  fun consume(value: T)
              }
              class DogFood
              
              class Dog : Consumer<DogFood> {
                  override fun consume(value: DogFood) {
                      println("Mlask mlask")
                  }
              }
              
              fun main() {
                  val dog: Dog = Dog()
                  val consumer: Consumer<DogFood> = dog
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-21_generics-generic-interfaces-q1"
            question: |-
              Given:
              
              ```kotlin
              interface Consumer<T> { fun consume(value: T) }
              open class Food
              class DogFood : Food()
              
              class Dog : Consumer<DogFood> {
                  // Which override is valid?
              }
              ```
            explanation: "Implementing Consumer<DogFood> fixes T as DogFood, so the parameter\
        \ type must be exactly DogFood (same nullability). You cannot widen to a supertype\
        \ or change nullability."
            repeatable: false
            answers:
              - "override fun consume(value: DogFood)"
              - "override fun consume(value: Food)"
              - "override fun consume(value: Any)"
              - "override fun consume(value: DogFood?)"
            correct: "override fun consume(value: DogFood)"
          - type: "question-single-answer"
            stepId: "lesson-21_generics-generic-interfaces-q2"
            question: |-
              Given:
              
              ```kotlin
              interface Consumer<T> { fun consume(value: T) }
              class DogFood
              class Dog : Consumer<DogFood> {
                  override fun consume(value: DogFood) { println("Mlask mlask") }
              }
              ```
              Which declaration compiles?
            explanation: "Dog implements Consumer<DogFood>, so it upcasts to that exact\
        \ generic interface. Consumer<T> here is invariant, so Consumer<DogFood> is\
        \ not a Consumer<Any>; and unrelated types don’t match."
            repeatable: false
            answers:
              - "val c: Consumer<DogFood> = Dog()"
              - "val c: Consumer<Any> = Dog()"
              - "val d: Dog = object : Consumer<DogFood> { override fun consume(value: DogFood)\
        \ {} }"
              - "val c: Consumer<DogFood> = DogFood()"
            correct: "val c: Consumer<DogFood> = Dog()"
          - type: "text"
            stepId: "lesson-21_generics-type-parameters-and-inheritance-text"
            repeatable: false
            text: |-
              Classes can inherit from open generic classes or implement generic interfaces; however, in both cases they must explicitly specify the type argument. Consider the snippet below. Class `A` inherits from `C<Int>` and implements `I<String>`.
              
              ```kotlin
              open class C<T>
              interface I<T>
              class A : C<Int>(), I<String>
              
              fun main() {
                  val a = A()
                  val c: C<Int> = a
                  val i: I<String> = a
              }
              ```
              
              It is actually quite common that a non-generic class inherits from a generic one. Consider `MessageListAdapter` presented below, which inherits from `ArrayAdapter<String>`.
              
              ```kotlin
              class MessageListAdapter(
                  context: Context,
                  val values: List<ClaimMessage>
              ) : ArrayAdapter<String>(
                  context,
                  R.layout.row_messages,
                  values.map { it.title }.toTypedArray()
              ) {
                  fun getView(
                      position: Int,
                      convertView: View?,
                      parent: ViewGroup?
                  ): View {
                      // ...
                  }
              }
              ```
              
              An even more common case is when one generic class or interface inherits from another generic class or interface and uses its type parameter as a type argument of the class it inherits from. In the snippet below, the class `A` is generic and uses its type parameter `T` as an argument for both `C` and `I`. This means that if you create `A<Int>`, you will be able to up-cast it to `C<Int>` or `I<Int>`. However, if you create `A<String>`, you will be able to up-cast it to `C<String>` or to `I<String>`.
              
              ```kotlin
              open class C<T>
              interface I<T>
              class A<T> : C<T>(), I<T>
              
              fun main() {
                  val a: A<Int> = A<Int>()
                  val c1: C<Int> = a
                  val i1: I<Int> = a
              
                  val a1: A<String> = A<String>()
                  val c2: C<String> = a1
                  val i2: I<String> = a1
              }
              ```
              
              A good example is the collection hierarchy. An object of type `MutableList<Int>` implements `List<Int>`, which implements `Collection<Int>`, which implements `Iterable<Int>`.
              
              ```kotlin
              interface Iterable<out T> {
                  // ...
              }
              interface MutableIterable<out T> : Iterable<T> {
                  // ...
              }
              interface Collection<out E> : Iterable<E> {
                  /// ...
              }
              interface MutableCollection<E> : Collection<E>,MutableIterable<E>{
                  // ...
              }
              interface List<out E> : Collection<E> {
                  // ...
              }
              interface MutableList<E> : List<E>, MutableCollection<E> {
                  // ...
              }
              ```
              
              However, a class does not need to use its type parameter when inheriting from a generic class or implementing a generic interface. Type parameters of parent and child classes are independent of one another and should not be confused, even if they have the same name.
              
              ```kotlin
              open class C<T>
              interface I<T>
              class A<T> : C<Int>(), I<String>
              
              fun main() {
                  val a1: A<Double> = A<Double>()
                  val c1: C<Int> = a1
                  val i1: I<String> = a1
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-type-parameters-and-inheritance-q1"
            question: |-
              Given:
              
              ```kotlin
              open class C<T>
              interface I<T>
              class A<T> : C<T>(), I<T>
              
              val a: A<Int> = A<Int>()
              ```
              Which assignments compile?
            explanation: "A<Int> inherits C<Int> and I<Int>. Kotlin generics are invariant\
        \ by default, so C<Int> is not a subtype of C<Number>, and I<Int> is not a\
        \ subtype of I<Any>. Any is always a valid supertype."
            repeatable: true
            answers:
              - "val c: C<Int> = a"
              - "val cNum: C<Number> = a"
              - "val i: I<Int> = a"
              - "val iAny: I<Any> = a"
              - "val any: Any = a"
            correct:
              - "val c: C<Int> = a"
              - "val i: I<Int> = a"
              - "val any: Any = a"
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-type-parameters-and-inheritance-q2"
            question: |-
              Given:
              
              ```kotlin
              open class C<T>
              interface I<T>
              class A<T> : C<Int>(), I<String>
              
              val a: A<Double> = A<Double>()
              ```
              Which assignments compile?
            explanation: "The child type parameter T is independent of supertypes. A<T>\
        \ always extends C<Int> and implements I<String>, regardless of T. Generics\
        \ are invariant, so C<Double> and I<Double> don't match."
            repeatable: true
            answers:
              - "val c: C<Int> = a"
              - "val cDouble: C<Double> = a"
              - "val i: I<String> = a"
              - "val iDouble: I<Double> = a"
              - "val any: Any = a"
            correct:
              - "val c: C<Int> = a"
              - "val i: I<String> = a"
              - "val any: Any = a"
          - type: "text"
            stepId: "lesson-21_generics-type-erasure-text"
            repeatable: false
            text: |-
              Generic types were added to Java for developers' convenience, but they were never built into the JVM platform. All type arguments are lost when we compile Kotlin to JVM bytecode. Under the hood, this means that `List<String>`  becomes `List`, and `emptyList<Double>` becomes `emptyList`. The process of losing type arguments is known as **type erasure**. Due to this process, type parameters have some limitations compared to regular types. You cannot use them for `is` checks; you cannot reference them; and you cannot use them as reified type arguments.
              
              ```kotlin
              import kotlin.reflect.typeOf
              
              fun <T> example(a: Any) {
                  val check = a is T // ERROR
                  val ref = T::class // ERROR
                  val type = typeOf<T>() // ERROR
              }
              ```
              
              However, Kotlin can overcome these limitations thanks to the use of inline functions with reified type arguments. This topic is covered in depth in the chapter *Inline functions* in the book *Functional Kotlin*.
              
              ```kotlin
              import kotlin.reflect.typeOf
              
              inline fun <reified T> example(a: Any) {
                  val check = a is T
                  val ref = T::class
                  val type = typeOf<T>()
              }
              ```
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-type-erasure-q1"
            question: "Which of the following Kotlin declarations compile on the JVM, given\
        \ type erasure rules? Assume necessary imports for `kotlin.reflect.typeOf`."
            explanation: "Due to type erasure, a non-reified type parameter `T` cannot be\
        \ used in `is` checks, referenced as `T::class`, or used with `typeOf<T>()`.\
        \ Marking the function `inline` with a `reified` `T` lifts these limitations."
            repeatable: true
            answers:
              - |-
                ```kotlin
                fun <T> isOf(a: Any) = a is T
                ```
              - |-
                ```kotlin
                inline fun <reified T> isOf(a: Any) = a is T
                ```
              - |-
                ```kotlin
                fun <T> kClass() = T::class
                ```
              - |-
                ```kotlin
                inline fun <reified T> kClass() = T::class
                ```
              - |-
                ```kotlin
                inline fun <reified T> kType() = typeOf<T>()
                ```
            correct:
              - |-
                ```kotlin
                inline fun <reified T> isOf(a: Any) = a is T
                ```
              - |-
                ```kotlin
                inline fun <reified T> kClass() = T::class
                ```
              - |-
                ```kotlin
                inline fun <reified T> kType() = typeOf<T>()
                ```
          - type: "question-single-answer"
            stepId: "lesson-21_generics-type-erasure-q2"
            question: |-
              To make the following function compile and perform a real runtime check of `T`, what change is required?
              
              ```kotlin
              fun <T> describe(a: Any): Boolean {
                  return a is T || T::class == String::class
              }
              ```
            explanation: "On the JVM, type erasure prevents using `T` in `is` checks or\
        \ referencing `T::class` unless `T` is reified in an inline function. Variance\
        \ or `typeOf<T>()` without reification does not help."
            repeatable: false
            answers:
              - "Add inline and reified to T: `inline fun <reified T> describe(a: Any)`"
              - "Add out variance to T: `fun <out T> describe(a: Any)`"
              - "Replace `T::class` with `typeOf<T>()` without other changes"
              - "No change needed on JVM; it already compiles"
            correct: "Add inline and reified to T: `inline fun <reified T> describe(a: Any)`"
          - type: "text"
            stepId: "lesson-21_generics-generic-constraints-text"
            repeatable: false
            text: "An important feature of type parameters is that they can be constrained\
        \ to be a subtype of a concrete type. We set a constraint by placing a supertype\
        \ after a colon. For instance, let's say that you implement the `maxOf` function,\
        \ which returns the biggest of its arguments. To find the biggest one, the\
        \ arguments need to be comparable. So, next to the type parameter, we can\
        \ specify that we accept only types that are a subtype of `Comparable<T>`.\n\
        \n```kotlin\nimport java.math.BigDecimal\n\nfun <T : Comparable<T>> maxOf(a:\
        \ T, b: T): T {\n    return if (a >= b) a else b\n}\n\nfun main() {\n    val\
        \ m = maxOf(BigDecimal(\"10.00\"), BigDecimal(\"11.00\"))\n    println(m)\
        \ // 11.00\n\n    class A\n    maxOf(A(), A()) // Compilation error, \n  \
        \  // A is not Comparable<A>\n}\n```\n\nType parameter constraints are also\
        \ used for generic classes. Consider the `ListAdapter` class below, which\
        \ expects a type argument that is a subtype of `ItemAdapter`.\n\n```kotlin\n\
        class ListAdapter<T : ItemAdapter>(/*...*/) { /*...*/ }\n```\n\nAn important\
        \ result of having a constraint is that instances of this type can use all\
        \ the methods offered by this type. In this way, when `T` is constrained as\
        \ a subtype of `Iterable<Int>`, we know that we can iterate over an instance\
        \ of type `T`, and that elements returned by the iterator will be of type\
        \ `Int`. When we are constrained to `Comparable<T>`, we know that this type\
        \ can be compared with another instance of the same type. Another popular\
        \ choice for a constraint is `Any`, which means that a type can be any non-nullable\
        \ type.\n\nIn rare cases in which we might need to set more than one upper\
        \ bound, we can use `where` to set more constraints. We add it after the class\
        \ or function name, and we use it to specify more than one generic constraint\
        \ for a single type.\n\n```kotlin\ninterface Animal {\n    fun feed()\n}\n\
        interface GoodTempered {\n    fun pet()\n}\n\nfun <T> pet(animal: T) where\
        \ T : Animal, T : GoodTempered {\n    animal.pet()\n    animal.feed()\n}\n\
        \nclass Cookie : Animal, GoodTempered {\n    override fun pet() {\n      \
        \  // ...\n    }\n    override fun feed() {\n        // ...\n    }\n}\nclass\
        \ Cujo : Animal {\n    override fun feed() {\n        // ...\n    }\n}\n\n\
        fun main() {\n    pet(Cookie()) // OK\n    pet(Cujo()) //COMPILATION ERROR,\
        \ Cujo is not GoodTempered\n}\n```"
          - type: "question-single-answer"
            stepId: "lesson-21_generics-generic-constraints-q1"
            question: "You want a generic `maxOf` that works for `BigDecimal` and uses `>=`\
        \ inside. Which declaration is correct?"
            explanation: "`BigDecimal` implements `Comparable<BigDecimal>`, so the correct\
        \ bound is `T : Comparable<T>`. Other options either miss the bound or use\
        \ incompatible bounds (e.g., `Comparable<T?>` or `Comparable<Any?>`)."
            repeatable: true
            answers:
              - "fun <T : Comparable<T>> maxOf(a: T, b: T): T = if (a >= b) a else b"
              - "fun <T> maxOf(a: T, b: T): T where T : Comparable<T?> = if (a >= b) a else\
        \ b"
              - "fun <T : Comparable<Any?>> maxOf(a: T, b: T): T = if (a >= b) a else b"
              - "fun <T> maxOf(a: T, b: T): T = if (a >= b) a else b"
            correct: "fun <T : Comparable<T>> maxOf(a: T, b: T): T = if (a >= b) a else\
        \ b"
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-generic-constraints-q2"
            question: "Which Kotlin declarations correctly constrain a type parameter to\
        \ be both `Animal` and `GoodTempered` so that both `pet()` and `feed()` can\
        \ be called?"
            explanation: "Kotlin allows one upper bound in the angle brackets; additional\
        \ bounds go in a `where` clause. Each constraint in `where` must repeat `T`.\
        \ Intersection syntax with `&` or listing supertypes without `T` is invalid."
            repeatable: true
            answers:
              - "fun <T> pet(animal: T) where T : Animal, T : GoodTempered { animal.pet();\
        \ animal.feed() }"
              - "fun <T : Animal> pet(animal: T) where T : GoodTempered { animal.pet(); animal.feed()\
        \ }"
              - "fun <T : Animal, GoodTempered> pet(animal: T) { animal.pet(); animal.feed()\
        \ }"
              - "fun <T : Animal & GoodTempered> pet(animal: T) { animal.pet(); animal.feed()\
        \ }"
              - "fun <T> pet(animal: T) where Animal, GoodTempered { animal.pet(); animal.feed()\
        \ }"
            correct:
              - "fun <T> pet(animal: T) where T : Animal, T : GoodTempered { animal.pet();\
        \ animal.feed() }"
              - "fun <T : Animal> pet(animal: T) where T : GoodTempered { animal.pet(); animal.feed()\
        \ }"
          - type: "text"
            stepId: "lesson-21_generics-star-projection-text"
            repeatable: false
            text: |-
              In some cases, we don’t want to specify a concrete type argument for a type. In these scenarios, we can use a star projection `*`, which accepts any type. There are two situations where this is useful. The first is when you check if a variable is a list. In this case, you should use the `is List<*>` check. Star projection should be used in such a case because of type erasure. If you used `List<Int>`, it would be compiled to `List` under the hood anyway. This means a list of strings would pass the `is List<Int>` check. Such a check would be confusing and is illegal in Kotlin. You must use `is List<*>` instead.
              
              ```kotlin
              fun main() {
                  val list = listOf("A", "B")
                  println(list is List<*>) // true
                  println(list is List<Int>) // Compilation error
              }
              ```
              
              Star projection can also be used for properties or parameters. You can use `List<*>` when you want to express that you want a list, no matter what the type of its elements. When you get elements from such a list, they are of type `Any?`, which is the supertype of all the types.
              
              ```kotlin
              fun printSize(list: List<*>) {
                  println(list.size)
              }
              
              fun printList(list: List<*>) {
                  for (e in list) { // the type of e is Any?
                      println(e)
                  }
              }
              ```
              
              Star projection should not be confused with the `Any?` type argument. To see this, let's compare `MutableList<Any?>` and `MutableList<*>`. Both of these types declare `Any?` as generic result types. However, when elements are added, `MutableList<Any?>` accepts anything (`Any?`), but `MutableList<*>` accepts `Nothing`, so it does not accept any values.
              
              ```kotlin
              fun main() {
                  val l1: MutableList<Any?> = mutableListOf("A")
                  val r1 = l1.first() // the type of r1 is Any?
                  l1.add("B") // the expected argument type is Any?
              
                  val l2: MutableList<*> = mutableListOf("A")
                  val r2 = l2.first() // the type of r2 is Any?
                  l2.add("B") // ERROR,
                  // the expected argument type is Nothing,
                  // so there is no value that might be used as an argument
              }
              ```
              
              When a star projection is used as an argument, it will be treated as `Any?` in all the out-positions (result types), and it will be treated as `Nothing` in all the in-positions (parameter types).
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-star-projection-q1"
            question: |-
              Given:
              
              ```kotlin
              val x: Any = listOf("A", "B")
              ```
              Which of the following `is` checks compile in Kotlin? Choose all that apply.
            explanation: "Due to type erasure, you cannot check concrete type arguments\
        \ at runtime. Only star-projected checks (e.g., `List<*>`, `MutableList<*>`,\
        \ `Collection<*>`) are allowed."
            repeatable: true
            answers:
              - "x is List<*>"
              - "x is MutableList<*>"
              - "x is List<Int>"
              - "x is List<Any?>"
              - "x is Collection<*>"
            correct:
              - "x is List<*>"
              - "x is MutableList<*>"
              - "x is Collection<*>"
          - type: "question-exact-text"
            stepId: "lesson-21_generics-star-projection-q2"
            question: "In Kotlin, for a parameter of type `MutableList<*>`, what is the\
        \ type expected by `add(...)`?"
            explanation: "With star projection, all in-positions are treated as `Nothing`,\
        \ so no value can be added."
            repeatable: false
            correct:
              - "Nothing"
          - type: "text"
            stepId: "lesson-21_generics-underscore-operator-for-type-arguments-text"
            repeatable: false
            text: |-
              Type arguments can be either specified explicitly or inferred from the context. However, sometimes we want to specify one type argument and let the compiler infer the other. In such a case, we can use the underscore operator `_` as a type argument. This operator specifies that we want to infer a type argument.
              
              ```kotlin
              inline fun <K, reified V> Map<K, *>
                      .filterValueIsInstance(): Map<K, V> =
                  filter { it.value is V } as Map<K, V>
              
              fun main() {
                  val props = mapOf(
                      "name" to "Alex",
                      "age" to 25,
                      "city" to "New York"
                  )
                  // One type argument inferred with _, one specified
                  val strProps = props.filterValueIsInstance<_, String>()
                  println(strProps) // {name=Alex, city=New York}
              }
              ```
          - type: "question-single-answer"
            stepId: "lesson-21_generics-underscore-operator-for-type-arguments-q1"
            question: |-
              Given:
              
              ```kotlin
              inline fun <K, reified V> Map<K, *>.filterValueIsInstance(): Map<K, V> =
                  filter { it.value is V } as Map<K, V>
              
              val m: Map<Long, Any?> = mapOf(1L to 2.0, 2L to "x")
              ```
              
              Which call correctly uses `_` to let the compiler infer the key type while filtering entries whose values are `Double`?
            explanation: "`_` can be used as a placeholder in explicit type arguments at\
        \ the call site to request inference for that position. Here we specify `V\
        \ = Double` and infer `K = Long`. `Long, _` leaves the needed `V` unspecified;\
        \ a single `Double` would bind to `K`; `*` is not allowed in explicit type\
        \ arguments."
            repeatable: false
            answers:
              - "m.filterValueIsInstance<_, Double>()"
              - "m.filterValueIsInstance<Long, _>()"
              - "m.filterValueIsInstance<Double>()"
              - "m.filterValueIsInstance<*, Double>()"
            correct: "m.filterValueIsInstance<_, Double>()"
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-underscore-operator-for-type-arguments-q2"
            question: "Select all correct statements about the underscore `_` when used\
        \ as a type argument in Kotlin."
            explanation: "`_` is a call-site placeholder for a type argument to be inferred;\
        \ it is not valid in type declarations. It is different from `*` (star projection),\
        \ which is used in type positions like `Map<K, *>`."
            repeatable: true
            answers:
              - "It can be used in explicit type arguments of a call to ask the compiler to\
        \ infer that type."
              - "It is allowed in type positions like property declarations: `val x: List<_>`."
              - "It is interchangeable with `*` (star projection)."
              - "It can appear together with other explicitly specified type arguments, e.g.\
        \ `map.filterValueIsInstance<_, String>()`."
            correct:
              - "It can be used in explicit type arguments of a call to ask the compiler to\
        \ infer that type."
              - "It can appear together with other explicitly specified type arguments, e.g.\
        \ `map.filterValueIsInstance<_, String>()`."
          - type: "text"
            stepId: "lesson-21_generics-summary-text"
            repeatable: false
            text: "For many developers, generics seem so hard and scary, but they are actually\
        \ quite simple and intuitive. We can make an element generic by specifying\
        \ its type parameter (or parameters). Such a type parameter can be used inside\
        \ this element. This mechanism lets us generalize algorithms and classes so\
        \ that they can be used with different types. It is good to understand how\
        \ generics work, which is why this chapter has presented nearly all aspects\
        \ of this mechanism. However, there are a few more, and they are presented\
        \ in the book *Advanced Kotlin*, where we still need to discuss\
        \ variance modifiers (`out` and `in`)."
          - type: "question-single-answer"
            stepId: "lesson-21_generics-summary-q1"
            question: "Which declaration correctly defines a generic function that returns\
        \ its argument unchanged?"
            explanation: "In Kotlin, type parameters are declared before the function name,\
        \ and the same type parameter must be used consistently in the parameter and\
        \ return types."
            repeatable: true
            answers:
              - "`fun <T> identity(x: T): T = x`"
              - "`fun identity<T>(x: T): T = x`"
              - "`fun <T> identity(x: Any): T = x`"
              - "`fun identity(x: T): T = x`"
            correct: "`fun <T> identity(x: T): T = x`"
          - type: "question-multiple-answer"
            stepId: "lesson-21_generics-summary-q2"
            question: "Which of the following are Kotlin variance modifiers used in generic\
        \ type parameter declarations?"
            explanation: "`in` and `out` are Kotlin's variance modifiers. `reified` is a\
        \ type parameter modifier (not variance), `crossinline` is a parameter modifier\
        \ for lambdas, and `covariant` is a concept, not a keyword."
            repeatable: true
            answers:
              - "in"
              - "out"
              - "reified"
              - "crossinline"
              - "covariant"
            correct:
              - "in"
              - "out"
