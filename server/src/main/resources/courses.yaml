---
courses:
- courseId: "course-kotlin_essentials"
  title: "Course kotlin_essentials"
  lessons:
  - lessonId: "lesson-what-is-kotlin?"
    name: "What is Kotlin?"
    steps:
    - type: "text"
      stepId: "lesson-01_what_is_kotlin-where-do-we-use-kotlin?-text"
      repeatable: false
      text: |-
        Kotlin can be used as an alternative to Java, JavaScript, C++, Objective-C, etc. However, it is most mature on JVM, so it is currently mainly used as an alternative to Java.

        Kotlin has become quite popular for backend development. I most often see it used with the Spring framework, but some projects use Kotlin with backend frameworks like Vert.x, Ktor, Micronaut, http4k or Javalin.

        Kotlin has also practically become the standard language for Android development. Google has officially suggested that all Android applications should be written in Kotlin and has announced that all their APIs will be designed primarily for Kotlin.

        More and more projects are now taking advantage of the fact that Kotlin can be compiled for a few different platforms because this means that teams can write code that runs on both Android and iOS, or on both the backend and the frontend. Moreover, this cross-platform compatibility means that library creators can create one library for multiple platforms at the same time. Kotlin’s multiplatform capabilities are already being used in many companies, and they are getting more and more popular.

        It is also worth mentioning Jetpack Compose, which is a toolkit for building native UIs in Kotlin. It was initially developed for Android, but it uses Kotlin’s multiplatform capabilities and can also be used to create views for websites, desktop applications, iOS applications, and other targets.

        A lot of developers are using Kotlin for front-end development, mainly using React, and there is also a growing community of data scientists using Kotlin.

        As you can see, there is already a lot that you can do in Kotlin, and there are more and more possibilities as each year passes. I am sure you will find good ways to apply your new knowledge once you’ve finished reading this book.
    - type: "text"
      stepId: "lesson-01_what_is_kotlin-the-kotlin-ide-text"
      repeatable: false
      text: "The most popular Kotlin IDEs (integrated development environments) are\
        \ IntelliJ IDEA and Android Studio. However, you can also write programs in\
        \ Kotlin using VS Code, Eclipse, Vim, Emacs, Sublime Text, and many more.\
        \ You can also write Kotlin code online, for instance, using the official\
        \ online IDE that can be found at this link [play.kotlinlang.org](play.kotlinlang.org/)."
    - type: "text"
      stepId: "lesson-01_what_is_kotlin-kotlin-platforms-text"
      repeatable: false
      text: |-
        Kotlin is a compiled programming language. This means that you can write some code in Kotlin and then use the Kotlin compiler to produce code in a lower-level language. Kotlin can currently be compiled into JVM bytecode (Kotlin/JVM), JavaScript (Kotlin/JS), or machine code (Kotlin/Native).

        ![](kotlin_compile_results.png)

        In this book, I would like to address all these compilation targets and, by default, show code that works on all of them, but I will concentrate on the most popular one: Kotlin/JVM.

        Kotlin/JVM is the technology that’s used to compile Kotlin code into JVM bytecode. The result is nearly identical to the result of compiling Java code into JVM bytecode. We also use the term “Kotlin/JVM” to talk about code that will be compiled into JVM bytecode.

        ![](Kotlin_Java_compile.png)

        Kotlin/JVM and Java are fully interoperable. Any code written in Java can be used in Kotlin/JVM. Any Java library, including those based on annotation processing, can be used in Kotlin/JVM. Kotlin/JVM can use Java classes, modules, libraries, and the Java standard library. Any Kotlin/JVM code can be used in Java (except for suspending functions, which are a support for Kotlin Coroutines).

        ![](Java_interoperability.png)

        Kotlin and Java can be mixed in a single project. A typical scenario is that a project was initially developed in Java, but then its creators decided to start using Kotlin. To do this, instead of migrating the whole project, these developers decided to add Kotlin to it. So, whenever they add a new file, it will be a Kotlin file; furthermore, when they refactor old Java code, they will migrate it to Kotlin. Over time, there is more and more Kotlin code until it excludes Java completely.

        ![](mix_Kotlin_Java.png)

        One example of such a project is the Kotlin compiler itself. It was initially written in Java, but more and more files were migrated to Kotlin when it became stable enough. This process has been happening for years now; at the time of writing this book, the Kotlin compiler project still contains around 10% of Java code.

        Now that we understand the relationship between Kotlin and Java, it is time to fight some misconceptions. Many see Kotlin as a layer of syntactic sugar on top of Java, but this is not true. Kotlin is a different language than Java. It has its own conventions and practices, and it has features that Java does not have, like multiplatform capabilities and coroutines. You don’t need to know Java to understand Kotlin. In my opinion, Kotlin is a better first language than Java. Junior Kotlin developers do not need to know what the `equals` method is and how to override it. For them, it is enough to know the default class and data class equality. They don’t need to learn to write getters and setters, or how to implement a singleton or a builder pattern. Kotlin has a lower entry threshold than Java and does not need the JVM platform.
    - type: "text"
      stepId: "lesson-01_what_is_kotlin-{sample:-true}-text"
      repeatable: false
      text: |-
        # What is Kotlin?

        Kotlin is an open-source, multiplatform, multi-paradigm, statically typed, general-purpose programming language. But what does all this mean?
        * Open-source means that the sources of the Kotlin compiler are freely available for modification and redistribution. Kotlin is primarily made by JetBrains, but now there is the Kotlin Foundation, which promotes and advances the development of this language. There is also a public process known as KEEP, which allows anyone to see and comment on official design change propositions.
        * Multiplatform means that a language can be used on more than one platform. For instance, Kotlin can be used both on Android and iOS.
        * Multi-paradigm means that a language has support for more than one programming paradigm. Kotlin has powerful support for both Object-Oriented Programming and Functional Programming.
        * Statically typed means that each variable, object, and function has an associated type that is known at compile time.
        * General-purpose means that a language is designed to be used for building software in a wide variety of application domains across a multitude of hardware configurations and operating systems.

        These descriptions might not be clear now, but you will see them all in action throughout the book. Let’s start by discussing Kotlin’s multiplatform capabilities.
    - type: "question-single-answer"
      stepId: "lesson-01_what_is_kotlin-{sample:-true}-q1"
      question: "In Kotlin, what does “statically typed” mean?"
      explanation: "In a statically typed language, types are known and checked at\
        \ compile time. Kotlin still has type inference, but inferred types are resolved\
        \ at compile time."
      repeatable: true
      answers:
      - "Types are known and checked at compile time"
      - "Types are checked only at runtime"
      - "Variables can change type after assignment"
      - "The language doesn’t support generics"
      correct: "Types are known and checked at compile time"
    - type: "question-multiple-answer"
      stepId: "lesson-01_what_is_kotlin-{sample:-true}-q2"
      question: "Which statements correctly reflect the text about Kotlin?"
      explanation: "The text states Kotlin is open-source (compiler sources available),\
        \ multi-paradigm (OOP and FP), and multiplatform (e.g., Android and iOS).\
        \ It’s not proprietary and not developed solely by Google."
      repeatable: false
      answers:
      - "Kotlin can be used on both Android and iOS"
      - "Kotlin supports both OOP and FP"
      - "Kotlin compiler sources are available for modification and redistribution"
      - "Kotlin is proprietary and closed-source"
      - "Kotlin is developed solely by Google"
      correct:
      - "Kotlin can be used on both Android and iOS"
      - "Kotlin supports both OOP and FP"
      - "Kotlin compiler sources are available for modification and redistribution"
    - type: "question-multiple-answer"
      stepId: "lesson-01_what_is_kotlin-kotlin-platforms-q1"
      question: "Which compilation targets are explicitly mentioned as supported by\
        \ Kotlin in this section?"
      explanation: "The section lists three targets: JVM bytecode (Kotlin/JVM), JavaScript\
        \ (Kotlin/JS), and machine code via Kotlin/Native. WebAssembly and Python\
        \ bytecode are not mentioned."
      repeatable: true
      answers:
      - "JVM bytecode (Kotlin/JVM)"
      - "JavaScript (Kotlin/JS)"
      - "Machine code (Kotlin/Native)"
      - "WebAssembly"
      - "Python bytecode"
      correct:
      - "JVM bytecode (Kotlin/JVM)"
      - "JavaScript (Kotlin/JS)"
      - "Machine code (Kotlin/Native)"
    - type: "question-multiple-answer"
      stepId: "lesson-01_what_is_kotlin-kotlin-platforms-q2"
      question: "Which statements about Kotlin/JVM and Java interoperability are correct\
        \ according to the section?"
      explanation: "Kotlin/JVM can use Java classes, the Java standard library, and\
        \ libraries relying on annotation processing. Java can call Kotlin/JVM code\
        \ except for suspending functions. Kotlin and Java can be mixed in one project."
      repeatable: true
      answers:
      - "Kotlin/JVM can directly use Java classes and the Java standard library"
      - "Java code can call Kotlin suspending functions without any extra support"
      - "Kotlin/JVM can use Java libraries that rely on annotation processing"
      - "Kotlin and Java sources can coexist in a single project"
      - "Kotlin code cannot be consumed from Java"
      correct:
      - "Kotlin/JVM can directly use Java classes and the Java standard library"
      - "Kotlin/JVM can use Java libraries that rely on annotation processing"
      - "Kotlin and Java sources can coexist in a single project"
    - type: "question-multiple-answer"
      stepId: "lesson-01_what_is_kotlin-the-kotlin-ide-q1"
      question: "Which of the following tools are mentioned in the text as environments\
        \ where you can write Kotlin code?"
      explanation: "The text lists IntelliJ IDEA, Android Studio, VS Code, and Eclipse\
        \ as environments for Kotlin; Xcode is not mentioned."
      repeatable: false
      answers:
      - "IntelliJ IDEA"
      - "Android Studio"
      - "VS Code"
      - "Eclipse"
      - "Xcode"
      correct:
      - "IntelliJ IDEA"
      - "Android Studio"
      - "VS Code"
      - "Eclipse"
    - type: "question-single-answer"
      stepId: "lesson-01_what_is_kotlin-the-kotlin-ide-q2"
      question: "What is the official online Kotlin IDE mentioned in the text?"
      explanation: "The official online IDE is at play.kotlinlang.org."
      repeatable: false
      answers:
      - "play.kotlinlang.org"
      - "try.kotlinlang.org"
      - "kotlinlang.org/play"
      - "kotlinfiddle.com"
      correct: "play.kotlinlang.org"
    - type: "question-multiple-answer"
      stepId: "lesson-01_what_is_kotlin-where-do-we-use-kotlin?-q1"
      question: "Which of the following are commonly used with Kotlin for backend\
        \ development?"
      explanation: "Spring, Ktor, Micronaut, and Javalin are server-side frameworks\
        \ frequently used with Kotlin; React is primarily for frontend (Kotlin/JS)."
      repeatable: true
      answers:
      - "Spring"
      - "Ktor"
      - "React"
      - "Micronaut"
      - "Javalin"
      correct:
      - "Spring"
      - "Ktor"
      - "Micronaut"
      - "Javalin"
    - type: "question-multiple-answer"
      stepId: "lesson-01_what_is_kotlin-where-do-we-use-kotlin?-q2"
      question: "Select all true statements about Kotlin Multiplatform and Jetpack\
        \ Compose."
      explanation: "Kotlin Multiplatform enables sharing code across Android/iOS and\
        \ lets library authors target multiple platforms. Compose started on Android\
        \ and now targets desktop/web/iOS via KMP. Kotlin does not compile only to\
        \ JVM, and KMP is used in production by many companies."
      repeatable: true
      answers:
      - "Kotlin Multiplatform lets teams share code between Android and iOS."
      - "Kotlin compiles only to JVM bytecode, so sharing with iOS isn't possible."
      - "Library authors can publish a single library targeting multiple platforms."
      - "Compose began on Android and now targets desktop/web/iOS via KMP."
      - "Kotlin Multiplatform is only experimental and not used in companies."
      correct:
      - "Kotlin Multiplatform lets teams share code between Android and iOS."
      - "Library authors can publish a single library targeting multiple platforms."
      - "Compose began on Android and now targets desktop/web/iOS via KMP."
  - lessonId: "lesson-your-first-program-in-kotlin"
    name: "Your first program in Kotlin"
    steps:
    - type: "text"
      stepId: "lesson-02_first_program-summary-text"
      repeatable: false
      text: "We've learned about using `main` functions and creating them easily with\
        \ live templates. We’ve also learned how to find out what our Kotlin code\
        \ would look like if it were written in Java. For me, it seems like we have\
        \ quite a nice toolbox for starting our adventure. So, without further ado,\
        \ let's get on with that."
    - type: "text"
      stepId: "lesson-02_first_program-packages-and-importing-text"
      repeatable: false
      text: "When our project has more than one file, we need to use packages to organize\
        \ them. Packages are a way to group files together and avoid name conflicts.\
        \ \n\nA file can specify package at the top of the file using the `package`\
        \ keyword.\n\n```kotlin\npackage com.marcinmoskala.domain.model\n\nclass User(val\
        \ name: String)\n```\n\nIf we don't specify a package, the file is in the\
        \ default package. In real projects, it is recommended that package path should\
        \ be the same as the directory path in our source files. Package can also\
        \ include company domain in reverse order, like `com.marcinmoskala`. We name\
        \ package using lowercase characters only. \n\nIf we want to use a function\
        \ or class from another package, we need to import it. Imports are declared\
        \ after the package declaration and before file elements' declaration. They\
        \ first specify the package name, then the name of the element. We can also\
        \ use the `*` character to import all elements from a package.\n\n```kotlin\n\
        package com.marcinmoskala.domain\n\nimport com.marcinmoskala.domain.model.User\n\
        // or \nimport com.marcinmoskala.domain.model.*\n\nfun useUser() {\n    val\
        \ user = User(\"Marcin\")\n    // ...\n}\n```\n\nEssential elements from Kotlin\
        \ and Java strandard libraries are imported by default. For example, we can\
        \ use `println` function without importing it. \n\nKotlin's developers rarely\
        \ think about imports, because IntelliJ manage them automatically. When you\
        \ use an element using IntelliJ suggestion, it will automatically add an import\
        \ for you. If you use an element that is not imported, IntelliJ will suggest\
        \ importing it. If you want to remove unused imports, you can use the \"Remove\
        \ unused imports\" action (Ctrl/command + Alt + O). That is also why I decided\
        \ to not show imports in most of the examples in this book."
    - type: "text"
      stepId: "lesson-02_first_program-what-is-under-the-hood-on-jvm?-text"
      repeatable: false
      text: |-
        The most important target for Kotlin is JVM (Java Virtual Machine). On JVM, every element needs to be in a class. So, you might be wondering how it is possible that our main function can be started there if it is not in a class. Let's figure it out. On the way, we will learn to find out what our Kotlin code would look like if it were written in Java. This is Java developers’ most powerful tool for learning how Kotlin works.

        Let's start by opening or starting a Kotlin project in IntelliJ or Android Studio. Make a new Kotlin file called "Playground". Inside this, use the live template "maina" to create the main function with arguments and add `println("Hello, World")` inside.

        ```kotlin
        fun main(args: Array<String>) {
            println("Hello, World")
        }
        ```

        Now, select from the tabs Tools > Kotlin > Show Kotlin Bytecode.

        ![](tools_kotlin_show_bytecode.png)

        On the right side, a new tool should open. "Show Kotlin Bytecode" shows the JVM bytecode generated from this file.

        ![](show_kotlin_bytecode.png)

        This is a great place for everyone who likes reading JVM bytecode. Since not everyone is Jake Wharton, most of us might find the "Decompile" button useful. What it does is quite funny. We’ve just compiled our Kotlin code into JVM bytecode, and this button decompiles this bytecode into Java. As a result, we can see what our code would look like if it were written in Java.

        ![](hello_world_decompiled.png)

        This code reveals that our `main` function on JVM becomes a static function inside a class named `PlaygroundKt`. Where does this name come from? Try to guess. Yes, this is, by default, the file's name with the "Kt" suffix. The same happens to all other functions and properties defined outside of classes on JVM.

        If we wanted to call our `main` function from Java code, we can call `PlaygroundKt.main({})`.

        The name of `PlaygroundKt` can be changed by adding the `@file:JvmName("NewName")` annotation at the top of the file. However, this does not change how elements defined in this file are used in Kotlin. It only influences how we will use such functions from Java. For example, to call our `main` function from Java now, we would need to call `NewName.main({})`.

        If you have experience with Java, remember this tool as it can help you to understand:
        - How Kotlin code works on a low level.
        - How a certain Kotlin feature works under the hood.
        - How to use a Kotlin element in Java.

        There are proposals to make a similar tool to show JavaScript generated from Kotlin code when our target is Kotlin/JS. However, at the time of writing this book, the best you can do is to open the generated files yourself.
    - type: "text"
      stepId: "lesson-02_first_program-live-templates-text"
      repeatable: false
      text: |-
        If you decide to test or practice the material from this book, you will likely be writing the `main` function quite often. Here come *live templates* to help us. This is an IntelliJ feature that suggests using a template when you start typing its name in a valid context. So, if you start typing "main" or "maina" (for main with arguments) in a Kotlin file, you will be shown a suggestion that offers the whole `main` function.

        ![](main_template.png)

        In most my workshops, I’ve used this template hundreds of times. Whenever I want to show something new with live coding, I open a "Playground" file, select all its content (Ctrl/command + A), type "main", confirm the live template with Enter, and I have a perfect space for showing how Kotlin works.

        I also recommend you test this now. Open any Kotlin project (it is best if you have a dedicated project for playing with Kotlin), create a new file (you can name it "Test" or "Playground"), and create the `main` function with the live template “maina”. Use the `print` function with some text, and run the code with the Run button.
    - type: "text"
      stepId: "lesson-02_first_program-{sample:-true}-text"
      repeatable: false
      text: |-
        # Your first program in Kotlin

        The first step in our Kotlin adventure is to write a minimal program in this language. Yes, it’s the famous "Hello, World!" program. This is what it looks like in Kotlin:

        ```kotlin
        fun main() {
            println("Hello, World")
        }
        ```

        This is minimal, isn't it? We need no classes (like we do in Java), no objects (like `console` in JavaScript), and no conditions (like in Python when we start code in the IDE). We need the `main` function and the `println` function call with some text.

        This is the most popular (but not the only) variant of the "main" function. If we need arguments, we might include a parameter of type `Array<String>`:

        ```kotlin
        fun main(args: Array<String>) {
            println("Hello, World")
        }
        ```

        There are also other forms of the `main` function:

        ```kotlin
        fun main(vararg args: String) {
            println("Hello, World")
        }
        ```

        ```kotlin
        class Test {
            companion object {
                @JvmStatic
                fun main(args: Array<String>) {
                    println("Hello, World")
                }
            }
        }
        ```

        ```kotlin
        suspend fun main() {
            println("Hello, World")
        }
        ```

        Although these are all valid, let's concentrate on the simple `main` function as we will find it most useful. I will use it in nearly every example in this book. Such examples are usually completely executable if you just copy-paste them into IntelliJ or the Online Kotlin Playground.

        ```kotlin
        fun main() {
            println("Hello, World")
        }
        ```

        All you need to do to start the `main` function in IntelliJ is click the green triangle which appears on the left side of the `main` function; this is called the "gutter icon", also known as the "Run" button.

        ![](main_run.png)
    - type: "question-multiple-answer"
      stepId: "lesson-02_first_program-{sample:-true}-q1"
      question: "Which of the following are valid Kotlin/JVM entry point declarations\
        \ (recognized as the program's main function) as shown in the section?"
      explanation: "Kotlin recognizes top-level `main` with no args, `Array<String>`,\
        \ or `vararg String`; `suspend fun main()` is also supported. A companion\
        \ object's `@JvmStatic` main is a valid JVM entry point. `List<String>` is\
        \ not a valid entry point parameter type."
      repeatable: true
      answers:
      - "`fun main()`"
      - "`fun main(args: Array<String>)`"
      - "`fun main(vararg args: String)`"
      - |-
        ```
        class Test {
            companion object {
                @JvmStatic
                fun main(args: Array<String>) { }
            }
        }
        ```
      - "`suspend fun main()`"
      - "`fun main(args: List<String>)`"
      correct:
      - "`fun main()`"
      - "`fun main(args: Array<String>)`"
      - "`fun main(vararg args: String)`"
      - |-
        ```
        class Test {
            companion object {
                @JvmStatic
                fun main(args: Array<String>) { }
            }
        }
        ```
      - "`suspend fun main()`"
    - type: "question-single-answer"
      stepId: "lesson-02_first_program-live-templates-q1"
      question: "In IntelliJ IDEA for Kotlin, which live template inserts a `main`\
        \ function that accepts command-line arguments?"
      explanation: "The Kotlin live template “maina” expands to `fun main(args: Array<String>)\
        \ {}`. “main” is the no-arg entry point; “psvm” is a Java template; “kmain”\
        \ doesn’t exist by default."
      repeatable: false
      answers:
      - "main"
      - "maina"
      - "psvm"
      - "kmain"
      correct: "maina"
    - type: "question-single-answer"
      stepId: "lesson-02_first_program-live-templates-q2"
      question: "What IntelliJ IDEA feature lets you type an abbreviation like “main”\
        \ in a Kotlin file and expand it into a full code snippet by pressing Enter?"
      explanation: "Live Templates expand predefined snippets like `main`/`maina`.\
        \ Postfix completion operates on existing expressions (e.g., `.if`), Surround\
        \ With wraps selected code, and Code Generation (Alt+Insert) creates members\
        \ via a dialog."
      repeatable: false
      answers:
      - "Live Templates"
      - "Postfix completion"
      - "Surround With"
      - "Code Generation (Alt+Insert)"
      correct: "Live Templates"
    - type: "question-single-answer"
      stepId: "lesson-02_first_program-what-is-under-the-hood-on-jvm?-q1"
      question: |-
        Given file name is `Report.kt` and it contains a top-level function:

        ```kotlin
        fun generate() { }
        ```
        No packages and no annotations are used. From Java, which call targets this function?
      explanation: "Top-level Kotlin functions on JVM become static methods in a synthetic\
        \ class named `<FileName>Kt`. Without annotations, Java calls `ReportKt.generate()`."
      repeatable: true
      answers:
      - "Report.generate()"
      - "ReportKt.generate()"
      - "KotlinReport.generate()"
      - "NewName.generate()"
      correct: "ReportKt.generate()"
    - type: "question-single-answer"
      stepId: "lesson-02_first_program-what-is-under-the-hood-on-jvm?-q2"
      question: "You have `Playground.kt` with a top-level `main` function. After\
        \ adding `@file:JvmName(\"NewName\")` at the top, what changes?"
      explanation: "`@file:JvmName` changes only the generated JVM class name used\
        \ from Java. Kotlin usage is unchanged."
      repeatable: true
      answers:
      - "In Kotlin, call sites must change to `NewName.main(...)`"
      - "In Java, you call `NewName.main(...)` instead of `PlaygroundKt.main(...)`"
      - "Both Kotlin and Java call sites must change"
      - "It moves functions to a package named `NewName`"
      correct: "In Java, you call `NewName.main(...)` instead of `PlaygroundKt.main(...)`"
    - type: "question-multiple-answer"
      stepId: "lesson-02_first_program-packages-and-importing-q1"
      question: "Assume class `User` is declared in package `com.marcinmoskala.domain.model`.\
        \ You are writing `UseUser.kt` in package `com.marcinmoskala.domain`. Which\
        \ file header(s) let you use `User` without fully qualifying it? (Choose all\
        \ that apply)"
      explanation: "Imports must come after the package declaration and before declarations.\
        \ You can import a single symbol or use a star import. Placing import before\
        \ package is invalid; using the wrong package or no import won’t make `User`\
        \ visible."
      repeatable: true
      answers:
      - |-
        ```kotlin
        package com.marcinmoskala.domain

        import com.marcinmoskala.domain.model.User
        ```
      - |-
        ```kotlin
        import com.marcinmoskala.domain.model.User

        package com.marcinmoskala.domain
        ```
      - |-
        ```kotlin
        package com.marcinmoskala.domain

        import com.marcinmoskala.domain.model.*
        ```
      - |-
        ```kotlin
        package com.marcinmoskala.domain.model
        // no import
        ```
      - |-
        ```kotlin
        package com.marcinmoskala.domain
        // no import
        ```
      correct:
      - |-
        ```kotlin
        package com.marcinmoskala.domain

        import com.marcinmoskala.domain.model.User
        ```
      - |-
        ```kotlin
        package com.marcinmoskala.domain

        import com.marcinmoskala.domain.model.*
        ```
    - type: "question-single-answer"
      stepId: "lesson-02_first_program-packages-and-importing-q2"
      question: "Which package name follows Kotlin conventions mentioned in the text?"
      explanation: "Package names should be lowercase and typically use reversed domain\
        \ names. Slashes are invalid; mixed-case is discouraged."
      repeatable: false
      answers:
      - "com.Example.App"
      - "com.example.app.domain"
      - "example.com.app"
      - "com/example/app"
      correct: "com.example.app.domain"
    - type: "question-multiple-answer"
      stepId: "lesson-02_first_program-summary-q1"
      question: "Which top-level function declarations are valid JVM entry points\
        \ for a Kotlin application? Choose all that apply."
      explanation: "On JVM, Kotlin recognizes `fun main()`, `fun main(args: Array<String>)`,\
        \ and `suspend fun main()` as valid entry points. Using `List<String>` or\
        \ `Array<Any>` does not match the required signature."
      repeatable: true
      answers:
      - "`fun main()`"
      - "`fun main(args: Array<String>)`"
      - "`suspend fun main()`"
      - "`fun main(args: List<String>)`"
      - "`fun main(args: Array<Any>)`"
      correct:
      - "`fun main()`"
      - "`fun main(args: Array<String>)`"
      - "`suspend fun main()`"
    - type: "question-single-answer"
      stepId: "lesson-02_first_program-summary-q2"
      question: "In IntelliJ IDEA, how can you see what your Kotlin code would look\
        \ like as Java?"
      explanation: "Use IntelliJ's Kotlin Bytecode viewer and its built-in decompiler:\
        \ Tools > Kotlin > Show Kotlin Bytecode, then click Decompile."
      repeatable: false
      answers:
      - "Tools > Kotlin > Show Kotlin Bytecode, then Decompile"
      - "Right-click file > Convert to Java"
      - "Build > Recompile as Java"
      - "Analyze > Infer nullity annotations"
      correct: "Tools > Kotlin > Show Kotlin Bytecode, then Decompile"
    - type: "question-single-answer"
      stepId: "lesson-02_first_program-{sample:-true}-q2"
      question: "You decide to place `main` inside a class's companion object. What\
        \ is required for the JVM to recognize it as the entry point?"
      explanation: "Inside a companion object, `main` must be exposed as a static\
        \ JVM method; `@JvmStatic` generates the needed static method."
      repeatable: false
      answers:
      - "Annotate `main` with `@JvmStatic`"
      - "Use `vararg` in the parameter list"
      - "Mark the class as `data class`"
      - "Annotate the companion object with `@Main`"
      correct: "Annotate `main` with `@JvmStatic`"
  - lessonId: "lesson-variables"
    name: "Variables"
    steps:
    - type: "text"
      stepId: "lesson-03_variables-#-variables-text"
      repeatable: false
      text: |-
        To declare a variable in Kotlin, we start with the `val` or `var` keyword, then a variable name, the equality sign, and an initial value.
        * The keyword `var` (which stands for "variable") represents *read-write variables* and is used to define variables whose values can be reassigned after initialization. This means that if you use `var`, you can always assign a new value to this variable.
        * The keyword `val` (which stands for "value") represents *read-only variables* and is used to define values that cannot be reassigned. This means that if you use `val`, you cannot assign a new value to this variable once it is initialized.

        ```kotlin
        fun main() {
            val a = 10
            var b = "ABC"
            println(a) // 10
            println(b) // ABC
            // a = 12 is not possible, because a is read-only!
            b = "CDE"
            println(b) // CDE
        }
        ```

        We can name variables using characters, underscore `_`, and numbers (but numbers are not allowed at the first position). By convention, we name variables with the camelCase convention; this means the variable name starts with a lowercase letter, then (instead of using spaces) each next word starts with a capital letter.

        {width: 50%}
        ![In Kotlin, we name variables using camelCase.](camelCase.png)

        Variables don’t need to specify their type explicitly, but this doesn't mean that variables are not typed. Kotlin is a statically typed language, therefore every variable needs its type specified. The point is that Kotlin is smart enough to infer the type from the value that is set. `10` is of type `Int`, so the type of `a` in the above example is `Int`. `"ABC"` is of type `String`, so the type of `b` is `String`.

        {width: 60%}
        ![](104_inference.png)

        We can also specify a variable type explicitly using a colon and a type **after** the variable name.

        ```kotlin
        fun main() {
           val a: Int = 10
           var b: String = "ABC"
           println(a) // 10
           println(b) // ABC
           b = "CDE"
           println(b) // CDE
        }
        ```

        When we initialize a variable, we should give it a value. As in the example below, a variable’s definition and initialization can be separated if Kotlin can be sure that the variable won’t be used before any value is set. I suggest avoiding this practice when it’s not necessary.

        ```kotlin
        fun main() {
            val a: Int
            a = 10
            println(a) // 10
        }
        ```

        We can assume that a variable should normally be initialized by using an equality sign after its declaration (like in `val a = 10`). So, what can stand on the right side of the assignment? It can be any expression, i.e., a piece of code that returns a value. Here are the most common types of expressions in Kotlin:
        * a basic type literal, like `1` or `"ABC"`,
        * a conditional statement used as an expression, like if-expression, when-expression, or try-catch expression.
        * a constructor call,
        * a function call,
        * an object expression or an object declaration,
        * a function literal, like a lambda expression, an anonymous function, or a function reference,
        * an element reference.

        We have a lot to discuss, so let's start with basic type literals.
    - type: "question-single-answer"
      stepId: "lesson-03_variables-#-variables-q1"
      question: "Which declaration uses the correct Kotlin syntax for specifying a\
        \ variable’s explicit type?"
      explanation: "In Kotlin, the type annotation goes after the name using a colon:\
        \ `val a: Int = 10`."
      repeatable: false
      answers:
      - "val a: Int = 10"
      - "Int a = 10"
      - "val: Int a = 10"
      - "val a = 10: Int"
      - "var Int a = 10"
      correct: "val a: Int = 10"
    - type: "question-multiple-answer"
      stepId: "lesson-03_variables-#-variables-q2"
      question: "Which snippets compile successfully?"
      explanation: "- A: `val` cannot be reassigned. - B: Local `var` can be declared\
        \ without init and assigned before use. - C: Using `n` before assignment is\
        \ illegal. - D: Type is inferred as `Int`, cannot assign `String`. - E: Local\
        \ `val` may be assigned exactly once later, before any use."
      repeatable: true
      answers:
      - |-
        ```kotlin
        fun f() {
            val x = 1
            x = 2
        }
        ```
      - |-
        ```kotlin
        fun f() {
            var s: String
            s = "OK"
            println(s)
        }
        ```
      - |-
        ```kotlin
        fun f() {
            val n: Int
            println(n)
            n = 10
        }
        ```
      - |-
        ```kotlin
        fun f() {
            var a = 5
            a = "5"
        }
        ```
      - |-
        ```kotlin
        fun f() {
            val y: Int
            y = 3
        }
        ```
      correct:
      - |-
        ```kotlin
        fun f() {
            var s: String
            s = "OK"
            println(s)
        }
        ```
      - |-
        ```kotlin
        fun f() {
            val y: Int
            y = 3
        }
        ```
  - lessonId: "lesson-basic-types,-their-literals-and-operations"
    name: "Basic types, their literals and operations"
    steps:
    - type: "text"
      stepId: "lesson-04_basic_values-summary-text"
      repeatable: false
      text: |-
        In this chapter, we've learned about the basic Kotlin types and the literals we use to create them:
        * Numbers that are represented by types `Int`, `Long`, `Double`, `Float`, `Short`, and `Byte` are created with bare number values with possible suffixes for type customization. We can define negative numbers or decimal parts. We can also use underscores for nicer number formatting.
        * Boolean values `true` and `false` are represented by the `Boolean` type.
        * Characters, which are represented by the `Char` type. We define a character value using single quotation marks.
        * Strings, which are used to represent text, are represented by the `String` type. Each string is just a series of characters. We define strings inside double quotation marks.

        So, we have the foundations for using Kotlin. Let's move on to more-complicated control structures that determine how our code behaves.
    - type: "text"
      stepId: "lesson-04_basic_values-strings-text"
      repeatable: false
      text: "Strings are just sequences of characters that form a piece of text. In\
        \ Kotlin, we create a string using quotation marks `\"` or triple quotation\
        \ marks `\"\"\"`.\n\n```kotlin\nfun main() {\n    val text1 = \"ABC\"\n  \
        \  println(text1) // ABC\n    val text2 = \"\"\"DEF\"\"\"\n    println(text2)\
        \ // DEF\n}\n```\n\nA string wrapped in single quotation marks requires text\
        \ in a single line. If we want to define a newline character, we need to use\
        \ a special character `\\n`. This is not the only thing that needs (or might\
        \ need) a backslash to be expressed in a string.\n\n| Escape Sequence | Meaning\
        \               |\n|-----------------|-----------------------|\n| `\\t`  \
        \          | Tab                   |\n| `\\b`            | Backspace     \
        \        |\n| `\\r`            | Carriage return       |\n| `\\f`        \
        \    | Form feed             |\n| `\\n`            | Newline             \
        \  |\n| `\\'`            | Single quotation mark |\n| `\\\"`            |\
        \ Quotation mark        |\n| `\\\\`            | Backslash             |\n\
        | `\\$`            | Dollar                |\n\nStrings in triple quotation\
        \ marks can be multiline; in these strings, special characters can be used\
        \ directly, and forms prefixed by a backslash don’t work.\n\n```kotlin\nfun\
        \ main() {\n    val text1 = \"Let\\'s say:\\n\\\"Hooray\\\"\"\n    println(text1)\n\
        \    // Let's say:\n    // \"Hooray\"\n    val text2 = \"\"\"Let\\'s say:\\\
        n\\\"Hooray\\\"\"\"\"\n    println(text2)\n    // Let\\'s say:\\n\\\"Hooray\\\
        \"\n    val text3 = \"\"\"Let's say:\n\"Hooray\"\"\"\"\n    println(text3)\n\
        \    // Let's say:\n    // \"Hooray\"\n}\n```\n\nTo better format triple quotation\
        \ mark strings, we use the `trimIndent` function, which ignores a constant\
        \ number of spaces for each line.\n\n```kotlin\nfun main() {\n    val text\
        \ = \"\"\"\n   Let's say:\n   \"Hooray\"\n   \"\"\".trimIndent()\n    println(text)\n\
        \    // Let's say:\n    // \"Hooray\"\n\n    val description = \"\"\"\n  \
        \    A\n      B\n          C\n  \"\"\".trimIndent()\n    println(description)\n\
        \    // A\n    // B\n    //     C\n}\n```\n\nString literals may contain template\
        \ expressions, which are pieces of code that are evaluated and whose results\
        \ are concatenated into a string. A template expression starts with a dollar\
        \ sign (`$`) and consists of either a variable name (like `\"text is $text\"\
        `) or an expression in curly braces (like `\"1 + 2 = ${1 + 2}\"`).\n\n```kotlin\n\
        fun main() {\n    val name = \"Cookie\"\n    val surname = \"DePies\"\n  \
        \  val age = 6\n\n    val fullName = \"$name $surname ($age)\"\n    println(fullName)\
        \ // Cookie DePies (6)\n\n    val fullNameUpper =\n        \"${name.uppercase()}\
        \ ${surname.uppercase()} ($age)\"\n    println(fullNameUpper) // COOKIE DEPIES\
        \ (6)\n\n    val description = \"\"\"\n       Name: $name\n       Surname:\
        \ $surname\n       Age: $age\n   \"\"\".trimIndent()\n    println(description)\n\
        \    // Name: Cookie\n    // Surname: DePies\n    // Age: 6\n}\n```\n\nIf\
        \ you need to use a special character inside a triple quotation mark string,\
        \ the easiest way is to specify it with a regular string and include it using\
        \ template syntax.\n\n```kotlin\nfun main() {\n    val text1 = \"\"\"ABC\\\
        nDEF\"\"\"\n    println(text1) // ABC\\nDEF\n    val text2 = \"\"\"ABC${\"\
        \\n\"}DEF\"\"\"\n    println(text2)\n    // ABC\n    // DEF\n}\n```\n\nIn\
        \ Kotlin strings, we use Unicode, so we can also define a Unicode character\
        \ using a number that starts with `\\u`, and then specifying a Unicode character\
        \ code in hexadecimal syntax.\n\n![](unicode.png)\n\nYou can use `+` operator\
        \ to concatenate two strings, so to create a new string that is a combination\
        \ of two other strings. You can also use this operator to concatenate a string\
        \ with any other object, which will be converted to a string. The result is\
        \ always a string. \n\n```kotlin\nfun main() {\n    val text1 = \"ABC\"\n\
        \    val text2 = \"DEF\"\n    println(text1 + text2) // ABCDEF\n    println(text1\
        \ + 123) // ABC123\n    println(text1 + true) // ABCtrue\n}\n```"
    - type: "text"
      stepId: "lesson-04_basic_values-characters-text"
      repeatable: false
      text: |-
        To represent a single character, we use the `Char` type. We specify a character using apostrophes.

        ```kotlin
        fun main() {
            println('A') // A
            println('Z') // Z
        }
        ```

        Each character is represented as a Unicode number. To find out the Unicode of a character, use the `code` property.

        ```kotlin
        fun main() {
            println('A'.code) // 65
        }
        ```

        Kotlin accepts Unicode characters. To describe them by their code, we start with `\u`, and then we need to use hexadecimal format, just like in Java.

        ```kotlin
        fun main() {
            println('\u00A3') // £
        }
        ```
    - type: "text"
      stepId: "lesson-04_basic_values-boolean-operations-text"
      repeatable: false
      text: |-
        There are three basic logical operators in Kotlin:
        * and `&&`, which returns `true` when the value on both its sides is `true`; otherwise, it returns `false`.
        * or `||`, which returns `true` when the value on either of its sides is `true`; otherwise, it returns `false`.
        * not `!`, which turns `true` into `false`, and `false` into `true`.

        ```kotlin
        fun main() {
            println(true && true) // true
            println(true && false) // false
            println(false && true) // false
            println(false && false) // false

            println(true || true) // true
            println(true || false) // true
            println(false || true) // true
            println(false || false) // false

            println(!true) // false
            println(!false) // true
        }
        ```

        Kotlin does not support any kind of automatic conversion to `Boolean` (or any other type), so logical operators should be used only with objects of type `Boolean`.
    - type: "text"
      stepId: "lesson-04_basic_values-equality-text"
      repeatable: false
      text: |-
        A `Boolean` is often a result of equality comparison. In Kotlin, we compare two objects for equality using the double equality sign `==`. To check if two objects are not equal, we use the non-equality sign `!=`.

        ```kotlin
        fun main() {
            println(10 == 10) // true
            println(10 == 11) // false
            println(10 != 10) // false
            println(10 != 11) // true
        }
        ```

        Numbers and all objects that are comparable (i.e., they implement the `Comparable` interface) can also be compared with `>`, `<`, `>=`, and `<=`.

        ```kotlin
        fun main() {
            println(10 > 10) // false
            println(10 > 11) // false
            println(11 > 10) // true

            println(10 < 10) // false
            println(10 < 11) // true
            println(11 < 10) // false

            println(10 >= 10) // true
            println(10 >= 11) // false
            println(11 >= 10) // true

            println(10 <= 10) // true
            println(10 <= 11) // true
            println(11 <= 10) // false
        }
        ```
    - type: "text"
      stepId: "lesson-04_basic_values-booleans-text"
      repeatable: false
      text: |-
        Another basic type is `Boolean`, which has two possible values: `true` and `false`.

        ```kotlin
        fun main() {
            val b1: Boolean = true
            println(b1) // true
            val b2: Boolean = false
            println(b2) // false
        }
        ```

        We use booleans to express yes/no answers, like:
        * Is the user an admin?
        * Has the user accepted the cookies policy?
        * Are two numbers identical?

        In practice, booleans are often a result of some kind of comparison.
    - type: "text"
      stepId: "lesson-04_basic_values-`bigdecimal`-and-`biginteger`-text"
      repeatable: false
      text: |-
        All basic types in Kotlin have limited size and precision, which can lead to imprecise or incorrect results in some situations.

        ```kotlin
        fun main() {
            println(0.1 + 0.2) // 0.30000000000000004
            println(2147483647 + 1) // -2147483648
        }
        ```

        This is a standard tradeoff in programming, and in most cases we just need to accept it. However, there are cases where we need to have perfect precision and unlimited number size. On JVM, for unlimited number size we should use `BigInteger`, which represents a number without a decimal part. For unlimited size and precision, we should use the `BigDecimal`, which represents a number that has a decimal part. Both can be created using constructors, factory functions (like `valueOf`), or a conversion from basic types that represent numbers (`toBigDecimal` and `toBigInteger` methods).

        ```kotlin
        import java.math.BigDecimal
        import java.math.BigInteger

        fun main() {
            val i = 10
            val l = 10L
            val d = 10.0
            val f = 10.0F

            val bd1: BigDecimal = BigDecimal(123)
            val bd2: BigDecimal = BigDecimal("123.00")
            val bd3: BigDecimal = i.toBigDecimal()
            val bd4: BigDecimal = l.toBigDecimal()
            val bd5: BigDecimal = d.toBigDecimal()
            val bd6: BigDecimal = f.toBigDecimal()
            val bi1: BigInteger = BigInteger.valueOf(123)
            val bi2: BigInteger = BigInteger("123")
            val bi3: BigInteger = i.toBigInteger()
            val bi4: BigInteger = l.toBigInteger()
        }
        ```

        `BigDecimal` and `BigInteger` also support basic mathematical operators:

        ```kotlin
        import java.math.BigDecimal
        import java.math.BigInteger

        fun main() {
            val bd1 = BigDecimal("1.2")
            val bd2 = BigDecimal("3.4")
            println(bd1 + bd2) // 4.6
            println(bd1 - bd2) // -2.2
            println(bd1 * bd2) // 4.08
            println(bd1 / bd2) // 0.4

            val bi1 = BigInteger("12")
            val bi2 = BigInteger("34")
            println(bi1 + bi2) // 46
            println(bi1 - bi2) // -22
            println(bi1 * bi2) // 408
            println(bi1 / bi2) // 0
        }
        ```

        On platforms other than Kotlin/JVM, external libraries are needed to represent numbers with unlimited size and precision.
    - type: "text"
      stepId: "lesson-04_basic_values-operations-on-bits-text"
      repeatable: false
      text: |-
        Kotlin also supports operations on bits using the following methods, which can be called using the infix notation (so, between two values):
        * `and` keeps only bits that have `1` in the same binary positions in both numbers.
        * `or` keeps only bits that have `1` in the same binary positions in one or both numbers.
        * `xor` keeps only bits that have exactly one `1` in the same binary positions in both numbers.
        * `shl` shifts the left value left by the right number of bits.
        * `shr` shifts the left value right by the right number of bits, filling the leftmost bits with copies of the sign bit.
        * `ushr` shifts the left value right by the right number of bits, filling the leftmost bits with zeros.

        ```kotlin
        fun main() {
            println(0b0101 and 0b0001) // 1, that is 0b0001
            println(0b0101 or 0b0001)  // 5, that is 0b0101
            println(0b0101 xor 0b0001) // 4, that is 0b0100
            println(0b0101 shl 1) // 10, that is 0b1010
            println(0b0101 shr 1) // 2,  that is 0b0010
            println(0b0101 ushr 1) // 2,  that is 0b0010
        }
        ```
    - type: "text"
      stepId: "lesson-04_basic_values-operations-on-numbers-text"
      repeatable: false
      text: "Numbers in Kotlin support the basic mathematical operations:\n* addition\
        \ (`+`),\n* subtraction (`-`),\n* multiplication (`*`),\n* division (`/`).\n\
        \n```kotlin\nfun main() {\n    val i1 = 12\n    val i2 = 34\n    println(i1\
        \ + i2) // 46\n    println(i1 - i2) // -22\n    println(i1 * i2) // 408\n\
        \    println(i1 / i2) // 0\n\n    val d1 = 1.4\n    val d2 = 2.5\n    println(d1\
        \ + d2) // 3.9\n    println(d1 - d2) // -1.1\n    println(d1 * d2) // 3.5\n\
        \    println(d1 / d2) // 0.5599999999999999\n}\n```\n\n> Notice, that the\
        \ correct result of `1.4 / 2.5` should be `0.56`, not `0.5599999999999999`.\
        \ This problem will be addressed soon. \n\nBeware that when we divide an `Int`\
        \ by an `Int`, the result is also `Int`, so the decimal part is lost.\n\n\
        ```kotlin\nfun main() {\n    println(5 / 2) // 2, not 2.5\n}\n```\n\nThe solution\
        \ is first to convert an integer into a floating-point representation and\
        \ then divide it.\n\n```kotlin\nfun main() {\n    println(5.toDouble() / 2)\
        \ // 2.5\n}\n```\n\nThere is also a remainder operator `%`:\n\n```kotlin\n\
        fun main() {\n    println(1 % 3) // 1\n    println(2 % 3) // 2\n    println(3\
        \ % 3) // 0\n    println(4 % 3) // 1\n    println(5 % 3) // 2\n    println(6\
        \ % 3) // 0\n    println(7 % 3) // 1\n    println(0 % 3) // 0\n    println(-1\
        \ % 3) // -1\n    println(-2 % 3) // -2\n    println(-3 % 3) // 0\n}\n```\n\
        \nKotlin also supports operations that modify a read-write variable `var`:\n\
        * `+=`, where `a += b` is the equivalent of `a = a + b`,\n* `-=`, where `a\
        \ -= b` is the equivalent of `a = a - b`,\n* `*=`, where `a *= b` is the equivalent\
        \ of `a = a * b`,\n* `/=`, where `a /= b` is the equivalent of `a = a / b`,\n\
        * `%=`, where `a %= b` is the equivalent of `a = a % b`,\n* post-incrementation\
        \ and pre-incrementation `++`, which increment variables value by `1`,\n*\
        \ post-decrementation and pre-decrementation `--`, which decrement variables\
        \ value by `1`.\n\n```kotlin\nfun main() {\n    var i = 1\n    println(i)\
        \ // 1\n    i += 10\n    println(i) // 11\n    i -= 5\n    println(i) // 6\n\
        \    i *= 3\n    println(i) // 18\n    i /= 2\n    println(i) // 9\n    i\
        \ %= 4\n    println(i) // 1\n\n    // Post-incrementation\n    // increments\
        \ value and returns the previous value\n    println(i++) // 1\n    println(i)\
        \ // 2\n\n    // Pre-incrementation\n    // increments value and returns the\
        \ new value\n    println(++i) // 3\n    println(i) // 3\n\n    // Post-decrementation\n\
        \    // decrements value and returns the previous value\n    println(i--)\
        \ // 3\n    println(i) // 2\n\n    // Pre-decrementation\n    // decrements\
        \ value and returns the new value\n    println(--i) // 1\n    println(i) //\
        \ 1\n}\n```"
    - type: "text"
      stepId: "lesson-04_basic_values-`number`-and-conversion-functions-text"
      repeatable: false
      text: |-
        All basic types that represent numbers are a subtype of the `Number` type.

        ```kotlin
        fun main() {
            val i: Int = 123
            val b: Byte = 123
            val l: Long = 123L

            val n1: Number = i
            val n2: Number = b
            val n3: Number = l
        }
        ```

        The `Number` type specifies transformation functions: from the current number to any other basic type representing a number.

        ```kotlin
        abstract class Number {
            abstract fun toDouble(): Double
            abstract fun toFloat(): Float
            abstract fun toLong(): Long
            abstract fun toInt(): Int
            abstract fun toChar(): Char
            abstract fun toShort(): Short
            abstract fun toByte(): Byte
        }
        ```

        This means that for each basic number you can transform it into a different basic number using the `to{new type}` function. Such functions are known as *conversion functions*.

        ```kotlin
        fun main() {
            val b: Byte = 123
            val l: Long = b.toLong()
            val f: Float = l.toFloat()
            val i: Int = f.toInt()
            val d: Double = i.toDouble()
            println(d) // 123.0
        }
        ```
    - type: "text"
      stepId: "lesson-04_basic_values-other-numeral-systems-text"
      repeatable: false
      text: |-
        To define a number using the hexadecimal numeral system, start it with `0x`. To define a number using the binary numeral system, start it with `0b`. The octal numeral system is not supported.

        ```kotlin
        fun main() {
            val hexBytes = 0xA4_D6_FE_FE
            println(hexBytes) // 2765553406
            val bytes = 0b01010010_01101101_11101000_10010010
            println(bytes) // 1382934674
        }
        ```
    - type: "text"
      stepId: "lesson-04_basic_values-underscores-in-numbers-text"
      repeatable: false
      text: |-
        In number literals, we can use the underscore `_` between digits. This character is ignored, but we sometimes use it to format long numbers for better readability.

        ```kotlin
        fun main() {
            val million = 1_000_000
            println(million) // 1000000
        }
        ```
    - type: "text"
      stepId: "lesson-04_basic_values-numbers-text"
      repeatable: false
      text: |-
        In Kotlin, there is a range of different types that are used to represent numbers. They can be divided into those representing integer numbers (without decimal points) and those representing floating-point numbers (with decimal points). In these groups, the difference is in the number of bits used to represent these numbers, which determines the possible number size and precision.

        To represent integer numbers, we use `Int`, `Long`, `Byte`, and `Short`.

        | Type    | Size (bits) | Min value  | Max value     |
        |---------|-------------|------------|---------------|
        | `Byte`  | 8           | -128       | 127           |
        | `Short` | 16          | -32768     | 32767         |
        | `Int`   | 32          | `-2^{31}`$ | `2^{31} - 1`$ |
        | `Long`  | 64          | `-2^{63}`$ | `2^{63} - 1`$ |

        To represent floating-point numbers, we use `Float` and `Double`.

        | Type     | Size (bits) | Significant bits | Exponent bits | Decimal digits |
        |----------|-------------|------------------|---------------|----------------|
        | `Float`  | 32          | 24               | 8             | 6-7            |
        | `Double` | 64          | 53               | 11            | 15-16          |

        A plain number without a decimal point is interpreted as an `Int`. A plain number with a decimal point is interpreted as a `Double`.

        ![](05_int_double.png)

        You can create `Long` by using the `L` suffix after the number. `Long` is also used for number literals that are too big for `Int`.

        ![](05_long.png)

        Similarly, you can create a `Float` by ending a number with the `F` or `f` suffix.

        ![](05_float.png)

        There is no suffix to create `Byte` or `Short` types. However, a number explicitly typed as one of these types will create an instance of this type. This also works for `Long`.

        ```kotlin
        fun main() {
            val b: Byte = 123
            val s: Short = 345
            val l: Long = 345
        }
        ```

        This is not a conversion! Kotlin does not support implicit type conversion, so you cannot use `Byte` or `Long` where `Int` is expected.

        ![](05_int_long_error.png)

        If we need to explicitly convert one number to another type, we use explicit conversion functions like `toInt` or `toLong`.

        ```kotlin
        fun main() {
            val b: Byte = 123
            val l: Long = 123L
            val i: Int = 123

            val i1: Int = b.toInt()
            val i2: Int = l.toInt()
            val l1: Long = b.toLong()
            val l2: Long = i.toLong()
        }
        ```
    - type: "text"
      stepId: "lesson-04_basic_values-#-basic-types,-their-literals-and-operations-text"
      repeatable: false
      text: |-
        Every language needs a convenient way to represent basic kinds of values, like numbers or characters. All languages need to have built-in **types** and **literals**. Types are used to represent certain types of values. Some type examples are `Int`, `Boolean`, or `String`. Literals are built-in notations that are used to create instances. Some literal examples are a string literal, which is text in quotation marks, or an integer literal, which is a bare number.

        In this chapter, we’ll learn about the basic Kotlin types and their literals:
        * numbers (`Int`, `Long`, `Double`, `Float`, `Short`, `Byte`),
        * booleans (`Boolean`),
        * characters (`Char`),
        * strings (`String`).

        There is also the array primitive type in Kotlin, which will be covered in the chapter *Collections*.

        In Kotlin, all values are considered objects (there are no primitive types), so they all have methods, and their types can be used as generic type arguments (this will be covered later). Types that represent numbers, booleans, and characters might be optimized by the Kotlin compiler and used as primitives, but this optimization does not affect Kotlin developers, therefore you don’t need to even think about it.

        Let's start discussing the basic types in Kotlin, one by one.
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-#-basic-types,-their-literals-and-operations-q1"
      question: "In Kotlin, which statement about primitives and objects is correct?"
      explanation: "Kotlin has no primitive types at the language level. The compiler\
        \ may optimize numeric/boolean/char types to primitives, but types like Int,\
        \ Boolean, and Char are always used as regular types (e.g., as generic arguments)."
      repeatable: true
      answers:
      - "All values are objects; numeric/boolean/char types may be optimized to platform\
        \ primitives, but this is invisible at the source level."
      - "Kotlin has distinct primitive and reference types like Java, and you must\
        \ choose which to use."
      - "You cannot use Int as a generic type argument because it's a primitive."
      - "Only String and Array are objects; numbers/booleans/chars are primitives."
      correct: "All values are objects; numeric/boolean/char types may be optimized\
        \ to platform primitives, but this is invisible at the source level."
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-#-basic-types,-their-literals-and-operations-q2"
      question: "Which of the following are literals in Kotlin source code?"
      explanation: "Literals are built-in notations that directly create values: integer\
        \ (123), float (1.0f), char ('A'), and string (\"Int\"). Names like Int and\
        \ Boolean are type identifiers, not literals."
      repeatable: true
      answers:
      - "Int"
      - "123"
      - "1.0f"
      - "'A'"
      - "\"Int\""
      - "Boolean"
      correct:
      - "123"
      - "1.0f"
      - "'A'"
      - "\"Int\""
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-numbers-q1"
      question: "Which declarations compile in Kotlin without errors (assume each\
        \ is inside a function)?"
      explanation: "Integer literals adapt to the expected type if the value fits\
        \ (e.g., Long, Short). 1.0 is Double by default; Float requires F/f. There\
        \ are no implicit conversions between numeric types (e.g., Long → Int, Float\
        \ → Double)."
      repeatable: true
      answers:
      - "val l: Long = 1"
      - "val f: Float = 1.0"
      - "val d: Double = 1F"
      - "val s: Short = 1000"
      - "val i: Int = 1L"
      - "val f2: Float = 1F"
      correct:
      - "val l: Long = 1"
      - "val s: Short = 1000"
      - "val f2: Float = 1F"
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-numbers-q2"
      question: "In Kotlin, what is the inferred type of the literal 3000000000 (no\
        \ suffix, no decimal point)?"
      explanation: "Plain integer literals are Int unless they don't fit; 3000000000\
        \ exceeds Int's max, so the literal is Long."
      repeatable: true
      answers:
      - "Int"
      - "Long"
      - "Double"
      - "Short"
      correct: "Long"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-underscores-in-numbers-q1"
      question: "Which of the following Kotlin numeric literals are valid?"
      explanation: "Underscores may appear between digits (including in binary/hex\
        \ and the fractional part) but not at the start/end, not directly next to\
        \ a decimal point, and not immediately before a type suffix."
      repeatable: true
      answers:
      - "1_000_000"
      - "0b1101_0010"
      - "3.14_15"
      - "123_.456"
      - "_123"
      correct:
      - "1_000_000"
      - "0b1101_0010"
      - "3.14_15"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-other-numeral-systems-q1"
      question: "Which Kotlin integer literals are valid and will compile?"
      explanation: "Kotlin supports hexadecimal (0x...) and binary (0b...) integer\
        \ literals; underscores are allowed between digits. Octal is not supported\
        \ (no 0o...), hex digits must be 0–9/A–F, binary digits must be 0/1, and a\
        \ prefix must be followed by at least one valid digit."
      repeatable: true
      answers:
      - "val a = 0xA4_D6_FE_FE"
      - "val b = 0b01010010_0110"
      - "val c = 0o77"
      - "val d = 0xFACE_B00K"
      - "val e = 0b1021"
      - "val f = 0x"
      correct:
      - "val a = 0xA4_D6_FE_FE"
      - "val b = 0b01010010_0110"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-`number`-and-conversion-functions-q1"
      question: "Which statements about Kotlin's Number and its conversion functions\
        \ are correct?"
      explanation: "All basic numeric types are subtypes of Number; Number declares\
        \ to{Type}() functions (including toChar()); Kotlin does not perform implicit\
        \ numeric widening, so explicit conversion is required."
      repeatable: false
      answers:
      - "Byte, Short, Int, Long, Float, and Double are subtypes of Number."
      - "You can call toInt(), toLong(), toFloat(), toDouble(), toShort(), toByte(),\
        \ and toChar() on any Number."
      - "Kotlin performs implicit widening conversions between numeric types in assignments."
      - "A Number value must be explicitly converted to a specific numeric type before\
        \ assigning to that type."
      correct:
      - "Byte, Short, Int, Long, Float, and Double are subtypes of Number."
      - "You can call toInt(), toLong(), toFloat(), toDouble(), toShort(), toByte(),\
        \ and toChar() on any Number."
      - "A Number value must be explicitly converted to a specific numeric type before\
        \ assigning to that type."
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-`number`-and-conversion-functions-q2"
      question: "Which function is NOT specified by Kotlin's abstract class Number?"
      explanation: "Number declares toDouble(), toFloat(), toLong(), toInt(), toShort(),\
        \ toByte(), and toChar(). Unsigned conversions like toUInt() are not part\
        \ of Number."
      repeatable: true
      answers:
      - "toChar()"
      - "toUInt()"
      - "toLong()"
      - "toDouble()"
      correct: "toUInt()"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-operations-on-numbers-q1"
      question: "In Kotlin, which of the following print exactly 2?"
      explanation: "When both operands are Int, division is integer division. The\
        \ remainder operator returns the remainder with the same sign as the dividend.\
        \ Division with a Double produces a Double."
      repeatable: true
      answers:
      - "println(5 / 2)"
      - "println(5 / 2.0)"
      - "println(5 % 3)"
      - "println(-1 % 3)"
      - "println(7 / 3 + 1 % 3)"
      correct:
      - "println(5 / 2)"
      - "println(5 % 3)"
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-operations-on-numbers-q2"
      question: |-
        What does this program print?

        ```kotlin
        fun main() {
            var a = 5
            val b = 2
            println(a / b)
            println(a.toDouble() / b)
            a += b
            println(a)
            a /= b
            println(a)
        }
        ```
      explanation: "a / b is Int division (2). Converting a to Double yields 2.5.\
        \ After a += b, a is 7. Then a /= b performs Int division: 7 / 2 = 3."
      repeatable: false
      answers:
      - |-
        2
        2.5
        7
        3
      - |-
        2
        2.5
        7
        3.5
      - |-
        2.5
        2.5
        7
        3
      - |-
        2
        2.5
        5
        2
      correct: |-
        2
        2.5
        7
        3
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-operations-on-bits-q1"
      question: |-
        What does this program print?

        ```kotlin
        fun main() {
            val x = -0b0100
            println(x shr 1)
            println(x ushr 1)
        }
        ```
      explanation: "`shr` is an arithmetic right shift (sign bit is copied), so -4\
        \ shr 1 = -2. `ushr` is a logical right shift (zeros filled), so -4 ushr 1\
        \ = 0x7FFFFFFE = 2147483646."
      repeatable: true
      answers:
      - "First: -2; Second: 2147483646"
      - "First: -2; Second: -2"
      - "First: -2; Second: 2"
      - "First: -1; Second: 2147483647"
      correct: "First: -2; Second: 2147483646"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-operations-on-bits-q2"
      question: "Which Kotlin expressions evaluate to the Int value 2?"
      explanation: |-
        - `0b0101 shr 1` = 0b0010 = 2
        - `0b1000 ushr 2` = 0b0010 = 2
        - `0b0110 and 0b0011` = 0b0010 = 2
        - `0b0101 and 0b0011` = 0b0001 = 1
        - `0b0011 shl 0` = 0b0011 = 3
      repeatable: false
      answers:
      - "`0b0101 and 0b0011`"
      - "`0b0101 shr 1`"
      - "`0b1000 ushr 2`"
      - "`0b0110 and 0b0011`"
      - "`0b0011 shl 0`"
      correct:
      - "`0b0101 shr 1`"
      - "`0b1000 ushr 2`"
      - "`0b0110 and 0b0011`"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-`bigdecimal`-and-`biginteger`-q1"
      question: "On Kotlin/JVM, which snippets print exactly \"0.3\"?"
      explanation: "Using String ctor, BigDecimal.valueOf, or Double.toBigDecimal()\
        \ preserves the decimal 0.1 exactly. Using Double arithmetic or BigDecimal(Double)\
        \ suffers from binary floating-point artifacts."
      repeatable: true
      answers:
      - "println(BigDecimal(\"0.1\") + BigDecimal(\"0.2\"))"
      - "println(0.1.toBigDecimal() + 0.2.toBigDecimal())"
      - "println(BigDecimal.valueOf(0.1) + BigDecimal.valueOf(0.2))"
      - "println(BigDecimal(0.1) + BigDecimal(0.2))"
      - "println(0.1 + 0.2)"
      correct:
      - "println(BigDecimal(\"0.1\") + BigDecimal(\"0.2\"))"
      - "println(0.1.toBigDecimal() + 0.2.toBigDecimal())"
      - "println(BigDecimal.valueOf(0.1) + BigDecimal.valueOf(0.2))"
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-`bigdecimal`-and-`biginteger`-q2"
      question: |-
        What does this print on Kotlin/JVM?

        ```kotlin
        import java.math.BigInteger

        fun main() {
            println(BigInteger("12") / BigInteger("34"))
        }
        ```
      explanation: "BigInteger division is integer division; the fractional part is\
        \ discarded, so 12/34 yields 0."
      repeatable: false
      answers:
      - "0"
      - "0.3529..."
      - "0.4"
      - "ArithmeticException"
      - "1"
      correct: "0"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values- -q1"
      question: "Which of the following Kotlin declarations compile successfully?\
        \ Choose all that apply."
      explanation: "A Boolean can only be `true`/`false` or the result of a comparison\
        \ (e.g., `==`, `<`). Assigning an `Int` or a `String` value to a `Boolean`\
        \ is a type error."
      repeatable: false
      answers:
      - "val b1: Boolean = true"
      - "val b2: Boolean = 1"
      - "val b3: Boolean = 2 == 2"
      - "val b4: Boolean = 5 < 3"
      - "val b5: Boolean = \"false\""
      correct:
      - "val b1: Boolean = true"
      - "val b3: Boolean = 2 == 2"
      - "val b4: Boolean = 5 < 3"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-equality-q1"
      question: |-
        Given:

        ```kotlin
        class Point(val x: Int)

        val p1 = Point(1)
        val p2 = Point(2)
        ```

        Which expressions compile successfully?
      explanation: "`==` and `!=` are available for all types (they rely on structural\
        \ equality). Relational operators (`>`, `<`, `>=`, `<=`) require the type\
        \ to implement `Comparable`, which `Point` does not."
      repeatable: true
      answers:
      - "p1 == p2"
      - "p1 != p2"
      - "p1 > p2"
      - "p1 <= p2"
      correct:
      - "p1 == p2"
      - "p1 != p2"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-equality-q2"
      question: "Which of the following String comparisons evaluate to true in Kotlin?"
      explanation: |-
        Strings are `Comparable` and use lexicographic (Unicode) ordering: prefix rules and character codes apply.
        - "abc" < "abd" (true, 'c' < 'd')
        - "abc" > "ab" (true, longer after equal prefix)
        - "kotlin" >= "kotlin" (true, equality)
        - "Kotlin" < "Java" (false, 'K' > 'J')
        - "a" <= "A" (false, 'a' > 'A')
      repeatable: false
      answers:
      - "\"abc\" < \"abd\""
      - "\"abc\" > \"ab\""
      - "\"kotlin\" >= \"kotlin\""
      - "\"Kotlin\" < \"Java\""
      - "\"a\" <= \"A\""
      correct:
      - "\"abc\" < \"abd\""
      - "\"abc\" > \"ab\""
      - "\"kotlin\" >= \"kotlin\""
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-boolean-operations-q1"
      question: "Which of the following Kotlin declarations compile successfully?"
      explanation: "Logical operators (&&, ||, !) work only with Boolean operands.\
        \ Kotlin has no truthy/falsy auto-conversions from Int, String, etc."
      repeatable: true
      answers:
      - "val a = (3 > 1) && (2 == 2)"
      - "val b = \"kotlin\".isNotEmpty() || false"
      - "val c = 1 && (2 == 2)"
      - "val d = !0"
      - "val e = !(5 != 5)"
      correct:
      - "val a = (3 > 1) && (2 == 2)"
      - "val b = \"kotlin\".isNotEmpty() || false"
      - "val e = !(5 != 5)"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-characters-q1"
      question: "Which of the following Kotlin expressions compile and evaluate to\
        \ the integer 65?"
      explanation: "`'A'.code` is 65 because 'A' has Unicode 65. `\\u0041` is 'A',\
        \ so its `.code` is also 65. `65.toChar()` yields 'A', whose `.code` is 65.\
        \ A String (`\"A\"`) has no `.code`, and `'65'` is not a valid `Char` literal."
      repeatable: true
      answers:
      - "'A'.code"
      - "'\\u0041'.code"
      - "65.toChar().code"
      - "\"A\".code"
      - "'65'.code"
      correct:
      - "'A'.code"
      - "'\\u0041'.code"
      - "65.toChar().code"
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-characters-q2"
      question: "Which literal is the correct Kotlin Char representing the pound sign\
        \ using a Unicode escape?"
      explanation: "Kotlin `Char` literals use single quotes and Unicode escapes with\
        \ `\\u` followed by 4 hex digits: `'\\u00A3'`."
      repeatable: false
      answers:
      - "'\\u00A3'"
      - "\"\\u00A3\""
      - "'U+00A3'"
      - "'\\x00A3'"
      correct: "'\\u00A3'"
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-strings-q1"
      question: |-
        What does this program print?

        ```kotlin
        fun main() {
            val s = """\u0041 ${'\u0042'} ${"\u0043"}"""
            println(s)
        }
        ```
      explanation: "In a raw (triple-quoted) string, backslash escapes are not processed,\
        \ so \\u0041 stays literal. Inside `${'\\u0042'}` the char literal becomes\
        \ B, and inside `${\"\\u0043\"}` the regular string escape becomes C."
      repeatable: true
      answers:
      - "\\u0041 B C"
      - "A B C"
      - "\\u0041 \\u0042 \\u0043"
      - "ABC"
      correct: "\\u0041 B C"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-strings-q2"
      question: "Select all println calls that print exactly one line: ABC\\nDEF"
      explanation: "Single-line literal with backslash-n requires either escaping\
        \ the backslash in a regular string (\"\\\\n\"), using a raw string where\
        \ \\n is not processed, or injecting \"\\\\n\" via a template. Using \\n as\
        \ an escape (regular string or via ${\"\\n\"}) produces an actual newline."
      repeatable: false
      answers:
      - "println(\"ABC\\\\nDEF\")"
      - "println(\"ABC\\nDEF\")"
      - "println(\"\"\"ABC\\nDEF\"\"\")"
      - "println(\"\"\"ABC${\"\\n\"}DEF\"\"\")"
      - "println(\"ABC${\"\\\\n\"}DEF\")"
      correct:
      - "println(\"ABC\\\\nDEF\")"
      - "println(\"\"\"ABC\\nDEF\"\"\")"
      - "println(\"ABC${\"\\\\n\"}DEF\")"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-summary-q1"
      question: "Which of the following Kotlin declarations compile as written?"
      explanation: |-
        - Char uses single quotes; String uses double quotes.
        - Booleans are `true`/`false`.
        - Integers can be negative and use underscores.
        - Long needs the `L` suffix; Float needs the `F` suffix; a bare decimal literal is `Double`.
      repeatable: true
      answers:
      - "val letter: Char = 'k'"
      - "val word: String = 'h'"
      - "val truth: Boolean = true"
      - "val count: Int = -1_000"
      - "val distance: Long = 1_000L"
      - "val ratio: Float = 3.14"
      correct:
      - "val letter: Char = 'k'"
      - "val truth: Boolean = true"
      - "val count: Int = -1_000"
      - "val distance: Long = 1_000L"
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-summary-q2"
      question: "Which line correctly declares a Float using a literal?"
      explanation: "Float literals use the `F` suffix. A bare decimal is `Double`;\
        \ quotes make a `String`; `L` denotes `Long`."
      repeatable: false
      answers:
      - "val f: Float = 2.5F"
      - "val f: Float = 2.5"
      - "val f: Float = \"2.5F\""
      - "val f: Float = 2.5L"
      correct: "val f: Float = 2.5F"
    - type: "question-multiple-answer"
      stepId: "lesson-04_basic_values-underscores-in-numbers-q2"
      question: "Which of the following Kotlin integer literal declarations compile?"
      explanation: "Underscores are allowed only between digits. They cannot appear\
        \ at the start or end of the literal, or next to a type suffix (`L`). Hex\
        \ (`0x`) and binary (`0b`) literals also allow underscores between digits."
      repeatable: true
      answers:
      - "val a: Int = 1_000_000"
      - "val b: Int = 1000_"
      - "val c: Long = 1234_L"
      - "val d = 0xFF_EC_DE_5E"
      - "val e = 0b1010_1010"
      correct:
      - "val a: Int = 1_000_000"
      - "val d = 0xFF_EC_DE_5E"
      - "val e = 0b1010_1010"
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-other-numeral-systems-q2"
      question: "Which prefix introduces a hexadecimal numeric literal in Kotlin?"
      explanation: "Hexadecimal literals use the 0x prefix; binary uses 0b; octal\
        \ is not supported."
      repeatable: false
      answers:
      - "0h"
      - "0b"
      - "0x"
      - "0o"
      correct: "0x"
    - type: "question-single-answer"
      stepId: "lesson-04_basic_values-boolean-operations-q2"
      question: |-
        What does the following Kotlin program print?

        ```kotlin
        fun main() {
            val a = true
            val b = false
            val c = true
            println(!(a && b) || (b || !c) && a)
        }
        ```
      explanation: "a && b = false; !(a && b) = true. c = true so !c = false; b ||\
        \ !c = false; (b || !c) && a = false; finally true || false = true."
      repeatable: false
      answers:
      - "true"
      - "false"
      - "Compilation error"
      - "Throws at runtime"
      correct: "true"
  - lessonId: "lesson-conditional-statements"
    name: "Conditional statements"
    steps:
    - type: "text"
      stepId: "lesson-05_conditional_statements-summary-text"
      repeatable: false
      text: "As you can see, Kotlin has introduced many powerful features to conditional\
        \ statements. The if-condition and when-condition can be used as expressions.\
        \ The when-statement is a more powerful alternative to if-else-if or switch-case.\
        \ Type checks with smart-casting are supported. All these features make operating\
        \ on nullable values both safe and pleasant, which makes the `null` value\
        \ our friend, not an enemy. Now, let's see what Kotlin has changed in functions."
    - type: "text"
      stepId: "lesson-05_conditional_statements-while-and-do-while-statements-text"
      repeatable: false
      text: |-
        The last important control structures we need to mention are while and do-while statements. Both look and work exactly the same as in Java, C++, and many other languages.

        ```kotlin
        fun main() {
            var i = 1
            // while-statement
            while (i < 10) {
                print(i)
                i *= 2
            }
            // 1248

            var j = 1
            // do-while statement
            do {
                print(j)
                j *= 2
            } while (j < 10)
            // 1248
        }
        ```

        I hope they don’t need any more explanation. When-statements and do-while-statements cannot be used as expressions. I will only add that both while and do-while statements are rarely used in Kotlin. Instead, we use collection or sequence processing functions, which will be covered in the *Functional Kotlin* book. For instance, the above code can be replaced with the following:

        ```kotlin
        fun main() {
            generateSequence(1) { it * 2 }
                .takeWhile { it < 10 }
                .forEach(::print)
            // 1248
        }
        ```
    - type: "text"
      stepId: "lesson-05_conditional_statements-smart-casting-text"
      repeatable: false
      text: "Kotlin has a powerful feature called smart-casting, which allows automatic\
        \ type casting when the compiler can be sure that a variable is of a certain\
        \ type. Take a look at the following example:\n\n```kotlin\nfun convertToInt(num:\
        \ Number): Int =\n    if (num is Int) num  // the type of num here is Int\n\
        \    else num.toInt()\n```\n\nThe `convertToInt` function converts an argument\
        \ of type `Number` to `Int` in the following way: if the argument is already\
        \ of type `Int`, it is just returned; otherwise, it is converted using the\
        \ `toInt` method. Notice that for this code to compile, the `num` inside the\
        \ first body needs to be of type `Int`. In most languages, it needs to be\
        \ casted, but this happens automatically in Kotlin. Take a look at another\
        \ example:\n\n```kotlin\nfun lengthIfString(a: Any): Int {\n    if (a is String)\
        \ {\n        return a.length // the type of a here is String\n    }\n    return\
        \ 0\n}\n```\n\nInside the if-condition predicate, we checked if `a` is of\
        \ type `String`. The body of this statement will only be executed if the type\
        \ check is successful. This is why `a` is of type `String` inside this body,\
        \ which is why we can check its length. Such a conversion, from `Any` to `String`,\
        \ is done implicitly by the Kotlin compiler. This can happen only when Kotlin\
        \ is sure that no other thread can change our property, so when it is either\
        \ a constant or a local variable. It will not work for non-local `var` properties\
        \ because, in such cases, there is no guarantee that they have not been modified\
        \ between check and usage (e.g., by another thread).\n\n```kotlin\nvar obj:\
        \ Any = \"AAA\"\n\nfun main() {\n    if (obj is String) {\n        // println(obj.length)\
        \ will not compile,\n        // because `obj` can be modified by some\n  \
        \      // other thread, so Kotlin cannot be sure,\n        // that at this\
        \ point, is it still of type String\n    }\n}\n```\n\nSmart-casting is often\
        \ used together with when-statements. When they are used together, they are\
        \ sometimes referred to as \"Kotlin type-safe pattern matching\" because they\
        \ can nicely cover the different possible types a value can be of. More examples\
        \ will be presented when we discuss the sealed modifier.\n\n```kotlin\nfun\
        \ handleResponse(response: Result<T>) {\n    when (response) {\n        is\
        \ Success<*> -> showMessages(response.data) \n        // response smart-casted\
        \ to Success\n        is Failure -> showError(response.throwable)\n      \
        \  // response smart-casted to Failure\n    }\n}\n```"
    - type: "text"
      stepId: "lesson-05_conditional_statements-explicit-casting-text"
      repeatable: false
      text: |-
        You can always use a value whose type is `Int` as a `Number` because every `Int` is a `Number`. This process is known as *up-casting* because we change the value type from lower (more specific) to higher (less specific).

        ```kotlin
        fun main() {
            val i: Int = 123
            val l: Long = 123L
            val d: Double = 3.14

            var number: Number = i // up-casting from Int to Number
            number = l // up-casting from Long to Number
            number = d // up-casting from Double to Number
        }
        ```

        We can implicitly cast from a lower type to a higher one, but not the other way around. Every `Int` is a `Number`, but not every `Number` is an `Int` because there are more subtypes of `Number`, including `Double` or `Long`. This is why we cannot use `Number` where `Int` is expected. However, sometimes we have a situation where we are certain that a value is of a specified type, even though its supertype is used. Explicitly changing from a higher type to a lower type is called *down-casting* and requires the `as` operator in Kotlin.

        ```kotlin
        var i: Number = 123

        fun main() {
            val j = (i as Int) + 10
            println(j) // 133
        }
        ```

        In general, we avoid using `as` when not necessary because we consider it dangerous. Consider the above example. What if someone changes `123` to `3.14`? Both values are of type `Number`, so the code will compile without any problems or warnings. But `3.14` is `Double` not `Int`, and casting is not possible; therefore, the code above will break with a `ClassCastException` exception.

        ```kotlin
        var i: Number = 3.14

        fun main() {
            val j = (i as Int) + 10 // RUNTIME ERROR!
            println(j)
        }
        ```

        There are two ways to deal with this. The first is to use one of many Kotlin alternatives to cast our value safely. One example is using smart-casting, which will be described in the next section. Another example is a conversion function, like the `toInt` method, which transforms `Number` to `Int` (and possibly loses the decimal part).

        ```kotlin
        var i: Number = 3.14

        fun main() {
            val j = i.toInt() + 10
            println(j) // 13
        }
        ```

        The second option is the `as?` operator, which, instead of throwing an exception, returns `null` when casting is not possible. We will discuss handling nullable values later.

        ```kotlin
        var n: Number = 123

        fun main() {
            val i: Int? = n as? Int
            println(i) // 123
            val d: Double? = n as? Double
            println(d) // null
        }
        ```

        In Kotlin, we consider `as?` a safer option than `as`, but using both these operators too often is regarded as a code smell. Let's describe smart-casting, which is their popular alternative.
    - type: "text"
      stepId: "lesson-05_conditional_statements-is-check-text"
      repeatable: false
      text: |-
        Since we have already mentioned the `is` operator, let's discuss it in a bit more depth. It checks if a value is of a certain type. We know already that `123` is of type `Int`, and `"ABC"` is of type `String`. Certainly, `123` is not of type `String`, and `"ABC"` is not of type `Int`. We can confirm this using the `is` check.

        ```kotlin
        fun main() {
            println(123 is Int) // true
            println("ABC" is String) // true
            println(123 is String) // false
            println("ABC" is Int) // false
        }
        ```

        Notice that `123` is an `Int`, but it is also a `Number`; the `is` check returns `true` for both these types.

        ```kotlin
        fun main() {
            println(123 is Int) // true
            println(123 is Number) // true
            println(3.14 is Double) // true
            println(3.14 is Number) // true

            println(123 is Double) // false
            println(3.14 is Int) // false
        }
        ```

        When we want to check if a value **is not** of a certain type, we can use `!is`; this is an equivalent of is-check, but its result value is negated.

        ```kotlin
        fun main() {
            println(123 !is Int) // false
            println("ABC" !is String) // false
            println(123 !is String) // true
            println("ABC" !is Int) // true
        }
        ```
    - type: "text"
      stepId: "lesson-05_conditional_statements-when-statement-with-a-value-text"
      repeatable: false
      text: |-
        There is also another form of the when-statement. If we add a value in brackets after the `when` keyword, then our when-statement becomes an alternative to the switch-case. However, it is a much more powerful alternative because it can not only compare values by equality, but it can also check if an object is of some type (using `is`), or if an object contains this value (using `in`). Each block can have multiple values we compare against, separated with a comma.

        ```kotlin
        private val magicNumbers = listOf(7, 13)

        fun describe(a: Any?) {
            when (a) {
                null -> println("Nothing")
                1, 2, 3 -> println("Small number")
                in magicNumbers -> println("Magic number")
                in 4..100 -> println("Big number")
                is String -> println("This is just $a")
                is Long, is Int -> println("This is Int or Long")
                else -> println("No idea, really")
            }
        }

        fun main() {
            describe(null) // Nothing
            describe(1) // Small number
            describe(3) // Small number
            describe(7) // Magic number
            describe(9) // Big number,
            // because 9 is in range from 4 to 100
            describe("AAA") // This is just AAA
            describe(1L) // This is Int or Long
            describe(-1) // This is Int or Long
            describe(1.0) // No idea, really,
            // because 1.0 is Double
        }
        ```

        The when-statement with a value can also be used as an expression because it can produce a value:

        ```kotlin
        private val magicNumbers = listOf(7, 13)

        fun describe(a: Any?): String = when (a) {
            null -> "Nothing"
            1, 2, 3 -> "Small number"
            in magicNumbers -> "Magic number"
            in 4..100 -> "Big number"
            is String -> "This is just $a"
            is Long, is Int -> "This is Int or Long"
            else -> "No idea, really"
        }

        fun main() {
            println(describe(null)) // Nothing
            println(describe(1)) // Small number
            println(describe(3)) // Small number
            println(describe(7)) // Magic number
            println(describe(9)) // Big number,
            // because 9 is in range from 4 to 100
            println(describe("AAA")) // This is just AAA
            println(describe(1L)) // This is Int or Long
            println(describe(-1)) // This is Int or Long
            println(describe(1.0)) // No idea, really,
            // because 1.0 is Double
        }
        ```

        Note that if we use a when-condition as an expression, its conditions must be exhaustive: it should cover all possible branch conditions or provide an else branch, as in the example above. If not all conditions are covered, a compiler error is shown.

        > Kotlin does not support switch-case statements because we use the when-statement instead.

        Inside the “when” parentheses, where we specify a value, we can also define a variable, and its value will be used in each condition.

        ```kotlin
        fun showUsers() =
            when (val response = requestUsers()) {
                is Success -> showUsers(response.body)
                is HttpError -> showException(response.exception)
            }
        ```
    - type: "text"
      stepId: "lesson-05_conditional_statements-when-statement-text"
      repeatable: false
      text: |-
        The when-statement is an alternative to if-else-if. In every branch, we specify a predicate and the body that should be executed if this predicate returns `true` (and previous predicates did not). So, it works just like if-else-if but should be preferred because its syntax is better suited for multiple conditions.

        ```kotlin
        fun main() {
            println("Is it going to rain?")
            val probability = 70
            when {
                probability < 40 -> {
                    println("Na-ha")
                }
                probability <= 80 -> {
                    println("Likely")
                }
                probability < 100 -> {
                    println("Yes")
                }
                else -> {
                    println("Holly Crab")
                }
            }
        }
        ```

        Like in an if-statement, braces are needed only for bodies with more than one statement.

        ```kotlin
        fun main() {
            println("Is it going to rain?")
            val probability = 70
            when {
                probability < 40 -> println("Na-ha")
                probability <= 80 -> println("Likely")
                probability < 100 -> println("Yes")
                else -> println("Holly Crab")
            }
        }
        ```

        The when-statement can also be used as an expression because it can return a value. The result is the last expression of the chosen branch, therefore the following example will print "Likely".

        ```kotlin
        fun main() {
            println("Is it going to rain?")
            val probability = 70
            val text = when {
                probability < 40 -> "Na-ha"
                probability <= 80 -> "Likely"
                probability < 100 -> "Yes"
                else -> "Holly Crab"
            }
            println(text)
        }
        ```

        The when-statement is often used as an expression body:

        ```kotlin
        private fun getEmailErrorId(email: String) = when {
            email.isEmpty() -> R.string.error_field_required
            emailInvalid(email) -> R.string.error_invalid_email
            else -> null
        }
        ```
    - type: "text"
      stepId: "lesson-05_conditional_statements-if-statement-text"
      repeatable: false
      text: |-
        Let's start with the aforementioned if-statement. It executes its body when its condition is satisfied (returns `true`). We can additionally add the `else` block, which is executed when the condition is not satisfied (returns `false`).

        ```kotlin
        fun main() {
            val i = 1 // or 5
            if (i < 3) { // i < 3 is used as a condition
                // will be executed when condition returns true
                println("Smaller")
            } else {
                // will be executed when condition returns false
                println("Bigger")
            }
            // Prints Smaller if i == 1, or Bigger if i == 5
        }
        ```

        One of Kotlin’s superpowers is that an if-else statement can be used as an expression, therefore it produces a value.

        ```kotlin
        val value = if (condition) {
            // body 1
        } else {
            // body 2
        }
        ```

        What value is returned? For each body block, it is the result of the last statement (or `Unit` for an empty body or a statement that is not an expression).

        ```kotlin
        fun main() {
            var isOne = true
            val number1: Int = if (isOne) 1 else 0
            println(number1) // 1
            isOne = false
            val number2: Int = if (isOne) 1 else 0
            println(number2) // 0

            val superuser = true
            val hasAccess: Boolean = if (superuser) {
                println("Good morning, sir Admin")
                true
            } else {
                false
            }
            println(hasAccess) // true
        }
        ```

        When a body has only one statement, its result is the result of our if-else expression. In such a case, we don’t need brackets.

        ```kotlin
        val r: Int = if (one) 1 else 0
        // a more readable alternative to
        val r: Int = if (one) {
            1
        } else {
            0
        }
        ```

        This way of using an if-statement is a Kotlin alternative to the Java or JavaScript ternary operator.

        ```
        // Java
        final String name = user == null ? "" : user.name
        // JavaScript
        const name = user === null ? "" : user.name
        ```

        ```kotlin
        // Kotlin
        val name = if (user == null) "" else user.name
        ```

        It should be said that if-else is longer than the ternary operator syntax. I believe this is the main reason why some developers want ternary operator syntax introduced in Kotlin. However, I am against this as if-else is a good replacement that is more readable and can be better formatted. Moreover, we have some additional Kotlin tools, which are also replacements for some ternary-operator use cases: the Elvis operator, extensions on nullable types (like `orEmpty`), or safe-calls. All these will be explained in detail in the chapter *Nullability*.

        ```
        // Java
        String name = user == null ? "" : user.name

        // Kotlin
        val name = user?.name ?: ""
        // or
        val name = user?.name.orEmpty()
        ```

        Notice that if you use the so-called if-else-if statement, it is just multiple connected if-else statements.

        ```kotlin
        fun main() {
            println("Is it going to rain?")
            val probability = 70
            if (probability < 40) {
                println("Na-ha")
            } else if (probability <= 80) {
                println("Likely")
            } else if (probability < 100) {
                println("Yes")
            } else {
                println("Holly Crab")
            }
        }
        ```

        There is actually no such thing as an if-else-if expression: it is just one if-else expression inside another, as can be seen in strange cases where a method is executed on a whole if-else-if expression. Just take a look at the following puzzle and try to predict the result of this code.

        ```kotlin
        // Function we can execute on any object, to print it
        // 10.print() prints 10
        // "ABC".print() prints ABC
        fun Any?.print() {
            print(this)
        }

        fun printNumberSign(num: Int) {
            if (num < 0) {
                "negative"
            } else if (num > 0) {
                "positive"
            } else {
                "zero"
            }.print()
        }

        fun main(args: Array<String>) {
            printNumberSign(-2)
            print(",")
            printNumberSign(0)
            print(",")
            printNumberSign(2)
        }
        ```

        The answer is **not** "negative,zero,positive", because there is no such thing as a single if-else-if expression (just two nested if-else expressions). So, the above `printNumberSign` implementation gives the same result as the following implementation.

        ```kotlin
        fun printNumberSign(num: Int) {
            if (num < 0) {
                "negative"
            } else {
                if (num > 0) {
                    "positive"
                } else {
                    "zero"
                }.print()
            }
        }
        ```

        So, when we call `print` on the result, it is called on the result of the second if-else expression only (the one with "positive" and "zero"). This means that the code above will print ",zero,positive". How can we fix this? We might use a bracket, but it is generally suggested that, instead of using if-else-if, we should use a when-statement when there is more than one condition. This can help avoid mistakes like the one in the puzzle above, and it makes code clearer and easier to read.

        ```kotlin
        // Function we can execute on any object, to print it
        // 10.print() prints 10
        // "ABC".print() prints ABC
        fun Any?.print() {
            print(this)
        }

        fun printNumberSign(num: Int) {
            when {
                num < 0 -> "negative"
                num > 0 -> "positive"
                else -> "zero"
            }.print()
        }

        fun main(args: Array<String>) {
            printNumberSign(-2) // negative
            print(",") // ,
            printNumberSign(0) // zero
            print(",") // ,
            printNumberSign(2) // positive
        }
        ```
    - type: "text"
      stepId: "lesson-05_conditional_statements-#-conditional-statements-text"
      repeatable: false
      text: |-
        Most conditional statements, like the if-condition or the while-loop, look the same in Kotlin, Java, C++, JavaScript, and most other modern languages. For instance, the if-statement is indistinguishable in all these languages:

        ```kotlin
        if (predicate) {
            // body
        }
        ```

        However, the if-condition in Kotlin is more powerful and has capabilities that Kotlin's predecessors don’t support. I assume that readers of this book have general experience in programming, so I will concentrate on the differences that Kotlin has introduced compared to other programming languages.
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-#-conditional-statements-q1"
      question: "Which statement about Kotlin's if is correct compared to languages\
        \ like Java or C++?"
      explanation: "In Kotlin, if is an expression and can produce a value. Parentheses\
        \ are required, there is no ternary operator ?:, and else is only required\
        \ when using if as an expression."
      repeatable: true
      answers:
      - "It is an expression that can return a value."
      - "Parentheses around the condition are optional."
      - "Kotlin provides the ternary operator ?:."
      - "An else block is always required, even when used as a statement."
      correct: "It is an expression that can return a value."
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-#-conditional-statements-q2"
      question: "Which snippet correctly assigns a value using Kotlin's if as an expression?"
      explanation: "Only A uses if as an expression with both branches producing a\
        \ value. Kotlin has no ?: ternary operator, and if used as an expression requires\
        \ an else branch."
      repeatable: true
      answers:
      - "val sign = if (n > 0) 1 else -1"
      - "val sign = if (n > 0) { 1 }"
      - "val sign = n > 0 ? 1 : -1"
      - "if (n > 0) val sign = 1 else val sign = -1"
      correct: "val sign = if (n > 0) 1 else -1"
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-if-statement-q1"
      question: |-
        What does the following program print?

        ```kotlin
        fun Any?.print() { print(this) }

        fun printNumberSign(num: Int) {
            if (num < 0) {
                "negative"
            } else if (num > 0) {
                "positive"
            } else {
                "zero"
            }.print()
        }

        fun main() {
            printNumberSign(-2)
            print(",")
            printNumberSign(0)
            print(",")
            printNumberSign(2)
        }
        ```
      explanation: "`.print()` is applied only to the second if-else expression (the\
        \ one with \"positive\"/\"zero\"). For -2, nothing is printed; then a comma;\
        \ then \"zero\"; then a comma; then \"positive\"."
      repeatable: false
      answers:
      - "negative,zero,positive"
      - ",zero,positive"
      - "negative,,positive"
      - "negative,zero,"
      correct: ",zero,positive"
    - type: "question-multiple-answer"
      stepId: "lesson-05_conditional_statements-if-statement-q2"
      question: "Which of the following declarations compile in Kotlin, given `val\
        \ flag = true`?"
      explanation: |-
        - `a` compiles: both branches return Int.
        - `b` fails: branches are Unit vs Int; cannot assign to Int.
        - `c` compiles: Unit and Int have common supertype Any.
        - `d` compiles: empty blocks return Unit.
        - `e` fails: first branch's last statement is `println`, so Unit vs String -> common type Any, not String.
      repeatable: true
      answers:
      - "val a: Int = if (flag) 1 else 0"
      - "val b: Int = if (flag) println(\"A\") else 0"
      - "val c: Any = if (flag) println(\"A\") else 0"
      - "val d: Unit = if (flag) {} else {}"
      - "val e: String = if (flag) { \"X\"; println(\"Y\") } else \"Z\""
      correct:
      - "val a: Int = if (flag) 1 else 0"
      - "val c: Any = if (flag) println(\"A\") else 0"
      - "val d: Unit = if (flag) {} else {}"
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-when-statement-q1"
      question: |-
        What is the inferred return type of the following function?

        ```kotlin
        private fun getEmailErrorId(email: String) = when {
            email.isEmpty() -> R.string.error_field_required
            emailInvalid(email) -> R.string.error_invalid_email
            else -> null
        }
        ```
      explanation: "Two branches return Int and one returns null; the common type\
        \ is Int?. A when used as an expression determines its type from branch results."
      repeatable: true
      answers:
      - "Int"
      - "Int?"
      - "String?"
      - "Unit"
      correct: "Int?"
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-when-statement-q2"
      question: |-
        What does this program print?

        ```kotlin
        fun main() {
            val msg = when {
                true -> { print("b"); "X" }
                else -> { print("c"); "Y" }
            }
            print(msg)
        }
        ```
      explanation: "The first branch runs, prints b, and returns the last expression\
        \ \"X\". Then print(msg) prints X, resulting in bX."
      repeatable: false
      answers:
      - "bX"
      - "Xb"
      - "b"
      - "X"
      - "Compile error"
      correct: "bX"
    - type: "question-multiple-answer"
      stepId: "lesson-05_conditional_statements-when-statement-with-a-value-q1"
      question: "Which of the following when-expressions compile (are exhaustive)\
        \ as written?"
      explanation: "A when used as an expression must be exhaustive. For Boolean,\
        \ true/false cover all cases. For Boolean?, you must also handle null or provide\
        \ else. For wide types like Any/Any?, you need else unless all possibilities\
        \ are covered."
      repeatable: true
      answers:
      - |-
        A)
        ```kotlin
        fun f(a: Boolean) = when (a) {
            true -> "T"
            false -> "F"
        }
        ```
      - |-
        B)
        ```kotlin
        fun f(a: Boolean?) = when (a) {
            true -> "T"
            false -> "F"
        }
        ```
      - |-
        C)
        ```kotlin
        fun f(a: Any) = when (a) {
            is String -> "S"
            is Int -> "I"
            else -> "?"
        }
        ```
      - |-
        D)
        ```kotlin
        fun f(a: Any?) = when (a) {
            null -> "N"
            is String -> "S"
        }
        ```
      correct:
      - |-
        A)
        ```kotlin
        fun f(a: Boolean) = when (a) {
            true -> "T"
            false -> "F"
        }
        ```
      - |-
        C)
        ```kotlin
        fun f(a: Any) = when (a) {
            is String -> "S"
            is Int -> "I"
            else -> "?"
        }
        ```
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-when-statement-with-a-value-q2"
      question: |-
        What does this print for the call categorize(7L)?

        ```kotlin
        val magic = listOf(7, 13)

        fun categorize(a: Any?) = when (a) {
            7 -> "Seven"
            in magic -> "Magic"
            in 1..10 -> "Range"
            is Long -> "Long"
            else -> "Other"
        }
        ```
      explanation: "Equality in when uses equals, so 7L is not equal to Int 7. `in\
        \ magic` fails because List<Int> doesn't contain Long 7L. `in 1..10` checks\
        \ an IntRange and only matches Ints. The first matching branch is `is Long`."
      repeatable: false
      answers:
      - "Seven"
      - "Magic"
      - "Range"
      - "Long"
      - "Other"
      correct: "Long"
    - type: "question-multiple-answer"
      stepId: "lesson-05_conditional_statements-is-check-q1"
      question: "Which Kotlin expressions evaluate to true?"
      explanation: "`Int` and `Double` are subtypes of `Number`, so `0 is Int`, `0\
        \ is Number`, and `3.14 is Number` are true. An `Int` is not a `Double`, and\
        \ `String` is not a `Number`."
      repeatable: true
      answers:
      - "0 is Int"
      - "0 is Number"
      - "0 is Double"
      - "\"0\" is Number"
      - "3.14 is Number"
      correct:
      - "0 is Int"
      - "0 is Number"
      - "3.14 is Number"
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-is-check-q2"
      question: |-
        Given:

        ```kotlin
        val x: Number = 42
        val a = x is Int
        val b = x is Double
        val c = x !is Number
        ```
        Which option is correct?
      explanation: "Runtime type of `x` is `Int`, so `a` is true. `x` is not a `Double`,\
        \ so `b` is false. `x` is a `Number`, so `x !is Number` is false."
      repeatable: false
      answers:
      - "Only a is true"
      - "Only b is true"
      - "a and b are true"
      - "b and c are true"
      - "All are false"
      correct: "Only a is true"
    - type: "question-multiple-answer"
      stepId: "lesson-05_conditional_statements-explicit-casting-q1"
      question: "Which statements about casting Numbers in Kotlin are correct?"
      explanation: |-
        - Up-casting (Int to Number) is implicit.
        - Down-casting with `as` can throw `ClassCastException` at runtime.
        - `as?` returns null on failure (does not throw).
        - `toInt()` converts, truncating the fractional part.
        - `x as Int` compiles but may fail at runtime if `x` isn't an Int.
      repeatable: true
      answers:
      - "Up-casting from Int to Number is implicit."
      - "Down-casting a Number to Int with `as` may throw ClassCastException at runtime."
      - "`as?` throws an exception on failure."
      - "Number.toInt() converts the value, possibly losing the fractional part."
      - "After `val x: Number = 3.14`, `val i = x as Int` is a compilation error."
      correct:
      - "Up-casting from Int to Number is implicit."
      - "Down-casting a Number to Int with `as` may throw ClassCastException at runtime."
      - "Number.toInt() converts the value, possibly losing the fractional part."
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-explicit-casting-q2"
      question: |-
        What does this program print?

        ```kotlin
        fun main() {
            var n: Number = 3.99
            val i = n as? Int ?: n.toInt()
            println(i + 1)
        }
        ```
      explanation: "`n as? Int` returns null because `n` holds a `Double`, so the\
        \ Elvis operator uses `n.toInt()` which is 3; `println(3 + 1)` prints 4."
      repeatable: false
      answers:
      - "4"
      - "5"
      - "ClassCastException at runtime"
      - "Compilation error"
      correct: "4"
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-smart-casting-q1"
      question: |-
        Consider:

        ```kotlin
        fun <T> handle(response: Result<T>) {
            when (response) {
                is Success<*> -> show(response.data)
                is Failure -> log(response.throwable)
            }
        }
        ```
        What is the static type of `response` inside the first `when` branch?
      explanation: "The `is` check narrows `response` to the matched type. Because\
        \ `T` is unknown, Kotlin smart-casts it to `Success<*>` (star-projected),\
        \ not `Success<T>`."
      repeatable: true
      answers:
      - "Success<*>"
      - "Success<T>"
      - "Result<T>"
      - "Any"
      correct: "Success<*>"
    - type: "question-multiple-answer"
      stepId: "lesson-05_conditional_statements-smart-casting-q2"
      question: "Which snippets compile thanks to smart-casting (no explicit casts)?"
      explanation: |-
        - A and E are local (parameter/variable), so they smart-cast after `is String`.
        - C copies the non-local `obj` into a local `val`, which can be smart-cast.
        - B and D use a non-local `var` property directly; Kotlin won’t smart-cast it because it might change between check and use.
      repeatable: true
      answers:
      - |-
        A)
        ```kotlin
        fun f(a: Any) {
            if (a is String) println(a.length)
        }
        ```
      - |-
        B)
        ```kotlin
        var obj: Any = "AAA"
        fun g() {
            if (obj is String) println(obj.length)
        }
        ```
      - |-
        C)
        ```kotlin
        var obj: Any = "AAA"
        fun h() {
            val local = obj
            if (local is String) println(local.length)
        }
        ```
      - |-
        D)
        ```kotlin
        var obj: Any = "AAA"
        fun i() {
            when (obj) {
                is String -> println(obj.length)
            }
        }
        ```
      - |-
        E)
        ```kotlin
        fun j() {
            var x: Any = "A"
            if (x is String) println(x.length)
        }
        ```
      correct:
      - |-
        A)
        ```kotlin
        fun f(a: Any) {
            if (a is String) println(a.length)
        }
        ```
      - |-
        C)
        ```kotlin
        var obj: Any = "AAA"
        fun h() {
            val local = obj
            if (local is String) println(local.length)
        }
        ```
      - |-
        E)
        ```kotlin
        fun j() {
            var x: Any = "A"
            if (x is String) println(x.length)
        }
        ```
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-while-and-do-while-statements-q1"
      question: |-
        What does the following Kotlin program print?

        ```kotlin
        fun main() {
            var i = 0
            while (i < 0) {
                print(i)
                i++
            }
            do {
                print(i)
                i++
            } while (i < 0)
        }
        ```
      explanation: "while checks the condition before the first iteration, so it doesn't\
        \ run. do-while runs the body once before checking, so it prints 0 once."
      repeatable: true
      answers:
      - "'' (prints nothing)"
      - "0"
      - "01"
      - "10"
      correct: "0"
    - type: "question-multiple-answer"
      stepId: "lesson-05_conditional_statements-while-and-do-while-statements-q2"
      question: "Which snippets print exactly `1248`? Choose all that apply."
      explanation: |-
        - generateSequence starting at 1 and doubling yields 1,2,4,8,16,...
        - takeWhile { it < 10 } keeps 1,2,4,8 -> prints 1248.
        - take(4) also takes the first four elements -> 1,2,4,8.
        - The sequenceOf(1) variant has only one element (2) -> prints just 2.
        - Mapping (1..9) doubles to 2,4,6,8 -> missing 1.
        - dropWhile { it < 10 } skips to 16 and continues infinitely.
      repeatable: false
      answers:
      - |-
        ```kotlin
        generateSequence(1) { it * 2 }
            .takeWhile { it < 10 }
            .forEach(::print)
        ```
      - |-
        ```kotlin
        sequenceOf(1)
            .map { it * 2 }
            .takeWhile { it < 10 }
            .forEach(::print)
        ```
      - |-
        ```kotlin
        generateSequence(1) { it * 2 }
            .take(4)
            .forEach(::print)
        ```
      - |-
        ```kotlin
        (1..9)
            .map { it * 2 }
            .takeWhile { it < 10 }
            .forEach(::print)
        ```
      - |-
        ```kotlin
        generateSequence(1) { it * 2 }
            .dropWhile { it < 10 }
            .forEach(::print)
        ```
      correct:
      - |-
        ```kotlin
        generateSequence(1) { it * 2 }
            .takeWhile { it < 10 }
            .forEach(::print)
        ```
      - |-
        ```kotlin
        generateSequence(1) { it * 2 }
            .take(4)
            .forEach(::print)
        ```
    - type: "question-multiple-answer"
      stepId: "lesson-05_conditional_statements-summary-q1"
      question: |-
        Assume the following is in scope:

        ```kotlin
        val x: Any?
        ```
        Which snippets compile as-is?
      explanation: |-
        - When used as an expression (assigned to a val), `when` must be exhaustive. Options B and D are missing an `else` (and don't cover all cases), so they don't compile.
        - Smart casts apply in the checked branch (`x is String -> x.length`).
        - Option A is exhaustive (`else` present); option C's `if` is exhaustive with an `else`.
      repeatable: true
      answers:
      - |-
        ```kotlin
        val len: Int = when (x) {
            is String -> x.length
            null -> 0
            else -> -1
        }
        ```
      - |-
        ```kotlin
        val len = when (x) {
            is String -> x.length
        }
        ```
      - |-
        ```kotlin
        val len = if (x is String) x.length else -1
        ```
      - |-
        ```kotlin
        val len: Int = when {
            x is String -> x.length
        }
        ```
      correct:
      - |-
        ```kotlin
        val len: Int = when (x) {
            is String -> x.length
            null -> 0
            else -> -1
        }
        ```
      - |-
        ```kotlin
        val len = if (x is String) x.length else -1
        ```
    - type: "question-single-answer"
      stepId: "lesson-05_conditional_statements-summary-q2"
      question: |-
        What is the inferred type of `len`?

        ```kotlin
        val s: Any? = ...
        val len = if (s is String) s.length else null
        ```
      explanation: "`if` is an expression; its type is the least common supertype\
        \ of its branches. `s.length` is `Int`, and the other branch is `null`, so\
        \ the result type is `Int?`."
      repeatable: true
      answers:
      - "Int"
      - "Int?"
      - "Any?"
      - "Nothing?"
      correct: "Int?"
  - lessonId: "lesson-functions"
    name: "Functions"
    steps:
    - type: "text"
      stepId: "lesson-06_functions-summary-text"
      repeatable: false
      text: "As you can see, functions in Kotlin have a lot of powerful features.\
        \ Single-expression syntax makes simple functions shorter. Named and default\
        \ arguments help us improve safety and readability. The `Unit` result type\
        \ makes every function call an expression. Vararg parameters allow any number\
        \ of arguments to be used for one parameter position. Infix notation introduces\
        \ a more convenient way to call certain kinds of functions. Trailing commas\
        \ minimize the number of changes on git. All this is for our convenience.\
        \ For now though, let's move on to another topic: using a for-loop."
    - type: "text"
      stepId: "lesson-06_functions-function-formatting-text"
      repeatable: false
      text: |-
        When a function declaration (name, parameters, and result type) is too long to fit in a single line, we split it such that every parameter definition is on a different line, and the beginning and end of the function declaration are also on separate lines.

        ```kotlin
        fun veryLongFunction(
            param1: Param1Type,
            param2: Param2Type,
            param3: Param3Type,
        ): ResultType {
            // body
        }
        ```

        Classes are formatted in the same way:

        ```kotlin
        class VeryLongClass(
            val property1: Type1,
            val property2: Type2,
            val property3: Type3,
        ) : ParentClass(), Interface1, Interface2 {
            // body
        }
        ```

        When a function call is too long, we format it similarly: each argument is on a different line. However, there are exceptions to this rule, such as keeping multiple vararg parameters on the same line.

        ```kotlin
        fun makeUser(
            name: String,
            surname: String,
        ): User = User(
            name = name,
            surname = surname,
        )

        class User(
            val name: String,
            val surname: String,
        )

        fun main() {
            val user = makeUser(
                name = "Norbert",
                surname = "Moskała",
            )

            val characters = listOf(
                "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
                "K", "L", "M", "N", "O", "P", "R", "S", "T", "U",
                "W", "X", "Y", "Z",
            )
        }
        ```

        In this book, the width of my lines is much smaller than in regular projects, so I am forced to break lines much more often than I would like to.

        Notice that when I specify arguments or parameters, I sometimes add a comma at the end. This is a so-called **trailing comma**. Such notation is optional.

        ```kotlin
        fun printName(
            name: String,
            surname: String, // <- trailing comma
        ) {
            println("$name $surname")
        }

        fun main() {
            printName(
                name = "Norbert",
                surname = "Moskała", // <- trailing comma
            )
        }
        ```

        I like using trailing comma notation because it makes it easier to add another element in the future. Without it, adding or removing an element requires not only a new line but also an additional comma after the last element. This leads to meaningless line modifications on Git, which makes it harder to read what has actually changed in our project. Some developers don’t like trailing comma notation, which can sometimes lead to a holy war. Decide in your team if you like it or not, and be consistent in your projects.

        ![Adding a parameter and an argument on git when a trailing comma is used.](trailing_comma_used.png)

        ![Adding a parameter and an argument on git when a trailing comma is not used.](trailing_comma_not_used.png)
    - type: "text"
      stepId: "lesson-06_functions-infix-syntax-text"
      repeatable: false
      text: "Methods with a single parameter can use the `infix` modifier, which allows\
        \ a special kind of function call: without the dot and the argument parentheses.\n\
        \n```kotlin\nclass View\nclass ViewInteractor {\n    infix fun clicks(view:\
        \ View) { \n        // ...\n    }\n}\n\nfun main() {\n    val aView = View()\n\
        \    val interactor = ViewInteractor()\n\n    // regular notation\n    interactor.clicks(aView)\n\
        \    // infix notation\n    interactor clicks aView\n}\n```\n\nThis notation\
        \ is used by some functions from Kotlin stdlib (Standard Library), like the\
        \ `and`, `or` and `xor` bitwise operations on numbers (presented in the chapter\
        \ *Basic types, their literals and operations*).\n\n```kotlin\nfun main()\
        \ {\n    // infix notation\n    println(0b011 and 0b001) // 1, that is 0b001\n\
        \    println(0b011 or 0b001) // 3, that is 0b011\n    println(0b011 xor 0b001)\
        \ // 2, that is 0b010\n\n    // regular notation\n    println(0b011.and(0b001))\
        \ // 1, that is 0b001\n    println(0b011.or(0b001)) // 3, that is 0b011\n\
        \    println(0b011.xor(0b001)) // 2, that is 0b010\n}\n```\n\nInfix notation\
        \ is only for our convenience. It is an example of Kotlin syntactic sugar\
        \ - syntax that is designed only to make things easier to read or express.\n\
        \n> Regarding the position of operators or functions in relation to their\
        \ operands or arguments, we use three kinds of position types: prefix, infix,\
        \ and postfix. Prefix notation is when we place the operator or function **before**\
        \ the operands or arguments. A good example is a plus or minus placed before\
        \ a single number (like `+12` or `-3.14`). One might argue that a top-level\
        \ function call also uses prefix notation because the function name comes\
        \ before the arguments (like `maxOf(10, 20)`). Infix notation is when we place\
        \ the operator or function **between** the operands or arguments. A good example\
        \ is a plus or minus between two numbers (like `1 + 2` or `10 - 7`). One might\
        \ argue that a method call with arguments also uses infix notation because\
        \ the function name comes between the receiver (the object we call this method\
        \ on) and arguments (like `account.add(money)`). In Kotlin, we use the term\
        \ \"infix notation\" more restrictively to reference the special notation\
        \ we use for methods with the `infix` modifier. Postfix notation is when we\
        \ place the operator or function **after** the operands or arguments. In modern\
        \ programming, postfix notation is practically not used anymore. One might\
        \ argue that calling a method with no arguments is postfix notation, as in\
        \ `str.uppercase()`."
    - type: "text"
      stepId: "lesson-06_functions-function-overloading-text"
      repeatable: false
      text: |-
        In Kotlin, we can define functions with the same name in the same scope (file or class) as long as they have different parameter types or a different number of parameters. This is known as function **overloading**. Kotlin decides which function to execute based on the types of the specified arguments.

        ```kotlin
        fun a(a: Any) = "Any"
        fun a(i: Int) = "Int"
        fun a(l: Long) = "Long"

        fun main() {
            println(a(1)) // Int
            println(a(18L)) // Long
            println(a("ABC")) // Any
        }
        ```

        A practical example of function overloading is providing multiple function variants for user convenience.

        ```kotlin
        import java.math.BigDecimal

        class Money(val amount: BigDecimal, val currency: String)

        fun pln(amount: BigDecimal) = Money(amount, "PLN")
        fun pln(amount: Int) = pln(amount.toBigDecimal())
        fun pln(amount: Double) = pln(amount.toBigDecimal())
        ```
    - type: "text"
      stepId: "lesson-06_functions-named-parameter-syntax-and-default-arguments-text"
      repeatable: false
      text: |-
        When we declare functions, we often specify optional parameters. A good example is `joinToString`, which transforms an iterable into a `String`. It can be used without any arguments, or we might change its behavior with concrete arguments.

        ```kotlin
        fun main() {
            val list = listOf(1, 2, 3, 4)
            println(list.joinToString()) // 1, 2, 3, 4
            println(list.joinToString(separator = "-")) //  1-2-3-4
            println(list.joinToString(limit = 2)) //  1, 2, ...
        }
        ```

        Many more functions in Kotlin use optional parametrization, but how is this done? It is enough to place an equality sign after a parameter and then specify the default value.

        ```kotlin
        fun cheer(how: String = "Hello,", who: String = "World") {
            println("$how $who")
        }

        fun main() {
            cheer() // Hello, World
            cheer("Hi") // Hi World
        }
        ```

        Values specified this way are created on-demand when there is no parameter for their position. This is not Python, therefore they are not stored statically, which is why it’s safe to use mutable values as default arguments.

        ```kotlin
        fun addOneAndPrint(list: MutableList<Int> = mutableListOf()) {
            list.add(1)
            println(list)
        }

        fun main() {
            addOneAndPrint() // [1]
            addOneAndPrint() // [1]
            addOneAndPrint() // [1]
        }
        ```

        > In Python, the analogous code would produce `[1]`, `[1, 1]`, and `[1, 1, 1]`.

        When we call a function, we can specify an argument’s position by its parameter name, like in the example below. This way, we can specify later optional positions without specifying previous ones. This is called *named parameter syntax*.

        ```kotlin
        fun cheer(how: String = "Hello,", who: String = "World") {
            print("$how $who")
        }

        fun main() {
            cheer(who = "Group") // Hello, Group
        }
        ```

        Named parameter syntax is very useful for improving our code’s readability. When an argument's meaning is not clear, it is better to specify a parameter name for it.

        ```kotlin
        fun main() {
            val list = listOf(1, 2, 3, 4)
            println(list.joinToString("-")) // 1-2-3-4
            // better
            println(list.joinToString(separator = "-")) //  1-2-3-4
        }
        ```

        Naming arguments also prevents mistakes that are a result of changing parameter positions.

        ```kotlin
        class User(
            val name: String,
            val surname: String,
        )

        val user = User(
            name = "Norbert",
            surname = "Moskała",
        )
        ```

        In the above example, without named arguments a developer might flip the `name` and `surname` positions; if named arguments were not used here, this would lead to an incorrect name and surname in the object. Named arguments protect us from such situations.

        It is considered a good practice to use the named arguments convention when we call functions with many arguments, some of whose meanings might not be obvious to developers reading our code in the future.
    - type: "text"
      stepId: "lesson-06_functions-vararg-parameters-text"
      repeatable: false
      text: |-
        Each parameter expects one argument, except for parameters marked with the `vararg` modifier. Such parameters accept any number of arguments.

        ```kotlin
        fun a(vararg params: Int) {}

        fun main() {
            a()
            a(1)
            a(1, 2)
            a(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
        }
        ```

        A good example of such a function is `listOf`, which produces a list from values used as arguments.

        ```kotlin
        fun main() {
            println(listOf(1, 3, 5, 6)) // [1, 3, 5, 6]
            println(listOf("A", "B", "C")) // [A, B, C]
        }
        ```

        This means a vararg parameter holds a collection of values, therefore it cannot have the type of a single object. So the vararg parameter represents an array of the declared type, and we can iterate over arrays using a for loop (which will be explained in more depth in the next chapter).

        ```kotlin
        fun concatenate(vararg strings: String): String {
            // The type of `strings` is Array<String>
            var accumulator = ""
            for (s in strings) accumulator += s
            return accumulator
        }

        fun sum(vararg ints: Int): Int {
            // The type of `ints` is IntArray
            var accumulator = 0
            for (i in ints) accumulator += i
            return accumulator
        }

        fun main() {
            println(concatenate()) //
            println(concatenate("A", "B")) // AB
            println(sum()) // 0
            println(sum(1, 2, 3)) // 6
        }
        ```

        We will get back to vararg parameters in the chapter *Collections*, in the section dedicated to arrays.
    - type: "text"
      stepId: "lesson-06_functions-`unit`-return-type-text"
      repeatable: false
      text: |-
        In Kotlin, all functions have a result type, so every function call is an expression. When a type is not specified, the default result type is `Unit`, and the default result value is the `Unit` object.

        ```kotlin
        fun someFunction() {}

        fun main() {
            val res: Unit = someFunction()
            println(res) // kotlin.Unit
        }
        ```

        `Unit` is just a very simple object that is used as a placeholder when nothing else is returned. When you specify a function without an explicit result type, its result type will implicitly be `Unit`. When you define a function without `return` in the last line, it is the same as using `return` with no value. Using `return` with no value is the same as returning `Unit`.

        ```kotlin
        fun a() {}

        // the same as
        fun a(): Unit {}

        // the same as
        fun a(): Unit {
            return
        }

        // the same as
        fun a(): Unit {
            return Unit
        }
        ```
    - type: "text"
      stepId: "lesson-06_functions-parameters-and-arguments-text"
      repeatable: false
      text: |-
        A variable defined as a part of a function definition is called a **parameter**. The value that is passed when we call a function is called an **argument**.

        ```kotlin
        fun square(x: Double) = x * x // x is a parameter

        fun main() {
            println(square(10.0)) // 10.0 is an argument
            println(square(0.0)) // 0.0 is an argument
        }
        ```

        In Kotlin, parameters are read-only, so we cannot reassign their value.

        ```kotlin
        fun a(i: Int) {
            i = i + 10 // ERROR
            // ...
        }
        ```

        If you need to modify a parameter variable, the only way is to shadow it with a local variable that is mutable.

        ```kotlin
        fun a(i: Int) {
            var i = i + 10
            // ...
        }
        ```

        This is possible but discouraged. A parameter holds a value that was used as an argument, and this value should not change. A local read-write variable represents a different concept and should therefore have a different name.
    - type: "text"
      stepId: "lesson-06_functions-functions-on-all-levels-text"
      repeatable: false
      text: |-
        Kotlin allows us to define functions on many levels, but this isn’t very obvious as Java only allows functions inside classes. In Kotlin, we can define:
        * functions in files outside any classes, called **top-level functions**,
        * functions inside classes or objects, called **member functions** (they are also called **methods**),
        * functions inside functions, called **local functions** or **nested functions**.

        ```kotlin
        // Top-level function
        fun double(i: Int) = i * 2

        class A {
            // Member function (method)
            private fun triple(i: Int) = i * 3

            // Member function (method)
            fun twelveTimes(i: Int): Int {
                // Local function
                fun fourTimes() = double(double(i))
                return triple(fourTimes())
            }
        }

        // Top-level function
        fun main(args: Array<String>) {
            double(1) // 2
            A().twelveTimes(2) // 24
        }
        ```

        Top-level functions (defined outside classes) are often used to define utils, small but useful functions that help us with development. Top-level functions can be moved and split across files. In many cases, top-level functions in Kotlin are better than static functions in Java. Using them seems intuitive and convenient for developers.

        However, it’s a different story with local functions (defined inside functions). I often see that developers lack the imagination to use them (due to lack of exposure to them). Local functions are popular in JavaScript and Python, but there’s nothing like this in Java. The power of local functions is that they can directly access or modify local variables. They are used to extract repetitive code inside a function that operates on local variables. Longer functions should tell a "story", and local subroutines can wrap a block expression in a descriptive name.

        Take a look at the below example, which presents a function that validates a form. It checks conditions for the form fields. If a condition is not matched, we should show an error and change the local variable `isValid` to `false`, in which case we should not return from the function because we want to check all the fields (we should not stop at the first one that fails). This is an example of where a local function can help us extract repetitive behavior.

        ```kotlin
        fun validateForm() {
            var isValid = true
            val errors = mutableListOf<String>()
            fun addError(view: FormView, error: String) {
                view.error = error
                errors += error
                isValid = false
            }

            val email = emailView.text
            if (email.isBlank()) {
                addError(emailView, "Email cannot be empty or blank")
            }

            val pass = passView.text.trim()
            if (pass.length < 3) {
                addError(passView, "Password too short")
            }

            if (isValid) {
                tryLogin(email, pass)
            } else {
                showErrors(errors)
            }
        }
        ```
    - type: "text"
      stepId: "lesson-06_functions-single-expression-functions-text"
      repeatable: false
      text: |-
        Many functions in real-life projects just have a single expression, so they start and immediately use the `return` keyword. The `square` function defined above is a great example. For such functions, instead of defining the body with braces, we can use the equality sign (`=`) and just specify the expression that calculates the result without specifying `return`. This is *single-expression syntax*, and functions that use it are called *single-expression functions*.

        ```kotlin
        fun square(x: Double): Double = x * x

        fun main() {
            println(square(10.0)) // 100.0
        }
        ```

        An expression can be more complicated and take multiple lines. This is fine as long as its body is a single statement.

        ```kotlin
        fun findUsers(userFilter: UserFilter): List<User> =
            userRepository
                .getUsers()
                .map { it.toDomain() }
                .filter { userFilter.accepts(it) }
        ```

        When we use single-expression function syntax, we can infer the result type. We don’t need to, as explicit result type might still be useful for safety and readability, but we can.

        ```kotlin
        fun square(x: Double) = x * x

        fun main() {
            println(square(10.0)) // 100.0
        }
        ```
    - type: "text"
      stepId: "lesson-06_functions-{sample:-true}-text"
      repeatable: false
      text: |-
        # Functions

        When Andrey Breslav, the initial Kotlin creator, was asked about his favourite feature during a discussion panel at KotlinConf Amsterdam, he said it was functions. In the end, functions are our programs' most important building blocks. If you look at real-life applications, most of the code either defines or calls functions.

        ![As an example, I used a random class from the APKUpdater open-source project. Notice that nearly every line either defines or calls a function.](06_example_app.png)

        In Kotlin, we define functions using the `fun` keyword. This is why we have so much "fun" in Kotlin. With a bit of creativity, a function can consist only of `fun`:

        ```kotlin
        fun <Fun> `fun`(`fun`: Fun): Fun = `fun`
        ```

        > This is the so-called *identity function*, a function that returns its argument without any modifications. It has a generic type parameter `Fun`, but this will be explained in the chapter *Generics*.

        By convention, we name functions using lower camelCase syntax. Formally, we can use characters, underscore `_`, and numbers (but not at the first position), but in general just characters should be used.

        {width: 50%}
        ![In Kotlin, we name functions with lowerCamelCase.](camelCase.png)

        This is what a typical function looks like:

        ```kotlin
        fun square(x: Double): Double {
            return x * x
        }

        fun main() {
            println(square(10.0)) // 100.0
        }
        ```

        Notice that the parameter type is specified after the variable name and a colon, and the result type is specified after a colon inside the parameter brackets. Such notation is typical of languages with powerful support for type inference because it is easier to add or remove explicit type definitions.

        ```kotlin
        val a: Int = 123
        // easy to transform from or to
        val a = 123

        fun add(a: Int, b: Int): Int = a + b

        // easy to transform from or to
        fun add(a: Int, b: Int) = a + b
        ```

        To use a reserved keyword as a function name (like `fun` or `when`), use backticks, as in the example below. When a function has an illegal name, both its definition and calls require backticks.

        Another use case for backticks is naming unit-test functions so that they can be described in plain English, as in the example below. This is not standard practice, but it is still quite a popular practice that many teams choose to adopt.

        ```kotlin
        class CartViewModelTests {
            @Test
            fun `should show error dialog when no items loaded`() {
                ...
            }
        }
        ```
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-{sample:-true}-q1"
      question: "Which of the following Kotlin snippets compile as-is? Assume they\
        \ appear in the same file at top level."
      explanation: "Identifiers cannot start with a digit and cannot be a reserved\
        \ keyword unless wrapped in backticks. Underscores are allowed. Backticked\
        \ names must be used both in declaration and call."
      repeatable: true
      answers:
      - "fun when() {}"
      - "fun `when`(): Unit {} ; fun main() { `when`() }"
      - "fun 2sum(a: Int, b: Int) = a + b"
      - "fun sum_2(a: Int, b: Int): Int { return a + b }"
      - "fun `should show error dialog when no items loaded`() {}"
      correct:
      - "fun `when`(): Unit {} ; fun main() { `when`() }"
      - "fun sum_2(a: Int, b: Int): Int { return a + b }"
      - "fun `should show error dialog when no items loaded`() {}"
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-single-expression-functions-q1"
      question: "Which of the following are valid single-expression functions that\
        \ compile as written? Choose all that apply."
      explanation: |-
        - A single-expression function uses `=` followed by exactly one expression; it may span multiple lines.
        - 1, 2, and 4 are valid single-expression functions.
        - 3 is invalid because it contains multiple statements after `=`.
        - 5 is invalid because `if` used as an expression requires an `else` branch.
      repeatable: true
      answers:
      - "fun inc(x: Int): Int = x + 1"
      - "fun printHello(): Unit = println(\"Hello\")"
      - |-
        fun sumAndInc(a: Int, b: Int): Int =
            val s = a + b
            s + 1
      - |-
        fun filtered() = listOf(1, 2, 3)
            .filter { it % 2 == 1 }
            .map { it * it }
      - "fun wrong(): Int = if (true) { 1 }"
      correct:
      - "fun inc(x: Int): Int = x + 1"
      - "fun printHello(): Unit = println(\"Hello\")"
      - |-
        fun filtered() = listOf(1, 2, 3)
            .filter { it % 2 == 1 }
            .map { it * it }
    - type: "question-single-answer"
      stepId: "lesson-06_functions-single-expression-functions-q2"
      question: |-
        What is the inferred return type of the following single-expression function?

        ```kotlin
        fun oddSquares() = listOf(1, 2, 3, 4)
            .filter { it % 2 == 1 }
            .map { it * it }
        ```
      explanation: "`filter` and `map` on a `List<Int>` return a `List<Int>`, and\
        \ the result type is inferred."
      repeatable: false
      answers:
      - "List<Int>"
      - "Sequence<Int>"
      - "IntArray"
      - "Iterable<Int>"
      correct: "List<Int>"
    - type: "question-single-answer"
      stepId: "lesson-06_functions-functions-on-all-levels-q1"
      question: "You refactor `validateForm` by moving the local function `addError`\
        \ out as a top-level function with the same body. Why does this fail to compile?"
      explanation: "Local functions form a closure over the surrounding scope. When\
        \ moved to top-level, `errors` and `isValid` are out of scope (unresolved\
        \ references)."
      repeatable: true
      answers:
      - "Top-level functions cannot access function-local variables like `errors`\
        \ or `isValid`; they’re out of scope."
      - "Top-level functions must be marked `inline` to modify variables."
      - "Kotlin forbids top-level functions from mutating properties on parameters\
        \ (like `view.error`)."
      - "It compiles, but changes to `isValid` won’t be visible after the function\
        \ returns."
      correct: "Top-level functions cannot access function-local variables like `errors`\
        \ or `isValid`; they’re out of scope."
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-functions-on-all-levels-q2"
      question: |-
        Given the code:

        ```kotlin
        fun double(i: Int) = i * 2

        class A {
            private fun triple(i: Int) = i * 3
            fun twelveTimes(i: Int): Int {
                fun fourTimes() = double(double(i))
                return triple(fourTimes())
            }
        }
        ```
        Select all correct statements:
      explanation: |-
        - `twelveTimes(2)` computes `double(double(2)) = 8`, then `triple(8) = 24`.
        - `triple` is `private`, so it’s not accessible from outside `A`.
        - Local function `fourTimes` captures `i` from `twelveTimes` and can call the top-level `double`.
      repeatable: false
      answers:
      - "`A().twelveTimes(2)` returns `24`."
      - "`A().triple(3)` is accessible from outside `A`."
      - "The local function `fourTimes` can access the parameter `i` of `twelveTimes`."
      - "The local function `fourTimes` cannot call the top-level function `double`."
      correct:
      - "`A().twelveTimes(2)` returns `24`."
      - "The local function `fourTimes` can access the parameter `i` of `twelveTimes`."
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-parameters-and-arguments-q1"
      question: "Which snippets compile without errors? Select all that apply."
      explanation: "Parameters in Kotlin are read-only and cannot be reassigned. You\
        \ can shadow a parameter with a new local variable (e.g., `var i = i + 10`).\
        \ Reassigning a `val` is illegal."
      repeatable: true
      answers:
      - "fun a(i: Int) { i = i + 10 }"
      - "fun b(i: Int) { var i = i + 10 }"
      - "fun c(x: Int) { val y = x; y = 2 }"
      - "fun d(x: Int) { var y = x; y++ }"
      - "fun e(x: Int) { val z = x * 2 }"
      correct:
      - "fun b(i: Int) { var i = i + 10 }"
      - "fun d(x: Int) { var y = x; y++ }"
      - "fun e(x: Int) { val z = x * 2 }"
    - type: "question-single-answer"
      stepId: "lesson-06_functions-parameters-and-arguments-q2"
      question: "What does this program print? fun f(x: Int): Int { var x = x + 1;\
        \ x += 2; return x } fun main() = println(f(5))"
      explanation: "The parameter `x` (5) is read-only; it’s shadowed by a local `var\
        \ x = x + 1` (becomes 6), then incremented by 2 to 8."
      repeatable: false
      answers:
      - "5"
      - "6"
      - "7"
      - "8"
      correct: "8"
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-`unit`-return-type-q1"
      question: |-
        Given:

        ```kotlin
        fun a() {}
        ```
        Which of the following function definitions are exactly equivalent to `a()` in return type and behavior (ignoring the function name)?
      explanation: "All correct options explicitly or implicitly return `Unit` with\
        \ no extra side effects. The `Any` return type changes the signature, so it\
        \ is not equivalent."
      repeatable: true
      answers:
      - "fun b(): Unit {}"
      - "fun c(): Unit { return }"
      - "fun d(): Unit = Unit"
      - "fun e() = Unit"
      - "fun f(): Any = Unit"
      correct:
      - "fun b(): Unit {}"
      - "fun c(): Unit { return }"
      - "fun d(): Unit = Unit"
      - "fun e() = Unit"
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-`unit`-return-type-q2"
      question: "Inside a function declared as `fun g(): Unit { /* ... */ }`, which\
        \ `return` forms compile?"
      explanation: "`return` with no value, `return Unit`, and returning any expression\
        \ of type `Unit` (e.g., `println(...)`) are valid. `null` and `42` are not\
        \ `Unit`."
      repeatable: false
      answers:
      - "return"
      - "return Unit"
      - "return println(\"OK\")"
      - "return null"
      - "return 42"
      correct:
      - "return"
      - "return Unit"
      - "return println(\"OK\")"
    - type: "question-single-answer"
      stepId: "lesson-06_functions-vararg-parameters-q1"
      question: "In Kotlin, given `fun sum(vararg ints: Int)`, what is the compile-time\
        \ type of `ints` inside the function body?"
      explanation: "`vararg` parameters are arrays inside the function. For primitive\
        \ element types, Kotlin uses specialized primitive arrays, so `Int` becomes\
        \ `IntArray`."
      repeatable: true
      answers:
      - "IntArray"
      - "Array<Int>"
      - "List<Int>"
      - "Sequence<Int>"
      correct: "IntArray"
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-vararg-parameters-q2"
      question: "Choose all correct statements about `vararg` parameters based on\
        \ the section."
      explanation: |-
        - Vararg accepts any number of arguments, including zero.
        - Inside the function, a `vararg` of reference type becomes `Array<T>`; of primitive type becomes a primitive array.
        - `listOf` is a standard example of a vararg function.
        - You declare a vararg with the element type, not an array type, and you can iterate it with `for`.
      repeatable: true
      answers:
      - "You can call a vararg function with zero arguments."
      - "Inside `fun concatenate(vararg strings: String)`, `strings` has type `Array<String>`."
      - "`listOf` is defined with a vararg parameter."
      - "A vararg parameter must be declared with an array type (e.g., `vararg xs:\
        \ Array<Int>`)."
      - "A vararg parameter cannot be iterated with a for loop."
      correct:
      - "You can call a vararg function with zero arguments."
      - "Inside `fun concatenate(vararg strings: String)`, `strings` has type `Array<String>`."
      - "`listOf` is defined with a vararg parameter."
    - type: "question-single-answer"
      stepId: "lesson-06_functions-named-parameter-syntax-and-default-arguments-q1"
      question: |-
        Given:

        ```kotlin
        fun addOneAndPrint(list: MutableList<Int> = mutableListOf()) {
            list.add(1)
            println(list)
        }

        fun main() {
            addOneAndPrint()
            addOneAndPrint()
            addOneAndPrint()
        }
        ```
        What is the output?
      explanation: "Default arguments are evaluated on each call in Kotlin. A new\
        \ mutable list is created every time, so the list does not accumulate elements\
        \ across calls."
      repeatable: true
      answers:
      - "Line1: [1], Line2: [1], Line3: [1]"
      - "Line1: [1], Line2: [1, 1], Line3: [1, 1, 1]"
      - "Line1: [1, 1, 1], Line2: [1, 1, 1], Line3: [1, 1, 1]"
      - "Compilation error: default value must be constant"
      correct: "Line1: [1], Line2: [1], Line3: [1]"
    - type: "question-single-answer"
      stepId: "lesson-06_functions-named-parameter-syntax-and-default-arguments-q2"
      question: |-
        Given:

        ```kotlin
        fun cheer(how: String = "Hello,", who: String = "World") {
            print("$how $who")
        }
        ```
        Which call sets only the `who` parameter to "Group" while leaving `how` at its default?
      explanation: "Named arguments let you specify a later parameter without providing\
        \ earlier ones. Positional \"Group\" would target `how`; other options set\
        \ both parameters."
      repeatable: false
      answers:
      - "cheer(\"Group\")"
      - "cheer(who = \"Group\")"
      - "cheer(how = \"Hello,\", who = \"Group\")"
      - "cheer(\"Hello,\", who = \"Group\")"
      correct: "cheer(who = \"Group\")"
    - type: "question-single-answer"
      stepId: "lesson-06_functions-function-overloading-q1"
      question: |-
        Given the overloads:

        ```kotlin
        fun a(x: Any) = "Any"
        fun a(x: Number) = "Number"
        fun a(x: Int) = "Int"
        ```
        What does `println(a(1L))` print?
      explanation: "The argument `1L` is a Long. There is no `Long` overload, so Kotlin\
        \ picks the most specific applicable overload among `Any` and `Number`, which\
        \ is `Number`."
      repeatable: false
      answers:
      - "Int"
      - "Number"
      - "Any"
      - "Compilation error"
      correct: "Number"
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-function-overloading-q2"
      question: "Given `fun a(x: Int) {}`, which of the following are valid overloads\
        \ in the same scope?"
      explanation: "Overloads must differ by parameter types or number of parameters.\
        \ Changing return type or only parameter names does not create a distinct\
        \ overload."
      repeatable: true
      answers:
      - "fun a(x: Long) {}"
      - "fun a(x: Int): String"
      - "fun a(x: Int, y: Int) {}"
      - "fun a(y: Int) {}"
      - "fun a(x: Number) {}"
      correct:
      - "fun a(x: Long) {}"
      - "fun a(x: Int, y: Int) {}"
      - "fun a(x: Number) {}"
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-infix-syntax-q1"
      question: |-
        Given:

        ```kotlin
        class View
        class ViewInteractor {
            infix fun clicks(view: View) {}
            fun taps(view: View) {}
        }

        val aView = View()
        val interactor = ViewInteractor()
        ```

        Which of the following are valid infix calls that compile?
      explanation: |-
        - Infix calls require a function marked with `infix` and exactly one argument, called without dot/parentheses.
        - `interactor clicks aView` and `0b011 and 0b001` meet these rules.
        - `taps` isn't infix; dotted forms are regular calls, not infix.
      repeatable: false
      answers:
      - "interactor clicks aView"
      - "interactor taps aView"
      - "interactor.clicks(aView)"
      - "0b011 and 0b001"
      - "0b011.and(0b001)"
      correct:
      - "interactor clicks aView"
      - "0b011 and 0b001"
    - type: "question-single-answer"
      stepId: "lesson-06_functions-infix-syntax-q2"
      question: "You want to call `logger log \"Started\"` using infix notation. Which\
        \ declaration enables this?"
      explanation: "An infix function must be a member (or extension) with the `infix`\
        \ modifier and exactly one parameter."
      repeatable: false
      answers:
      - "class Logger { infix fun log(message: String) {} }"
      - "class Logger { fun log(message: String) {} }"
      - "class Logger { infix fun log() {} }"
      - "class Logger { infix fun log(message: String, level: Int) {} }"
      correct: "class Logger { infix fun log(message: String) {} }"
    - type: "question-single-answer"
      stepId: "lesson-06_functions-function-formatting-q1"
      question: |-
        Given the function:

        ```kotlin
        fun log(tag: String, vararg messages: String, level: Int) {}
        ```

        Which call best demonstrates the section's exception for long calls (keeping multiple vararg arguments on the same line, while other arguments are on separate lines)?
      explanation: "For long calls, each argument goes on its own line, with an exception\
        \ allowing multiple vararg arguments to stay on one line. Option A shows exactly\
        \ that. B violates the per-argument line rule; C is not a long/multiline call;\
        \ D is invalid ordering (vararg items after a named argument)."
      repeatable: true
      answers:
      - |-
        ```kotlin
        log(
            tag = "Auth",
            "Started", "step1", "done",
            level = 2,
        )
        ```
      - |-
        ```kotlin
        log(
            tag = "Auth", level = 2,
            "Started",
            "step1",
            "done",
        )
        ```
      - |-
        ```kotlin
        log(tag = "Auth", "Started", "step1", "done", level = 2)
        ```
      - |-
        ```kotlin
        log(
            tag = "Auth",
            "Started",
            level = 2, "step1", "done",
        )
        ```
      correct: |-
        ```kotlin
        log(
            tag = "Auth",
            "Started", "step1", "done",
            level = 2,
        )
        ```
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-function-formatting-q2"
      question: "According to the section, where may a trailing comma be used?"
      explanation: "The section shows trailing commas used after parameters and after\
        \ arguments in multiline calls. Other locations are not covered here."
      repeatable: false
      answers:
      - "After the last parameter in a multiline function declaration"
      - "After the last argument in a multiline function call"
      - "After the last supertype in a class header"
      - "After the last enum entry in an enum class"
      - "After the last character in a string literal"
      correct:
      - "After the last parameter in a multiline function declaration"
      - "After the last argument in a multiline function call"
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-summary-q1"
      question: "Which declarations can be called using infix notation (e.g., `a op\
        \ b`)?"
      explanation: "An infix function must be marked `infix`, be a member or extension,\
        \ take exactly one parameter, and that parameter cannot be `vararg` or have\
        \ a default value."
      repeatable: true
      answers:
      - "infix fun Int.add(other: Int) = this + other"
      - "infix fun Int.bar(other: Int = 0) = this + other"
      - "fun Int.baz(other: Int) = this + other"
      - "infix fun Int.qux(vararg xs: Int) = this + xs.sum()"
      - "class Box { infix fun put(item: String) { /*...*/ } }"
      correct:
      - "infix fun Int.add(other: Int) = this + other"
      - "class Box { infix fun put(item: String) { /*...*/ } }"
    - type: "question-multiple-answer"
      stepId: "lesson-06_functions-summary-q2"
      question: |-
        Given the function with trailing commas and a middle vararg:

        ```kotlin
        fun join(
            prefix: String = "[",
            vararg parts: String,
            suffix: String = "]",
        ) = prefix + parts.joinToString() + suffix
        ```
        Which calls compile?
      explanation: "When a `vararg` is not last, all arguments that follow must be\
        \ named. Also, once you use a named argument, all subsequent arguments must\
        \ be named. The valid calls either keep all positional args before `suffix`\
        \ or use names appropriately."
      repeatable: true
      answers:
      - "join()"
      - "join(\"(\", \"a\", \"b\", suffix = \")\")"
      - "join(prefix = \"(\", \"a\", \"b\")"
      - "join(\"(\", suffix = \")\")"
      - "join(suffix = \")\", \"a\")"
      - "join(prefix = \"(\", suffix = \")\")"
      correct:
      - "join()"
      - "join(\"(\", \"a\", \"b\", suffix = \")\")"
      - "join(\"(\", suffix = \")\")"
      - "join(prefix = \"(\", suffix = \")\")"
  - lessonId: "lesson-the-power-of-the-for-loop"
    name: "The power of the for-loop"
    steps:
    - type: "text"
      stepId: "lesson-07_for-ranges-text"
      repeatable: false
      text: "In Kotlin, if you place two dots between two numbers, like `1..5`, you\
        \ create an `IntRange`. This class implements `Iterable<Int>`, so we can use\
        \ it in a for-loop:\n\n```kotlin\nfun main() {\n    for (i in 1..5) {\n  \
        \      print(i)\n    }\n}\n// 12345\n```\n\nThis solution is efficient as\
        \ well as convenient because the Kotlin compiler optimizes its performance\
        \ under the hood.\n\nRanges created with `..` include the last value (which\
        \ means they are **closed ranges**). If you want a range that stops before\
        \ the last value, use the `..<` operator or `until` infix function instead.\n\
        \n```kotlin\nfun main() {\n    for (i in 1..<5) {\n        print(i)\n    }\n\
        }\n// 1234\n```\n\n```kotlin\nfun main() {\n    for (i in 1 until 5) {\n \
        \       print(i)\n    }\n}\n// 1234\n```\n\nBoth `..` and `..<` start with\
        \ the value on their left and progress toward the right number in increments\
        \ of one. If you use a bigger number on the left, the result is an empty range.\n\
        \n```kotlin\nfun main() {\n    for (i in 5..1) {\n        print(i)\n    }\n\
        \    for (i in 5..<1) {\n        print(i)\n    }\n}\n// (nothing is printed)\n\
        ```\n\nIf you want to iterate in the other direction, from larger to smaller\
        \ numbers, use the `downTo` function.\n\n```kotlin\nfun main() {\n    for\
        \ (i in 5 downTo 1) {\n        print(i)\n    }\n}\n// 54321\n```\n\nThe default\
        \ step in all those cases is `1`. If you want to use a different step, you\
        \ should use the `step` infix function.\n\n```kotlin\nfun main() {\n    for\
        \ (i in 1..10 step 3) {\n        print(\"$i \")\n    }\n    println()\n  \
        \  for (i in 1..<10 step 3) {\n        print(\"$i \")\n    }\n    println()\n\
        \    for (i in 10 downTo 1 step 3) {\n        print(\"$i \")\n    }\n}\n//\
        \ 1 4 7 10 \n// 1 4 7 \n// 10 7 4 1 \n```"
    - type: "text"
      stepId: "lesson-07_for-#-the-power-of-the-for-loop-text"
      repeatable: false
      text: "In Java and other older languages, a for-loop typically has three parts:\
        \ the first initializes the variable before the loop starts; the second contains\
        \ the condition for the execution of the code block; the third is executed\
        \ after the code block.\n\n```    \n// Java\nfor(int i=0; i < 5; i++){\n \
        \  System.out.println(i);\n}\n```\n\nHowever, this is considered complicated\
        \ and error-prone. Just consider a situation in which someone uses `>` or\
        \ `<=` instead of `<`. Such a small difference is not easy to notice, but\
        \ it essentially influences the behavior of this for-loop.\n\nAs an alternative\
        \ to this classic for-loop, many languages have introduced a modern alternative\
        \ for iterating over collections. This is why, in languages like Java or JavaScript,\
        \ there are two completely different kinds of for-loops, both of which are\
        \ defined with the same `for` keyword. Kotlin has simplified this. In Kotlin,\
        \ we have one universal for-loop that can be expressively used to iterate\
        \ over a collection, a map, a range of numbers, and much more.\n\nIn general,\
        \ a for-loop is used in Kotlin to iterate over something that is iterable.\n\
        \n{width: 60%}\n![](for_described.jpg)\n\nWe can iterate over lists or sets.\n\
        \n```kotlin\nfun main() {\n    val list = listOf(\"A\", \"B\", \"C\")\n  \
        \  for (letter in list) {\n        print(letter)\n    }\n\n    // Variable\
        \ type can be explicit\n    for (str: String in setOf(\"D\", \"E\", \"F\"\
        )) {\n        print(str)\n    }\n}\n// ABCDEF\n```\n\nWe can also iterate\
        \ over any other object as long as it contains the `iterator` method with\
        \ no parameters, plus the `Iterator` result type and the `operator` modifier.\
        \ The easiest way to define this operator method is to make your class implement\
        \ the `Iterable` interface (then you do not need to define `operator` modifier\
        \ yourself, as it is inherited from `Iterable`). In the below example, we\
        \ define a `Tree` class that implements `Iterable<String>`, so we must override\
        \ the `iterator` method, and we can iterate over an instance of this class.\n\
        \n```kotlin\nfun main() {\n    val tree = Tree(\n        value = \"B\",\n\
        \        left = Tree(\"A\"),\n        right = Tree(\"D\", left = Tree(\"C\"\
        ))\n    )\n\n    for (value in tree) {\n        print(value) // ABCD\n   \
        \ }\n}\n\nclass Tree(\n    val value: String,\n    val left: Tree? = null,\n\
        \    val right: Tree? = null,\n) : Iterable<String> {\n\n    override fun\
        \ iterator(): Iterator<String> = iterator {\n        if (left != null) yieldAll(left)\n\
        \        yield(value)\n        if (right != null) yieldAll(right)\n    }\n\
        }\n```\n\nThe inferred variable type of the variable defined inside the for-loop\
        \ comes from the `Iterable` type argument. When we iterate over `Iterable<User>`,\
        \ the inferred element type will be `User`. When we iterate over `Iterable<Long?>`,\
        \ the inferred element type will be `Long?`. The same applies to all other\
        \ types.\n\nThis mechanism, which relies on `Iterable`, is really powerful\
        \ and allows us to cover numerous use cases, one of the most notable of which\
        \ is the use of *ranges* to express progressions."
    - type: "question-multiple-answer"
      stepId: "lesson-07_for-#-the-power-of-the-for-loop-q1"
      question: "To make `for (x in myObj)` compile for a custom class in Kotlin,\
        \ which statements are true?"
      explanation: "A Kotlin for-loop lowers to `myObj.iterator()`; it must be an\
        \ operator with no parameters returning `kotlin.collections.Iterator<...>`.\
        \ Implementing `Iterable<T>` satisfies this. `Sequence<T>` is not required."
      repeatable: true
      answers:
      - "Provide an operator function `iterator()` with no parameters."
      - "`iterator()` must return `kotlin.collections.Iterator<...>`."
      - "Implementing `Iterable<T>` is sufficient."
      - "You must implement `Sequence<T>`."
      - "Support for Java-style `for(init; cond; step)` is required."
      correct:
      - "Provide an operator function `iterator()` with no parameters."
      - "`iterator()` must return `kotlin.collections.Iterator<...>`."
      - "Implementing `Iterable<T>` is sufficient."
    - type: "question-multiple-answer"
      stepId: "lesson-07_for-#-the-power-of-the-for-loop-q2"
      question: |-
        Given `val items: Iterable<Long?> = listOf(1L, null)`, which explicit loop variable type annotations compile?

        ```
        for (x: ??? in items) { /* ... */ }
        ```
      explanation: "The element type is `Long?`. The loop variable type must be the\
        \ same or a supertype. `Long?` and `Any?` work; `Long` and `Any` do not (nullability\
        \ mismatch)."
      repeatable: false
      answers:
      - "Long"
      - "Long?"
      - "Any"
      - "Any?"
      correct:
      - "Long?"
      - "Any?"
    - type: "question-multiple-answer"
      stepId: "lesson-07_for-ranges-q1"
      question: "Which of the following for-loops iterate over no elements (print\
        \ nothing)?"
      explanation: "`..` and `..<` progress forward; if start > end, the range/progression\
        \ is empty. `downTo` progresses backward; if start < end, it’s empty. `until`/`..<`\
        \ exclude the end, so `start == end` is empty."
      repeatable: true
      answers:
      - "for (i in 5..1) print(i)"
      - "for (i in 1 until 1) print(i)"
      - "for (i in 1 downTo 5) print(i)"
      - "for (i in 5 downTo 1 step 2) print(i)"
      - "for (i in 1..<2) print(i)"
      correct:
      - "for (i in 5..1) print(i)"
      - "for (i in 1 until 1) print(i)"
      - "for (i in 1 downTo 5) print(i)"
    - type: "question-multiple-answer"
      stepId: "lesson-07_for-ranges-q2"
      question: "Which loops iterate over exactly the values 1, 4, 7 in this order\
        \ (no other values)?"
      explanation: "`1..<10` and `1 until 10` exclude 10; with `step 3` they yield\
        \ 1,4,7. `1..9 step 3` also yields 1,4,7. `1..10 step 3` includes 10, and\
        \ `downTo` reverses order."
      repeatable: true
      answers:
      - "for (i in 1 until 10 step 3) print(i)"
      - "for (i in 1..<10 step 3) print(i)"
      - "for (i in 1..9 step 3) print(i)"
      - "for (i in 1..10 step 3) print(i)"
      - "for (i in 10 downTo 1 step 3) print(i)"
      correct:
      - "for (i in 1 until 10 step 3) print(i)"
      - "for (i in 1..<10 step 3) print(i)"
      - "for (i in 1..9 step 3) print(i)"
  - lessonId: "lesson-inheritance"
    name: "Inheritance"
    steps:
    - type: "text"
      stepId: "lesson-10_inheritance-summary-text"
      repeatable: false
      text: |-
        In this chapter, we’ve learned how to use inheritance in Kotlin. We’ve got familiar with open and abstract classes, interfaces, and visibility modifiers. These are useful when we want to represent hierarchies of classes.

        Instead of using classes to represent hierarchies, we can also treat them as holders of data; for this we use the `data` modifier, which is presented in the next chapter.
    - type: "text"
      stepId: "lesson-10_inheritance-`any`-text"
      repeatable: false
      text: |-
        If a class has no explicit parent, its implicit parent is `Any`, which is a superclass of all the classes in Kotlin. This means that when we expect the `Any?` type parameter, we accept all possible objects as arguments.

        ```kotlin
        fun consumeAnything(a: Any?) {
            println("Om nom $a")
        }

        fun main() {
            consumeAnything(null) // Om nom null
            consumeAnything(123) // Om nom 123
            consumeAnything("ABC") // Om nom ABC
        }
        ```

        You can think of `Any` as an open class with three methods: `toString`, `equals` and `hashCode`. These will be better explained in the next chapter, *Data classes*. Overriding methods defined by `Any` is optional because each is an open function with a default body.
    - type: "text"
      stepId: "lesson-10_inheritance-visibility-text"
      repeatable: false
      text: |-
        When we design our classes, we prefer to expose as little as possible. If there is no reason for an element to be visible, we prefer to keep it hidden. This is why if there is no good reason to have a less restrictive visibility type, it is good practice to make the visibility of classes and elements as restrictive as possible. We do this using visibility modifiers.

        For class members, these are the 4 visibility modifiers we can use:
        * `public` (default) - visible everywhere for clients which can see the declaring class.
        * `private` - visible inside this class only.
        * `protected` - visible inside this class and in subclasses.
        * `internal` - visible inside this module for clients which can see the declaring class.

        Top-level elements have 3 visibility modifiers:
        * `public` (default) - visible everywhere.
        * `private` - visible inside the same file only.
        * `internal` - visible inside this module.

        Note that a module is not the same as a package. In Kotlin, a module is defined as a set of Kotlin sources that are compiled together. This might mean:
        * a Gradle source set,
        * a Maven project,
        * an IntelliJ IDEA module,
        * a set of files compiled with one invocation of an Ant task.

        Let's see some examples, starting with the default visibility, which makes elements visible everywhere and can be explicitly specified using the `public` modifier.

        ```kotlin
        // File1.kt
        open class A {
           public val a = 10
           public fun b() {
               println(a) // Can use it
           }
        }

        public val c = 20
        public fun d() {}

        class B: A() {
           fun e() {
               println(a) // Can use it
               println(b()) // Can use it
           }
        }

        fun main() {
           println(A().a) // Can use it
           println(A().b()) // Can use it
           println(c) // Can use it
           println(d()) // Can use it
        }

        // File2.kt in the same or different module as File1.kt
        fun main() {
           println(A().a) // Can use it
           println(A().b()) // Can use it
           println(c) // Can use it
           println(d()) // Can use it
        }
        ```

        The `private` modifier can be interpreted as "visible in the creation scope"; so, if we define an element in a class, it will be visible only in this class; if we define an element in a file, it will be visible only in this file.

        ```kotlin
        // File1.kt
        open class A {
            private val a = 10
            private fun b() {
                println(a) // Can use it
            }
        }

        private val c = 20
        private fun d() {}

        class B : A() {
            fun e() {
                println(a) // Error, cannot use a!
                println(b()) // Error, cannot use b!
            }
        }

        fun main() {
            println(A().a) // Error, cannot use a!
            println(A().b()) // Error, cannot use b!
            println(c) // Can use it
            println(d()) // Can use it
        }

        // File2.kt in the same or different module as File1.kt
        fun main() {
            println(A().a) // Error, cannot use a!
            println(A().b()) // Error, cannot use b!
            println(c) // Error, cannot use c!
            println(d()) // Error, cannot use d!
        }
        ```

        The `protected` modifier can be interpreted as "visible in the class and its subclasses". `protected` only makes sense for elements defined inside classes. It is similar to `private`, but protected elements are also visible inside subclasses of the class where these elements are defined.

        ```kotlin
        // File1.kt
        open class A {
           protected val a = 10
           protected fun b() {
               println(a) // Can use it
           }
        }

        open class B: A() {
           fun e() {
               println(a) // Can use it!
               println(b()) // Can use it!
           }
        }

        class C: A() {
           fun f() {
               println(a) // Can use it!
               println(b()) // Can use it!
           }
        }

        fun main() {
           println(A().a) // Error, cannot use a!
           println(A().b()) // Error, cannot use b!
        }

        // File2.kt in the same or different module as File1.kt
        fun main() {
           println(A().a) // Error, cannot use a!
           println(A().b()) // Error, cannot use b!
        }
        ```

        The `internal` modifier makes elements visible in the same module. It is useful for library creators who use the `internal` modifier for elements they want to be visible in their project but don’t want to expose to library users. It is also useful in multi-module projects to limit access to a single module. It's useless in single-module projects.

        ```kotlin
        // File1.kt
        open class A {
           internal val a = 10
           internal fun b() {
               println(a) // Can use it
           }
        }

        internal val c = 20
        internal fun d() {}

        class B: A() {
           fun e() {
               println(a) // Can use it
               println(b()) // Can use it
           }
        }

        fun main() {
           println(A().a) // Can use it
           println(A().b()) // Can use it
           println(c) // Can use it
           println(d()) // Can use it
        }

        // File2.kt in the same module as File1.kt
        fun main() {
           println(A().a) // Can use it
           println(A().b()) // Can use it
           println(c) // Can use it
           println(d()) // Can use it
        }

        // File3.kt in a different module than File1.kt
        fun main() {
           println(A().a) // Error, cannot use a!
           println(A().b()) // Error, cannot use b!
           println(c) // Error, cannot use c!
           println(d()) // Error, cannot use d!
        }
        ```

        If your module might be used by another module, change the visibility of public elements that you don’t want to expose to `internal`. If an element is designed for inheritance and is only used in a class and subclasses, make it `protected`. If you use an element only in the same file or class, make it `private`.

        Changing the visibility of a property means changing the visibility of its accessors. A property's field is always private. To change setter visibility, place the visibility modifier before the `set` keyword. The getter must have the same visibility as the property.

        ```kotlin
        class View {
           var isVisible: Boolean = true
               private set

           fun hide() {
               isVisible = false
           }
        }

        fun main() {
           val view = View()
           println(view.isVisible) // true
           view.hide()
           println(view.isVisible) // false
           view.isVisible = true // ERROR
           // Cannot assign to 'isVisible',
           // the setter is private in 'View'
        }
        ```
    - type: "question-single-answer"
      stepId: "lesson-10_inheritance-visibility-q1"
      question: "Multi-module visibility: Which calls compile inside C.use()?"
      explanation: "internal members are visible only within the declaring module;\
        \ protected members are visible in subclasses (even across modules). Therefore,\
        \ p() is callable in C, but i() is not."
      repeatable: true
      answers:
      - "Both i() and p() compile"
      - "Only p() compiles"
      - "Only i() compiles"
      - "Neither compiles"
      correct: "Only p() compiles"
    - type: "question-multiple-answer"
      stepId: "lesson-10_inheritance-visibility-q2"
      question: "Which of the following Kotlin declarations compile?"
      explanation: "Rules: getter must have the same visibility as the property (so\
        \ private get is illegal). The setter may be more restrictive than the property\
        \ (e.g., private/internal/protected set). protected is only valid for class\
        \ members, not top-level."
      repeatable: true
      answers:
      - |-
        var clicks: Int = 0
            private set
      - |-
        open class A {
            var x: Int = 0
                protected set
        }
      - |-
        class B {
            public var y: Int = 0
                internal set
        }
      - |-
        public var z: Int = 0
            internal set
      - |-
        class C {
            var a: Int = 0
                private get
        }
      - "protected var p: Int = 0"
      correct:
      - |-
        var clicks: Int = 0
            private set
      - |-
        open class A {
            var x: Int = 0
                protected set
        }
      - |-
        class B {
            public var y: Int = 0
                internal set
        }
      - |-
        public var z: Int = 0
            internal set
    - type: "question-single-answer"
      stepId: "lesson-10_inheritance-`any`-q1"
      question: "In Kotlin, which parameter type should you use to accept any value,\
        \ including null?"
      explanation: "`Any` is the superclass of all classes; adding `?` allows null.\
        \ `Nothing?` can only be null, and `Unit` is a return type."
      repeatable: true
      answers:
      - "Any"
      - "Any?"
      - "Nothing"
      - "Nothing?"
      - "Unit"
      correct: "Any?"
    - type: "question-multiple-answer"
      stepId: "lesson-10_inheritance-`any`-q2"
      question: "Which functions are declared in Kotlin's `Any` and can be optionally\
        \ overridden?"
      explanation: "`Any` defines `equals`, `hashCode`, and `toString` with default\
        \ bodies. `copy` is for data classes; `compareTo` comes from `Comparable`."
      repeatable: true
      answers:
      - "toString()"
      - "equals(other: Any?)"
      - "hashCode()"
      - "copy()"
      - "compareTo(other: Any)"
      correct:
      - "toString()"
      - "equals(other: Any?)"
      - "hashCode()"
    - type: "question-multiple-answer"
      stepId: "lesson-10_inheritance-summary-q1"
      question: "Which visibility modifiers are valid for top-level (file-level) declarations\
        \ in Kotlin?"
      explanation: "Top-level declarations can be public (default), internal (module-visible),\
        \ or private (file-visible). protected is only for class/interface members."
      repeatable: true
      answers:
      - "public"
      - "internal"
      - "private"
      - "protected"
      correct:
      - "public"
      - "internal"
      - "private"
    - type: "question-single-answer"
      stepId: "lesson-10_inheritance-summary-q2"
      question: "Given `class Base` and `class Derived : Base()` fails to compile,\
        \ without making `Base` abstract, which modifier must you add to make inheritance\
        \ work?"
      explanation: "Classes are final by default in Kotlin. To allow subclassing of\
        \ a concrete class, mark the superclass as open (or abstract, but the question\
        \ forbids that)."
      repeatable: true
      answers:
      - "Mark `Base` as `open`"
      - "Mark `Derived` as `open`"
      - "Mark `Base` as `internal`"
      - "Mark `Derived` as `override`"
      correct: "Mark `Base` as `open`"
  - lessonId: "lesson-data-classes"
    name: "Data classes"
    steps:
    - type: "text"
      stepId: "lesson-11_data_classes-transforming-to-a-string-text"
      repeatable: false
      text: "The default `toString` transformation produces a string that starts with\
        \ the class name, then the at sign \"@\", and then the unsigned hexadecimal\
        \ representation of the hash code of the object. The purpose of this is to\
        \ display the class name and to determine whether two strings represent the\
        \ same object or not.\n\n```kotlin\nclass FakeUserRepository\n\nfun main()\
        \ {\n   val repository1 = FakeUserRepository()\n   val repository2 = FakeUserRepository()\n\
        \   println(repository1) // e.g. FakeUserRepository@8efb846\n   println(repository1)\
        \ // e.g. FakeUserRepository@8efb846\n   println(repository2) // e.g. FakeUserRepository@2a84aee7\n\
        }\n```\n\nWith the `data` modifier, the compiler generates a `toString` that\
        \ displays the class name and then pairs with the name and value for each\
        \ primary constructor property. We assume that data classes are represented\
        \ by their primary constructor properties, so all these properties, together\
        \ with their values, are displayed during a transformation to a string. This\
        \ is useful for logging and debugging.\n\n```kotlin\ndata class Player(\n\
        \   val id: Int,\n   val name: String,\n   val points: Int\n)\n\nfun main()\
        \ {\n   val player = Player(0, \"Gecko\", 9999)\n   println(player) \n   //\
        \ Player(id=0, name=Gecko, points=9999)\n   println(\"Player: $player\")\n\
        \   // Player: Player(id=0, name=Gecko, points=9999)\n}\n```\n\n{width: 84%}\n\
        ![](data_toString.png)"
    - type: "text"
      stepId: "lesson-11_data_classes-{sample:-true}-text"
      repeatable: false
      text: |-
        # Data classes

        In Kotlin, we say that all classes inherit from the `Any` superclass, which is at the top of the class hierarchy. Methods defined in `Any` can be called on all objects. These methods are:
        * `equals` - used when two objects are compared using `==`,
        * `hashCode` - used by collections that use the hash table algorithm,
        * `toString` - used to represent an object as a string, e.g., in a string template or the `print` function.

        Thanks to these methods, we can represent any object as a string or check the equality of any two objects.

        ```kotlin
        // Any formal definition
        open class Any {
           open operator fun equals(other: Any?): Boolean
           open fun hashCode(): Int
           open fun toString(): String
        }

        class A // Implicitly inherits from Any

        fun main() {
           val a = A()
           a.equals(a)
           a == a
           a.hashCode()
           a.toString()
           println(a)
        }
        ```

        > Truth be told, `Any` is represented as a class, but it should actually be considered the head of the type hierarchy, but with some special functions. Consider the fact that `Any` is also the supertype of all interfaces, even though interfaces cannot inherit from classes.

        The default implementations of `equals`, `hashCode`, and `toString` are strongly based on the object’s address in memory. The `equals` method returns `true` only when the address of both objects is the same, which means the same object is on both sides. The `hashCode` method typically transforms an address into a number. `toString` produces a string that starts with the class name, then the at sign "@", then the unsigned hexadecimal representation of the hash code of the object.

        ```kotlin
        class A

        fun main() {
           val a1 = A()
           val a2 = A()

           println(a1.equals(a1)) // true
           println(a1.equals(a2)) // false
           // or
           println(a1 == a1) // true
           println(a1 == a2) // false

           println(a1.hashCode()) // Example: 149928006
           println(a2.hashCode()) // Example: 713338599

           println(a1.toString()) // Example: A@8efb846
           println(a2.toString()) // Example: A@2a84aee7
           // or
           println(a1) // Example: A@8efb846
           println(a2) // Example: A@2a84aee7
        }
        ```

        By overriding these methods, we can decide how a class should behave. Consider the following class `A`, which is equal to other instances of the same class and returns a constant hash code and string representation.

        ```kotlin
        class A {
           override fun equals(other: Any?): Boolean = other is A

           override fun hashCode(): Int = 123

           override fun toString(): String = "A()"
        }

        fun main() {
           val a1 = A()
           val a2 = A()

           println(a1.equals(a1)) // true
           println(a1.equals(a2)) // true
           // or
           println(a1 == a1) // true
           println(a1 == a2) // true

           println(a1.hashCode()) // 123
           println(a2.hashCode()) // 123

           println(a1.toString()) // A()
           println(a2.toString()) // A()
           // or
           println(a1) // A()
           println(a2) // A()
        }
        ```

        I've dedicated separate items in the *Effective Kotlin* book to implementing a custom `equals` and `hashCode`, but in practice we rarely need to do that. As it turns out, in modern projects we almost solely operate on only two kinds of objects:
        * Active objects, like services, controllers, repositories, etc. Such classes don’t need to override any methods from `Any` because the default behavior is perfect for them.
        * Data model class objects, which represent bundles of data. For such objects, we use the `data` modifier, which overrides the `toString`, `equals`, and `hashCode` methods. The `data` modifier also implements the methods `copy` and `componentN` (`component1`, `component2`, etc.), which are not inherited and cannot be modified.

        ```kotlin
        data class Player(
           val id: Int,
           val name: String,
           val points: Int
        )

        val player = Player(0, "Gecko", 9999)
        ```

        Let's discuss the aforementioned implicit data class methods and the differences between regular class behavior and data class behavior.
    - type: "question-multiple-answer"
      stepId: "lesson-11_data_classes-{sample:-true}-q1"
      question: "Select all correct statements about Kotlin data classes and Any."
      explanation: "Data classes override equals/hashCode/toString and generate copy/componentN\
        \ that are not inherited and cannot be modified. Methods from Any are available\
        \ on all objects. Regular classes by default use identity-based equals; default\
        \ toString is ClassName@hexHash, not just the name."
      repeatable: true
      answers:
      - "Data classes override equals, hashCode, and toString."
      - "Data classes provide copy and componentN functions that are not inherited\
        \ and cannot be overridden."
      - "The default equals for a regular class compares all primary-constructor properties."
      - "Methods from Any (equals, hashCode, toString) can be called on any object."
      - "The default toString for a regular class prints only the class name, without\
        \ any extra information."
      correct:
      - "Data classes override equals, hashCode, and toString."
      - "Data classes provide copy and componentN functions that are not inherited\
        \ and cannot be overridden."
      - "Methods from Any (equals, hashCode, toString) can be called on any object."
    - type: "question-single-answer"
      stepId: "lesson-11_data_classes-{sample:-true}-q2"
      question: |-
        Given:

        ```kotlin
        class A

        data class Player(val id: Int, val name: String, val points: Int)

        val a1 = A(); val a2 = A()
        val p1 = Player(1, "Gecko", 9999)
        val p2 = Player(1, "Gecko", 9999)
        ```

        Which statement is guaranteed to be true?
      explanation: "Regular classes use identity-based equals by default, so a1 ==\
        \ a2 is false. Data classes compare property values, so p1 == p2 is true.\
        \ Changing a property in copy makes it unequal. Hash codes of different A\
        \ instances are not guaranteed to differ or be equal."
      repeatable: true
      answers:
      - "a1 == a2"
      - "p1 == p2"
      - "p1.copy(points = 11) == p1"
      - "a1.hashCode() == a2.hashCode()"
      correct: "p1 == p2"
    - type: "question-single-answer"
      stepId: "lesson-11_data_classes-transforming-to-a-string-q1"
      question: "What is the default string format produced by `println(obj)` for\
        \ a regular (non-data) Kotlin class instance?"
      explanation: "By default, `Any.toString()` returns `ClassName@<unsigned-hex-of-hashCode()>`."
      repeatable: false
      answers:
      - "ClassName@<unsigned-hex-hash-code>"
      - "ClassName#<decimal-hash-code>"
      - "ClassName(hash=<unsigned-hex-hash-code>)"
      - "<ClassName>"
      correct: "ClassName@<unsigned-hex-hash-code>"
    - type: "question-single-answer"
      stepId: "lesson-11_data_classes-transforming-to-a-string-q2"
      question: |-
        Given:

        ```kotlin
        data class Box(val w: Int) {
            val h: Int = w * 2
        }

        fun main() {
            println(Box(3))
        }
        ```
        What is the output?
      explanation: "Data class `toString` includes only primary constructor properties,\
        \ in their declaration order."
      repeatable: true
      answers:
      - "Box(w=3, h=6)"
      - "Box(w=3)"
      - "Box(h=6)"
      - "Box(3, 6)"
      correct: "Box(w=3)"
