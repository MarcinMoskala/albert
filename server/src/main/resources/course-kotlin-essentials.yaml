courses:
  - courseId: "kotlin-essentials"
    title: "Kotlin Essentials"
    lessons:
      - lessonId: "what-is-kotlin"
        name: "What is Kotlin?"
        steps:
          - type: "text"
            stepId: "what-is-kotlin-introduction"
            question: "What is Kotlin?"
            explanation: "Introduction to What is Kotlin?"
            repetable: false
            text: "{sample: true}\n# What is Kotlin?\n\nKotlin is an open-source, multiplatform,\
        \ multi-paradigm, statically typed, general-purpose programming language.\
        \ But what does all this mean?\n* Open-source means that the sources of the\
        \ Kotlin compiler are freely available for modification and redistribution.\
        \ Kotlin is primarily made by JetBrains, but now there is the Kotlin Foundation,\
        \ which promotes and advances the development of this language. There is also\
        \ a public process known as KEEP, which allows anyone to see and comment on\
        \ official design change propositions.\n* Multiplatform means that a language\
        \ can be used on more than one platform. For instance, Kotlin can be used\
        \ both on Android and iOS.\n* Multi-paradigm means that a language has support\
        \ for more than one programming paradigm. Kotlin has powerful support for\
        \ both Object-Oriented Programming and Functional Programming.\n* Statically\
        \ typed means that each variable, object, and function has an associated type\
        \ that is known at compile time.\n* General-purpose means that a language\
        \ is designed to be used for building software in a wide variety of application\
        \ domains across a multitude of hardware configurations and operating systems.\n\
        \nThese descriptions might not be clear now, but you will see them all in\
        \ action throughout the book. Letâ€™s start by discussing Kotlinâ€™s multiplatform\
        \ capabilities."
          - type: "text"
            stepId: "what-is-kotlin-section-1"
            question: "Kotlin platforms"
            explanation: "Content for Kotlin platforms"
            repetable: false
            text: "## Kotlin platforms\n\nKotlin is a compiled programming language. This\
        \ means that you can write some code in Kotlin and then use the Kotlin compiler\
        \ to produce code in a lower-level language. Kotlin can currently be compiled\
        \ into JVM bytecode (Kotlin/JVM), JavaScript (Kotlin/JS), or machine code\
        \ (Kotlin/Native).\n\n![](kotlin_compile_results.png)\n\nIn this book, I would\
        \ like to address all these compilation targets and, by default, show code\
        \ that works on all of them, but I will concentrate on the most popular one:\
        \ Kotlin/JVM.\n\nKotlin/JVM is the technology thatâ€™s used to compile Kotlin\
        \ code into JVM bytecode. The result is nearly identical to the result of\
        \ compiling Java code into JVM bytecode. We also use the term â€śKotlin/JVMâ€ť\
        \ to talk about code that will be compiled into JVM bytecode.\n\n![](Kotlin_Java_compile.png)\n\
        \nKotlin/JVM and Java are fully interoperable. Any code written in Java can\
        \ be used in Kotlin/JVM. Any Java library, including those based on annotation\
        \ processing, can be used in Kotlin/JVM. Kotlin/JVM can use Java classes,\
        \ modules, libraries, and the Java standard library. Any Kotlin/JVM code can\
        \ be used in Java (except for suspending functions, which are a support for\
        \ Kotlin Coroutines).\n\n![](Java_interoperability.png)\n\nKotlin and Java\
        \ can be mixed in a single project. A typical scenario is that a project was\
        \ initially developed in Java, but then its creators decided to start using\
        \ Kotlin. To do this, instead of migrating the whole project, these developers\
        \ decided to add Kotlin to it. So, whenever they add a new file, it will be\
        \ a Kotlin file; furthermore, when they refactor old Java code, they will\
        \ migrate it to Kotlin. Over time, there is more and more Kotlin code until\
        \ it excludes Java completely.\n\n![](mix_Kotlin_Java.png)\n\nOne example\
        \ of such a project is the Kotlin compiler itself. It was initially written\
        \ in Java, but more and more files were migrated to Kotlin when it became\
        \ stable enough. This process has been happening for years now; at the time\
        \ of writing this book, the Kotlin compiler project still contains around\
        \ 10% of Java code.\n\nNow that we understand the relationship between Kotlin\
        \ and Java, it is time to fight some misconceptions. Many see Kotlin as a\
        \ layer of syntactic sugar on top of Java, but this is not true. Kotlin is\
        \ a different language than Java. It has its own conventions and practices,\
        \ and it has features that Java does not have, like multiplatform capabilities\
        \ and coroutines. You donâ€™t need to know Java to understand Kotlin. In my\
        \ opinion, Kotlin is a better first language than Java. Junior Kotlin developers\
        \ do not need to know what the `equals` method is and how to override it.\
        \ For them, it is enough to know the default class and data class equality[^01_4].\
        \ They donâ€™t need to learn to write getters and setters, or how to implement\
        \ a singleton or a builder pattern. Kotlin has a lower entry threshold than\
        \ Java and does not need the JVM platform."
          - type: "text"
            stepId: "what-is-kotlin-section-2"
            question: "The Kotlin IDE"
            explanation: "Content for The Kotlin IDE"
            repetable: false
            text: "## The Kotlin IDE\n\nThe most popular Kotlin IDEs (integrated development\
        \ environments) are IntelliJ IDEA and Android Studio. However, you can also\
        \ write programs in Kotlin using VS Code, Eclipse, Vim, Emacs, Sublime Text,\
        \ and many more. You can also write Kotlin code online, for instance, using\
        \ the official online IDE that can be found at this link [play.kotlinlang.org](play.kotlinlang.org/)."
          - type: "text"
            stepId: "what-is-kotlin-section-3"
            question: "Where do we use Kotlin?"
            explanation: "Content for Where do we use Kotlin?"
            repetable: false
            text: "## Where do we use Kotlin?\n\nKotlin can be used as an alternative to\
        \ Java, JavaScript, C++, Objective-C, etc. However, it is most mature on JVM,\
        \ so it is currently mainly used as an alternative to Java.\n\nKotlin has\
        \ become quite popular for backend development. I most often see it used with\
        \ the Spring framework, but some projects use Kotlin with backend frameworks\
        \ like Vert.x, Ktor, Micronaut, http4k or Javalin.\n\nKotlin has also practically\
        \ become the standard language for Android development. Google has officially\
        \ suggested that all Android applications should be written in Kotlin[^01_1]\
        \ and has announced that all their APIs will be designed primarily for Kotlin[^01_2].\n\
        \nMore and more projects are now taking advantage of the fact that Kotlin\
        \ can be compiled for a few different platforms because this means that teams\
        \ can write code that runs on both Android and iOS, or on both the backend\
        \ and the frontend. Moreover, this cross-platform compatibility means that\
        \ library creators can create one library for multiple platforms at the same\
        \ time. Kotlinâ€™s multiplatform capabilities are already being used in many\
        \ companies, and they are getting more and more popular.\n\nIt is also worth\
        \ mentioning Jetpack Compose, which is a toolkit for building native UIs in\
        \ Kotlin. It was initially developed for Android, but it uses Kotlinâ€™s multiplatform\
        \ capabilities and can also be used to create views for websites, desktop\
        \ applications, iOS applications, and other targets[^01_3].\n\nA lot of developers\
        \ are using Kotlin for front-end development, mainly using React, and there\
        \ is also a growing community of data scientists using Kotlin.\n\nAs you can\
        \ see, there is already a lot that you can do in Kotlin, and there are more\
        \ and more possibilities as each year passes. I am sure you will find good\
        \ ways to apply your new knowledge once youâ€™ve finished reading this book.\n\
        \n[^01_1]: Source: techcrunch.com/2022/08/18/five-years-later-google-is-still-all-in-on-kotlin/\n\
        [^01_2]: Source: developer.android.com/kotlin/first\n[^01_3]: At the moment,\
        \ the maturity of these targets differs.\n[^01_4]: It will be explained in\
        \ the chapter *Data classes*."
          - type: "single-answer"
            stepId: "what-is-kotlin-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "what-is-kotlin-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "what-is-kotlin-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "what-is-kotlin-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "what-is-kotlin-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "first-program"
        name: "Your first program in Kotlin"
        steps:
          - type: "text"
            stepId: "first-program-introduction"
            question: "Your first program in Kotlin"
            explanation: "Introduction to Your first program in Kotlin"
            repetable: false
            text: "{sample: true}\n# Your first program in Kotlin\n\nThe first step in our\
        \ Kotlin adventure is to write a minimal program in this language. Yes, itâ€™\
        s the famous \"Hello, World!\" program. This is what it looks like in Kotlin:\n\
        \n```kotlin\nfun main() {\n    println(\"Hello, World\")\n}\n```\n\nThis is\
        \ minimal, isn't it? We need no classes (like we do in Java), no objects (like\
        \ `console` in JavaScript), and no conditions (like in Python when we start\
        \ code in the IDE). We need the `main` function and the `println` function\
        \ call with some text[^02_0].\n\nThis is the most popular (but not the only)\
        \ variant of the \"main\" function. If we need arguments, we might include\
        \ a parameter of type `Array<String>`:\n\n```kotlin\nfun main(args: Array<String>)\
        \ {\n    println(\"Hello, World\")\n}\n```\n\nThere are also other forms of\
        \ the `main` function:\n\n```kotlin\nfun main(vararg args: String) {\n   \
        \ println(\"Hello, World\")\n}\n```\n\n```kotlin\nclass Test {\n    companion\
        \ object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n\
        \            println(\"Hello, World\")\n        }\n    }\n}\n```\n\n```kotlin\n\
        suspend fun main() {\n    println(\"Hello, World\")\n}\n```\n\nAlthough these\
        \ are all valid, let's concentrate on the simple `main` function as we will\
        \ find it most useful. I will use it in nearly every example in this book.\
        \ Such examples are usually completely executable if you just copy-paste them\
        \ into IntelliJ or the Online Kotlin Playground[^02_2].\n\n```kotlin\nfun\
        \ main() {\n    println(\"Hello, World\")\n}\n```\n\nAll you need to do to\
        \ start the `main` function in IntelliJ is click the green triangle which\
        \ appears on the left side of the `main` function; this is called the \"gutter\
        \ icon\", also known as the \"Run\" button.\n\n![](main_run.png)"
          - type: "text"
            stepId: "first-program-section-1"
            question: "Live templates"
            explanation: "Content for Live templates"
            repetable: false
            text: "## Live templates\n\nIf you decide to test or practice the material from\
        \ this book[^02_3], you will likely be writing the `main` function quite often.\
        \ Here come *live templates* to help us. This is an IntelliJ feature that\
        \ suggests using a template when you start typing its name in a valid context.\
        \ So, if you start typing \"main\" or \"maina\" (for main with arguments)\
        \ in a Kotlin file, you will be shown a suggestion that offers the whole `main`\
        \ function.\n\n![](main_template.png)\n\nIn most my workshops, Iâ€™ve used this\
        \ template hundreds of times. Whenever I want to show something new with live\
        \ coding, I open a \"Playground\" file, select all its content (Ctrl/command\
        \ + A), type \"main\", confirm the live template with Enter, and I have a\
        \ perfect space for showing how Kotlin works.\n\nI also recommend you test\
        \ this now. Open any Kotlin project (it is best if you have a dedicated project\
        \ for playing with Kotlin), create a new file (you can name it \"Test\" or\
        \ \"Playground\"), and create the `main` function with the live template â€ś\
        mainaâ€ť. Use the `print` function with some text, and run the code with the\
        \ Run button."
          - type: "text"
            stepId: "first-program-section-2"
            question: "What is under the hood on JVM?"
            explanation: "Content for What is under the hood on JVM?"
            repetable: false
            text: "## What is under the hood on JVM?\n\nThe most important target for Kotlin\
        \ is JVM (Java Virtual Machine). On JVM, every element needs to be in a class.\
        \ So, you might be wondering how it is possible that our main function can\
        \ be started there if it is not in a class. Let's figure it out. On the way,\
        \ we will learn to find out what our Kotlin code would look like if it were\
        \ written in Java. This is Java developersâ€™ most powerful tool for learning\
        \ how Kotlin works.\n\nLet's start by opening or starting a Kotlin project\
        \ in IntelliJ or Android Studio. Make a new Kotlin file called \"Playground\"\
        . Inside this, use the live template \"maina\" to create the main function\
        \ with arguments and add `println(\"Hello, World\")` inside.\n\n```kotlin\n\
        fun main(args: Array<String>) {\n    println(\"Hello, World\")\n}\n```\n\n\
        Now, select from the tabs Tools > Kotlin > Show Kotlin Bytecode.\n\n![](tools_kotlin_show_bytecode.png)\n\
        \nOn the right side, a new tool should open. \"Show Kotlin Bytecode\" shows\
        \ the JVM bytecode generated from this file.\n\n![](show_kotlin_bytecode.png)\n\
        \nThis is a great place for everyone who likes reading JVM bytecode. Since\
        \ not everyone is Jake Wharton, most of us might find the \"Decompile\" button\
        \ useful. What it does is quite funny. Weâ€™ve just compiled our Kotlin code\
        \ into JVM bytecode, and this button decompiles this bytecode into Java. As\
        \ a result, we can see what our code would look like if it were written in\
        \ Java[^02_5].\n\n![](hello_world_decompiled.png)\n\nThis code reveals that\
        \ our `main` function on JVM becomes a static function inside a class named\
        \ `PlaygroundKt`. Where does this name come from? Try to guess. Yes, this\
        \ is, by default, the file's name with the \"Kt\" suffix. The same happens\
        \ to all other functions and properties defined outside of classes on JVM.\n\
        \nIf we wanted to call our `main` function from Java code, we can call `PlaygroundKt.main({})`.\n\
        \nThe name of `PlaygroundKt` can be changed by adding the `@file:JvmName(\"\
        NewName\")` annotation at the top of the file[^02_6]. However, this does not\
        \ change how elements defined in this file are used in Kotlin. It only influences\
        \ how we will use such functions from Java. For example, to call our `main`\
        \ function from Java now, we would need to call `NewName.main({})`.\n\nIf\
        \ you have experience with Java, remember this tool as it can help you to\
        \ understand:\n- How Kotlin code works on a low level.\n- How a certain Kotlin\
        \ feature works under the hood.\n- How to use a Kotlin element in Java.\n\n\
        There are proposals to make a similar tool to show JavaScript generated from\
        \ Kotlin code when our target is Kotlin/JS. However, at the time of writing\
        \ this book, the best you can do is to open the generated files yourself."
          - type: "text"
            stepId: "first-program-section-3"
            question: "Packages and importing"
            explanation: "Content for Packages and importing"
            repetable: false
            text: "## Packages and importing\n\nWhen our project has more than one file,\
        \ we need to use packages to organize them. Packages are a way to group files\
        \ together and avoid name conflicts. \n\nA file can specify package at the\
        \ top of the file using the `package` keyword.\n\n```kotlin\npackage com.marcinmoskala.domain.model\n\
        \nclass User(val name: String)\n```\n\nIf we don't specify a package, the\
        \ file is in the default package. In real projects, it is recommended that\
        \ package path should be the same as the directory path in our source files.\
        \ Package can also include company domain in reverse order, like `com.marcinmoskala`.\
        \ We name package using lowercase characters only. \n\nIf we want to use a\
        \ function or class from another package, we need to import it. Imports are\
        \ declared after the package declaration and before file elements'[^02_7]\
        \ declaration. They first specify the package name, then the name of the element.\
        \ We can also use the `*` character to import all elements from a package.\n\
        \n```kotlin\npackage com.marcinmoskala.domain\n\nimport com.marcinmoskala.domain.model.User\n\
        // or \nimport com.marcinmoskala.domain.model.*\n\nfun useUser() {\n    val\
        \ user = User(\"Marcin\")\n    // ...\n}\n```\n\nEssential elements from Kotlin\
        \ and Java strandard libraries are imported by default. For example, we can\
        \ use `println` function without importing it. \n\nKotlin's developers rarely\
        \ think about imports, because IntelliJ manage them automatically. When you\
        \ use an element using IntelliJ suggestion, it will automatically add an import\
        \ for you. If you use an element that is not imported, IntelliJ will suggest\
        \ importing it. If you want to remove unused imports, you can use the \"Remove\
        \ unused imports\" action (Ctrl/command + Alt + O). That is also why I decided\
        \ to not show imports in most of the examples in this book."
          - type: "text"
            stepId: "first-program-section-4"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nWe've learned about using `main` functions and creating\
        \ them easily with live templates. Weâ€™ve also learned how to find out what\
        \ our Kotlin code would look like if it were written in Java. For me, it seems\
        \ like we have quite a nice toolbox for starting our adventure. So, without\
        \ further ado, let's get on with that.\n\n[^02_0]: The `println` function\
        \ is implicitly imported from the standard library package `kotlin.io`.\n\
        [^02_2]: You can also find some chapters of this book online on the Kt. Academy\
        \ website. These examples can be started and modified thanks to the Kotlin\
        \ Playground feature.\n[^02_3]: It makes me happy when people try to challenge\
        \ what I am teaching. Be skeptical, and verify what you've learned; this is\
        \ a great way to learn something new and deepen your understanding.\n[^02_5]:\
        \ This doesnâ€™t always work because the decompiler is not perfect, but it is\
        \ really helpful anyway.\n[^02_6]: More about this in the book *Advanced Kotlin*,\
        \ chapter *Kotlin and Java interoperability*.\n[^02_7]: By elements in the\
        \ context of Kotlin programming we mean classes, functions, properties, object,\
        \ interfaces, etc. We will discuss all element types in the following chapters."
          - type: "single-answer"
            stepId: "first-program-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "first-program-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "first-program-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "first-program-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "first-program-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "variables"
        name: "Variables"
        steps:
          - type: "text"
            stepId: "variables-introduction"
            question: "Variables"
            explanation: "Introduction to Variables"
            repetable: false
            text: "# Variables\n\nTo declare a variable in Kotlin, we start with the `val`\
        \ or `var` keyword, then a variable name, the equality sign, and an initial\
        \ value.\n* The keyword `var` (which stands for \"variable\") represents *read-write\
        \ variables* and is used to define variables whose values can be reassigned\
        \ after initialization. This means that if you use `var`, you can always assign\
        \ a new value to this variable.\n* The keyword `val` (which stands for \"\
        value\") represents *read-only variables* and is used to define values that\
        \ cannot be reassigned. This means that if you use `val`, you cannot assign\
        \ a new value to this variable once it is initialized.\n\n```kotlin\nfun main()\
        \ {\n    val a = 10\n    var b = \"ABC\"\n    println(a) // 10\n    println(b)\
        \ // ABC\n    // a = 12 is not possible, because a is read-only!\n    b =\
        \ \"CDE\"\n    println(b) // CDE\n}\n```\n\nWe can name variables using characters,\
        \ underscore `_`, and numbers (but numbers are not allowed at the first position).\
        \ By convention, we name variables with the camelCase convention; this means\
        \ the variable name starts with a lowercase letter, then (instead of using\
        \ spaces) each next word starts with a capital letter.\n\n{width: 50%}\n![In\
        \ Kotlin, we name variables using camelCase.](camelCase.png)\n\nVariables\
        \ donâ€™t need to specify their type explicitly, but this doesn't mean that\
        \ variables are not typed. Kotlin is a statically typed language, therefore\
        \ every variable needs its type specified. The point is that Kotlin is smart\
        \ enough to infer the type from the value that is set. `10` is of type `Int`,\
        \ so the type of `a` in the above example is `Int`. `\"ABC\"` is of type `String`,\
        \ so the type of `b` is `String`.\n\n{width: 60%}\n![](104_inference.png)\n\
        \nWe can also specify a variable type explicitly using a colon and a type\
        \ **after** the variable name.\n\n```kotlin\nfun main() {\n   val a: Int =\
        \ 10\n   var b: String = \"ABC\"\n   println(a) // 10\n   println(b) // ABC\n\
        \   b = \"CDE\"\n   println(b) // CDE\n}\n```\n\nWhen we initialize a variable,\
        \ we should give it a value. As in the example below, a variableâ€™s definition\
        \ and initialization can be separated if Kotlin can be sure that the variable\
        \ wonâ€™t be used before any value is set. I suggest avoiding this practice\
        \ when itâ€™s not necessary.\n\n```kotlin\nfun main() {\n    val a: Int\n  \
        \  a = 10\n    println(a) // 10\n}\n```\n\nWe can assume that a variable should\
        \ normally be initialized by using an equality sign after its declaration\
        \ (like in `val a = 10`). So, what can stand on the right side of the assignment?\
        \ It can be any expression, i.e., a piece of code that returns a value. Here\
        \ are the most common types of expressions in Kotlin:\n* a basic type literal,\
        \ like `1` or `\"ABC\"`[^03_2],\n* a conditional statement used as an expression,\
        \ like if-expression, when-expression, or try-catch expression[^03_3].\n*\
        \ a constructor call[^03_4],\n* a function call[^03_5],\n* an object expression\
        \ or an object declaration[^03_6],\n* a function literal, like a lambda expression,\
        \ an anonymous function, or a function reference[^03_7],\n* an element reference[^03_8].\n\
        \nWe have a lot to discuss, so let's start with basic type literals.\n\n[^03_2]:\
        \ Basic types are covered in the next chapter.\n[^03_3]: Conditional statements\
        \ are covered in the chapter *Conditional statements*.\n[^03_4]: Constructors\
        \ are covered in the chapter *Classes*\n[^03_5]: All functions in Kotlin declare\
        \ a result type, so they can all be used on the right side of a variable assignment.\
        \ Functions are covered in the chapter *Functions*.\n[^03_6]: Object expression\
        \ and object declaration are covered in the chapter *Objects*\n[^03_7]: All\
        \ the function literal types are covered in the book *Functional Kotlin* in\
        \ chapters *Anonymous functions*, *Lambda expressions*, and *Function references*.\n\
        [^03_8]: All the different kinds of element references are covered in the\
        \ book *Advanced Kotlin*, in the chapter *Reflection*."
          - type: "single-answer"
            stepId: "variables-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "variables-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "variables-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "variables-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "variables-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "basic-values"
        name: "Basic types, their literals and operations"
        steps:
          - type: "text"
            stepId: "basic-values-introduction"
            question: "Basic types, their literals and operations"
            explanation: "Introduction to Basic types, their literals and operations"
            repetable: false
            text: "# Basic types, their literals and operations\n\nEvery language needs\
        \ a convenient way to represent basic kinds of values, like numbers or characters.\
        \ All languages need to have built-in **types** and **literals**. Types are\
        \ used to represent certain types of values. Some type examples are `Int`,\
        \ `Boolean`, or `String`. Literals are built-in notations that are used to\
        \ create instances. Some literal examples are a string literal, which is text\
        \ in quotation marks, or an integer literal, which is a bare number.\n\nIn\
        \ this chapter, weâ€™ll learn about the basic Kotlin types and their literals:\n\
        * numbers (`Int`, `Long`, `Double`, `Float`, `Short`, `Byte`),\n* booleans\
        \ (`Boolean`),\n* characters (`Char`),\n* strings (`String`).\n\nThere is\
        \ also the array primitive type in Kotlin, which will be covered in the chapter\
        \ *Collections*.\n\nIn Kotlin, all values are considered objects (there are\
        \ no primitive types), so they all have methods, and their types can be used\
        \ as generic type arguments (this will be covered later). Types that represent\
        \ numbers, booleans, and characters might be optimized by the Kotlin compiler\
        \ and used as primitives, but this optimization does not affect Kotlin developers,\
        \ therefore you donâ€™t need to even think about it.\n\nLet's start discussing\
        \ the basic types in Kotlin, one by one."
          - type: "text"
            stepId: "basic-values-section-1"
            question: "Numbers"
            explanation: "Content for Numbers"
            repetable: false
            text: "## Numbers\n\nIn Kotlin, there is a range of different types that are\
        \ used to represent numbers. They can be divided into those representing integer\
        \ numbers (without decimal points) and those representing floating-point numbers\
        \ (with decimal points). In these groups, the difference is in the number\
        \ of bits used to represent these numbers, which determines the possible number\
        \ size and precision.\n\nTo represent integer numbers, we use `Int`, `Long`,\
        \ `Byte`, and `Short`.\n\n| Type    | Size (bits) | Min value  | Max value\
        \     |\n|---------|-------------|------------|---------------|\n| `Byte`\
        \  | 8           | -128       | 127           |\n| `Short` | 16          |\
        \ -32768     | 32767         |\n| `Int`   | 32          | `-2^{31}`$ | `2^{31}\
        \ - 1`$ |\n| `Long`  | 64          | `-2^{63}`$ | `2^{63} - 1`$ |\n\nTo represent\
        \ floating-point numbers, we use `Float` and `Double`.\n\n| Type     | Size\
        \ (bits) | Significant bits | Exponent bits | Decimal digits |\n|----------|-------------|------------------|---------------|----------------|\n\
        | `Float`  | 32          | 24               | 8             | 6-7        \
        \    |\n| `Double` | 64          | 53               | 11            | 15-16\
        \          |\n\nA plain number without a decimal point is interpreted as an\
        \ `Int`. A plain number with a decimal point is interpreted as a `Double`.\n\
        \n![](05_int_double.png)\n\nYou can create `Long` by using the `L` suffix\
        \ after the number. `Long` is also used for number literals that are too big\
        \ for `Int`.\n\n![](05_long.png)\n\nSimilarly, you can create a `Float` by\
        \ ending a number with the `F` or `f` suffix.\n\n![](05_float.png)\n\nThere\
        \ is no suffix to create `Byte` or `Short` types. However, a number explicitly\
        \ typed as one of these types will create an instance of this type. This also\
        \ works for `Long`.\n\n```kotlin\nfun main() {\n    val b: Byte = 123\n  \
        \  val s: Short = 345\n    val l: Long = 345\n}\n```\n\nThis is not a conversion!\
        \ Kotlin does not support implicit type conversion, so you cannot use `Byte`\
        \ or `Long` where `Int` is expected.\n\n![](05_int_long_error.png)\n\nIf we\
        \ need to explicitly convert one number to another type, we use explicit conversion\
        \ functions like `toInt` or `toLong`.\n\n```kotlin\nfun main() {\n    val\
        \ b: Byte = 123\n    val l: Long = 123L\n    val i: Int = 123\n\n    val i1:\
        \ Int = b.toInt()\n    val i2: Int = l.toInt()\n    val l1: Long = b.toLong()\n\
        \    val l2: Long = i.toLong()\n}\n```\n\n### Underscores in numbers\n\nIn\
        \ number literals, we can use the underscore `_` between digits. This character\
        \ is ignored, but we sometimes use it to format long numbers for better readability.\n\
        \n```kotlin\nfun main() {\n    val million = 1_000_000\n    println(million)\
        \ // 1000000\n}\n```\n\n### Other numeral systems\n\nTo define a number using\
        \ the hexadecimal numeral system, start it with `0x`. To define a number using\
        \ the binary numeral system, start it with `0b`. The octal numeral system\
        \ is not supported.\n\n```kotlin\nfun main() {\n    val hexBytes = 0xA4_D6_FE_FE\n\
        \    println(hexBytes) // 2765553406\n    val bytes = 0b01010010_01101101_11101000_10010010\n\
        \    println(bytes) // 1382934674\n}\n```\n\n### `Number` and conversion functions\n\
        \nAll basic types that represent numbers are a subtype of the `Number` type.\n\
        \n```kotlin\nfun main() {\n    val i: Int = 123\n    val b: Byte = 123\n \
        \   val l: Long = 123L\n\n    val n1: Number = i\n    val n2: Number = b\n\
        \    val n3: Number = l\n}\n```\n\nThe `Number` type specifies transformation\
        \ functions: from the current number to any other basic type representing\
        \ a number.\n\n```kotlin\nabstract class Number {\n    abstract fun toDouble():\
        \ Double\n    abstract fun toFloat(): Float\n    abstract fun toLong(): Long\n\
        \    abstract fun toInt(): Int\n    abstract fun toChar(): Char\n    abstract\
        \ fun toShort(): Short\n    abstract fun toByte(): Byte\n}\n```\n\nThis means\
        \ that for each basic number you can transform it into a different basic number\
        \ using the `to{new type}` function. Such functions are known as *conversion\
        \ functions*.\n\n```kotlin\nfun main() {\n    val b: Byte = 123\n    val l:\
        \ Long = b.toLong()\n    val f: Float = l.toFloat()\n    val i: Int = f.toInt()\n\
        \    val d: Double = i.toDouble()\n    println(d) // 123.0\n}\n```\n\n###\
        \ Operations on numbers\n\nNumbers in Kotlin support the basic mathematical\
        \ operations:\n* addition (`+`),\n* subtraction (`-`),\n* multiplication (`*`),\n\
        * division (`/`).\n\n```kotlin\nfun main() {\n    val i1 = 12\n    val i2\
        \ = 34\n    println(i1 + i2) // 46\n    println(i1 - i2) // -22\n    println(i1\
        \ * i2) // 408\n    println(i1 / i2) // 0\n\n    val d1 = 1.4\n    val d2\
        \ = 2.5\n    println(d1 + d2) // 3.9\n    println(d1 - d2) // -1.1\n    println(d1\
        \ * d2) // 3.5\n    println(d1 / d2) // 0.5599999999999999\n}\n```\n\n> Notice,\
        \ that the correct result of `1.4 / 2.5` should be `0.56`, not `0.5599999999999999`.\
        \ This problem will be addressed soon. \n\nBeware that when we divide an `Int`\
        \ by an `Int`, the result is also `Int`, so the decimal part is lost.\n\n\
        ```kotlin\nfun main() {\n    println(5 / 2) // 2, not 2.5\n}\n```\n\nThe solution\
        \ is first to convert an integer into a floating-point representation and\
        \ then divide it.\n\n```kotlin\nfun main() {\n    println(5.toDouble() / 2)\
        \ // 2.5\n}\n```\n\nThere is also a remainder operator[^04_2] `%`:\n\n```kotlin\n\
        fun main() {\n    println(1 % 3) // 1\n    println(2 % 3) // 2\n    println(3\
        \ % 3) // 0\n    println(4 % 3) // 1\n    println(5 % 3) // 2\n    println(6\
        \ % 3) // 0\n    println(7 % 3) // 1\n    println(0 % 3) // 0\n    println(-1\
        \ % 3) // -1\n    println(-2 % 3) // -2\n    println(-3 % 3) // 0\n}\n```\n\
        \nKotlin also supports operations that modify a read-write variable `var`:\n\
        * `+=`, where `a += b` is the equivalent of `a = a + b`,\n* `-=`, where `a\
        \ -= b` is the equivalent of `a = a - b`,\n* `*=`, where `a *= b` is the equivalent\
        \ of `a = a * b`,\n* `/=`, where `a /= b` is the equivalent of `a = a / b`,\n\
        * `%=`, where `a %= b` is the equivalent of `a = a % b`,\n* post-incrementation\
        \ and pre-incrementation `++`, which increment variables value by `1`,\n*\
        \ post-decrementation and pre-decrementation `--`, which decrement variables\
        \ value by `1`.\n\n```kotlin\nfun main() {\n    var i = 1\n    println(i)\
        \ // 1\n    i += 10\n    println(i) // 11\n    i -= 5\n    println(i) // 6\n\
        \    i *= 3\n    println(i) // 18\n    i /= 2\n    println(i) // 9\n    i\
        \ %= 4\n    println(i) // 1\n\n    // Post-incrementation\n    // increments\
        \ value and returns the previous value\n    println(i++) // 1\n    println(i)\
        \ // 2\n\n    // Pre-incrementation\n    // increments value and returns the\
        \ new value\n    println(++i) // 3\n    println(i) // 3\n\n    // Post-decrementation\n\
        \    // decrements value and returns the previous value\n    println(i--)\
        \ // 3\n    println(i) // 2\n\n    // Pre-decrementation\n    // decrements\
        \ value and returns the new value\n    println(--i) // 1\n    println(i) //\
        \ 1\n}\n```\n\n### Operations on bits\n\nKotlin also supports operations on\
        \ bits using the following methods, which can be called using the infix notation\
        \ (so, between two values):\n* `and` keeps only bits that have `1` in the\
        \ same binary positions in both numbers.\n* `or` keeps only bits that have\
        \ `1` in the same binary positions in one or both numbers.\n* `xor` keeps\
        \ only bits that have exactly one `1` in the same binary positions in both\
        \ numbers.\n* `shl` shifts the left value left by the right number of bits.\n\
        * `shr` shifts the left value right by the right number of bits, filling the\
        \ leftmost bits with copies of the sign bit.\n* `ushr` shifts the left value\
        \ right by the right number of bits, filling the leftmost bits with zeros.\n\
        \n```kotlin\nfun main() {\n    println(0b0101 and 0b0001) // 1, that is 0b0001\n\
        \    println(0b0101 or 0b0001)  // 5, that is 0b0101\n    println(0b0101 xor\
        \ 0b0001) // 4, that is 0b0100\n    println(0b0101 shl 1) // 10, that is 0b1010\n\
        \    println(0b0101 shr 1) // 2,  that is 0b0010\n    println(0b0101 ushr\
        \ 1) // 2,  that is 0b0010\n}\n```\n\n### `BigDecimal` and `BigInteger`\n\n\
        All basic types in Kotlin have limited size and precision, which can lead\
        \ to imprecise or incorrect results in some situations.\n\n```kotlin\nfun\
        \ main() {\n    println(0.1 + 0.2) // 0.30000000000000004\n    println(2147483647\
        \ + 1) // -2147483648\n}\n```\n\nThis is a standard tradeoff in programming,\
        \ and in most cases we just need to accept it. However, there are cases where\
        \ we need to have perfect precision and unlimited number size. On JVM, for\
        \ unlimited number size we should use `BigInteger`, which represents a number\
        \ without a decimal part. For unlimited size and precision, we should use\
        \ the `BigDecimal`, which represents a number that has a decimal part. Both\
        \ can be created using constructors[^04_1], factory functions (like `valueOf`),\
        \ or a conversion from basic types that represent numbers (`toBigDecimal`\
        \ and `toBigInteger` methods).\n\n```kotlin\nimport java.math.BigDecimal\n\
        import java.math.BigInteger\n\nfun main() {\n    val i = 10\n    val l = 10L\n\
        \    val d = 10.0\n    val f = 10.0F\n\n    val bd1: BigDecimal = BigDecimal(123)\n\
        \    val bd2: BigDecimal = BigDecimal(\"123.00\")\n    val bd3: BigDecimal\
        \ = i.toBigDecimal()\n    val bd4: BigDecimal = l.toBigDecimal()\n    val\
        \ bd5: BigDecimal = d.toBigDecimal()\n    val bd6: BigDecimal = f.toBigDecimal()\n\
        \    val bi1: BigInteger = BigInteger.valueOf(123)\n    val bi2: BigInteger\
        \ = BigInteger(\"123\")\n    val bi3: BigInteger = i.toBigInteger()\n    val\
        \ bi4: BigInteger = l.toBigInteger()\n}\n```\n\n`BigDecimal` and `BigInteger`\
        \ also support basic mathematical operators:\n\n```kotlin\nimport java.math.BigDecimal\n\
        import java.math.BigInteger\n\nfun main() {\n    val bd1 = BigDecimal(\"1.2\"\
        )\n    val bd2 = BigDecimal(\"3.4\")\n    println(bd1 + bd2) // 4.6\n    println(bd1\
        \ - bd2) // -2.2\n    println(bd1 * bd2) // 4.08\n    println(bd1 / bd2) //\
        \ 0.4\n\n    val bi1 = BigInteger(\"12\")\n    val bi2 = BigInteger(\"34\"\
        )\n    println(bi1 + bi2) // 46\n    println(bi1 - bi2) // -22\n    println(bi1\
        \ * bi2) // 408\n    println(bi1 / bi2) // 0\n}\n```\n\nOn platforms other\
        \ than Kotlin/JVM, external libraries are needed to represent numbers with\
        \ unlimited size and precision."
          - type: "text"
            stepId: "basic-values-section-2"
            question: "Booleans"
            explanation: "Content for Booleans"
            repetable: false
            text: "## Booleans\n\nAnother basic type is `Boolean`, which has two possible\
        \ values: `true` and `false`.\n\n```kotlin\nfun main() {\n    val b1: Boolean\
        \ = true\n    println(b1) // true\n    val b2: Boolean = false\n    println(b2)\
        \ // false\n}\n```\n\nWe use booleans to express yes/no answers, like:\n*\
        \ Is the user an admin?\n* Has the user accepted the cookies policy?\n* Are\
        \ two numbers identical?\n\nIn practice, booleans are often a result of some\
        \ kind of comparison.\n\n### Equality\n\nA `Boolean` is often a result of\
        \ equality comparison. In Kotlin, we compare two objects for equality using\
        \ the double equality sign `==`. To check if two objects are not equal, we\
        \ use the non-equality sign `!=`.\n\n```kotlin\nfun main() {\n    println(10\
        \ == 10) // true\n    println(10 == 11) // false\n    println(10 != 10) //\
        \ false\n    println(10 != 11) // true\n}\n```\n\nNumbers and all objects\
        \ that are comparable (i.e., they implement the `Comparable` interface) can\
        \ also be compared with `>`, `<`, `>=`, and `<=`.\n\n```kotlin\nfun main()\
        \ {\n    println(10 > 10) // false\n    println(10 > 11) // false\n    println(11\
        \ > 10) // true\n\n    println(10 < 10) // false\n    println(10 < 11) //\
        \ true\n    println(11 < 10) // false\n\n    println(10 >= 10) // true\n \
        \   println(10 >= 11) // false\n    println(11 >= 10) // true\n\n    println(10\
        \ <= 10) // true\n    println(10 <= 11) // true\n    println(11 <= 10) //\
        \ false\n}\n```\n\n### Boolean operations\n\nThere are three basic logical\
        \ operators in Kotlin:\n* and `&&`, which returns `true` when the value on\
        \ both its sides is `true`; otherwise, it returns `false`.\n* or `||`, which\
        \ returns `true` when the value on either of its sides is `true`; otherwise,\
        \ it returns `false`.\n* not `!`, which turns `true` into `false`, and `false`\
        \ into `true`.\n\n```kotlin\nfun main() {\n    println(true && true) // true\n\
        \    println(true && false) // false\n    println(false && true) // false\n\
        \    println(false && false) // false\n\n    println(true || true) // true\n\
        \    println(true || false) // true\n    println(false || true) // true\n\
        \    println(false || false) // false\n\n    println(!true) // false\n   \
        \ println(!false) // true\n}\n```\n\nKotlin does not support any kind of automatic\
        \ conversion to `Boolean` (or any other type), so logical operators should\
        \ be used only with objects of type `Boolean`."
          - type: "text"
            stepId: "basic-values-section-3"
            question: "Characters"
            explanation: "Content for Characters"
            repetable: false
            text: "## Characters\n\nTo represent a single character, we use the `Char` type.\
        \ We specify a character using apostrophes.\n\n```kotlin\nfun main() {\n \
        \   println('A') // A\n    println('Z') // Z\n}\n```\n\nEach character is\
        \ represented as a Unicode number. To find out the Unicode of a character,\
        \ use the `code` property.\n\n```kotlin\nfun main() {\n    println('A'.code)\
        \ // 65\n}\n```\n\nKotlin accepts Unicode characters. To describe them by\
        \ their code, we start with `\\u`, and then we need to use hexadecimal format,\
        \ just like in Java.\n\n```kotlin\nfun main() {\n    println('\\u00A3') //\
        \ ÂŁ\n}\n```"
          - type: "text"
            stepId: "basic-values-section-4"
            question: "Strings"
            explanation: "Content for Strings"
            repetable: false
            text: "## Strings\n\nStrings are just sequences of characters that form a piece\
        \ of text. In Kotlin, we create a string using quotation marks `\"` or triple\
        \ quotation marks `\"\"\"`.\n\n```kotlin\nfun main() {\n    val text1 = \"\
        ABC\"\n    println(text1) // ABC\n    val text2 = \"\"\"DEF\"\"\"\n    println(text2)\
        \ // DEF\n}\n```\n\nA string wrapped in single quotation marks requires text\
        \ in a single line. If we want to define a newline character, we need to use\
        \ a special character `\\n`. This is not the only thing that needs (or might\
        \ need) a backslash to be expressed in a string.\n\n| Escape Sequence | Meaning\
        \               |\n|-----------------|-----------------------|\n| `\\t`  \
        \          | Tab                   |\n| `\\b`            | Backspace     \
        \        |\n| `\\r`            | Carriage return       |\n| `\\f`        \
        \    | Form feed             |\n| `\\n`            | Newline             \
        \  |\n| `\\'`            | Single quotation mark |\n| `\\\"`            |\
        \ Quotation mark        |\n| `\\\\`            | Backslash             |\n\
        | `\\$`            | Dollar                |\n\nStrings in triple quotation\
        \ marks can be multiline; in these strings, special characters can be used\
        \ directly, and forms prefixed by a backslash donâ€™t work.\n\n```kotlin\nfun\
        \ main() {\n    val text1 = \"Let\\'s say:\\n\\\"Hooray\\\"\"\n    println(text1)\n\
        \    // Let's say:\n    // \"Hooray\"\n    val text2 = \"\"\"Let\\'s say:\\\
        n\\\"Hooray\\\"\"\"\"\n    println(text2)\n    // Let\\'s say:\\n\\\"Hooray\\\
        \"\n    val text3 = \"\"\"Let's say:\n\"Hooray\"\"\"\"\n    println(text3)\n\
        \    // Let's say:\n    // \"Hooray\"\n}\n```\n\nTo better format triple quotation\
        \ mark strings, we use the `trimIndent` function, which ignores a constant\
        \ number of spaces for each line.\n\n```kotlin\nfun main() {\n    val text\
        \ = \"\"\"\n   Let's say:\n   \"Hooray\"\n   \"\"\".trimIndent()\n    println(text)\n\
        \    // Let's say:\n    // \"Hooray\"\n\n    val description = \"\"\"\n  \
        \    A\n      B\n          C\n  \"\"\".trimIndent()\n    println(description)\n\
        \    // A\n    // B\n    //     C\n}\n```\n\nString literals may contain template\
        \ expressions, which are pieces of code that are evaluated and whose results\
        \ are concatenated into a string. A template expression starts with a dollar\
        \ sign (`$`) and consists of either a variable name (like `\"text is $text\"\
        `) or an expression in curly braces (like `\"1 + 2 = ${1 + 2}\"`).\n\n```kotlin\n\
        fun main() {\n    val name = \"Cookie\"\n    val surname = \"DePies\"\n  \
        \  val age = 6\n\n    val fullName = \"$name $surname ($age)\"\n    println(fullName)\
        \ // Cookie DePies (6)\n\n    val fullNameUpper =\n        \"${name.uppercase()}\
        \ ${surname.uppercase()} ($age)\"\n    println(fullNameUpper) // COOKIE DEPIES\
        \ (6)\n\n    val description = \"\"\"\n       Name: $name\n       Surname:\
        \ $surname\n       Age: $age\n   \"\"\".trimIndent()\n    println(description)\n\
        \    // Name: Cookie\n    // Surname: DePies\n    // Age: 6\n}\n```\n\nIf\
        \ you need to use a special character inside a triple quotation mark string,\
        \ the easiest way is to specify it with a regular string and include it using\
        \ template syntax.\n\n```kotlin\nfun main() {\n    val text1 = \"\"\"ABC\\\
        nDEF\"\"\"\n    println(text1) // ABC\\nDEF\n    val text2 = \"\"\"ABC${\"\
        \\n\"}DEF\"\"\"\n    println(text2)\n    // ABC\n    // DEF\n}\n```\n\nIn\
        \ Kotlin strings, we use Unicode, so we can also define a Unicode character\
        \ using a number that starts with `\\u`, and then specifying a Unicode character\
        \ code in hexadecimal syntax.\n\n![](unicode.png)\n\nYou can use `+` operator\
        \ to concatenate two strings, so to create a new string that is a combination\
        \ of two other strings. You can also use this operator to concatenate a string\
        \ with any other object, which will be converted to a string. The result is\
        \ always a string. \n\n```kotlin\nfun main() {\n    val text1 = \"ABC\"\n\
        \    val text2 = \"DEF\"\n    println(text1 + text2) // ABCDEF\n    println(text1\
        \ + 123) // ABC123\n    println(text1 + true) // ABCtrue\n}\n```"
          - type: "text"
            stepId: "basic-values-section-5"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nIn this chapter, we've learned about the basic Kotlin types\
        \ and the literals we use to create them:\n* Numbers that are represented\
        \ by types `Int`, `Long`, `Double`, `Float`, `Short`, and `Byte` are created\
        \ with bare number values with possible suffixes for type customization. We\
        \ can define negative numbers or decimal parts. We can also use underscores\
        \ for nicer number formatting.\n* Boolean values `true` and `false` are represented\
        \ by the `Boolean` type.\n* Characters, which are represented by the `Char`\
        \ type. We define a character value using single quotation marks.\n* Strings,\
        \ which are used to represent text, are represented by the `String` type.\
        \ Each string is just a series of characters. We define strings inside double\
        \ quotation marks.\n\nSo, we have the foundations for using Kotlin. Let's\
        \ move on to more-complicated control structures that determine how our code\
        \ behaves.\n\n[^04_1]: Constructors will be covered in the chapter *Classes*.\n\
        [^04_2]: This operator is similar to modulo. Both the remainder and the modulo\
        \ operations act the same for positive numbers but differently for negative\
        \ numbers. The result of -5 remainder 4 is -1 because -5 = 4 * (-1) + (-1).\
        \ The result of -5 modulo 4 is 3 because -5 = 4 * (-2) + 3."
          - type: "single-answer"
            stepId: "basic-values-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "basic-values-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "basic-values-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "basic-values-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "basic-values-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "conditional-statements"
        name: "Conditional statements"
        steps:
          - type: "text"
            stepId: "conditional-statements-introduction"
            question: "Conditional statements"
            explanation: "Introduction to Conditional statements"
            repetable: false
            text: "# Conditional statements\n\nMost conditional statements, like the if-condition\
        \ or the while-loop[^05_0], look the same in Kotlin, Java, C++, JavaScript,\
        \ and most other modern languages. For instance, the if-statement is indistinguishable\
        \ in all these languages:\n\n```kotlin\nif (predicate) {\n    // body\n}\n\
        ```\n\nHowever, the if-condition in Kotlin is more powerful and has capabilities\
        \ that Kotlin's predecessors donâ€™t support. I assume that readers of this\
        \ book have general experience in programming, so I will concentrate on the\
        \ differences that Kotlin has introduced compared to other programming languages."
          - type: "text"
            stepId: "conditional-statements-section-1"
            question: "if-statement"
            explanation: "Content for if-statement"
            repetable: false
            text: "## if-statement\n\nLet's start with the aforementioned if-statement.\
        \ It executes its body when its condition is satisfied (returns `true`). We\
        \ can additionally add the `else` block, which is executed when the condition\
        \ is not satisfied (returns `false`).\n\n```kotlin\nfun main() {\n    val\
        \ i = 1 // or 5\n    if (i < 3) { // i < 3 is used as a condition\n      \
        \  // will be executed when condition returns true\n        println(\"Smaller\"\
        )\n    } else {\n        // will be executed when condition returns false\n\
        \        println(\"Bigger\")\n    }\n    // Prints Smaller if i == 1, or Bigger\
        \ if i == 5\n}\n```\n\nOne of Kotlinâ€™s superpowers is that an if-else statement\
        \ can be used as an expression[^05_1], therefore it produces a value.\n\n\
        ```kotlin\nval value = if (condition) {\n    // body 1\n} else {\n    // body\
        \ 2\n}\n```\n\nWhat value is returned? For each body block, it is the result\
        \ of the last statement (or `Unit` for an empty body or a statement that is\
        \ not an expression[^05_2]).\n\n```kotlin\nfun main() {\n    var isOne = true\n\
        \    val number1: Int = if (isOne) 1 else 0\n    println(number1) // 1\n \
        \   isOne = false\n    val number2: Int = if (isOne) 1 else 0\n    println(number2)\
        \ // 0\n\n    val superuser = true\n    val hasAccess: Boolean = if (superuser)\
        \ {\n        println(\"Good morning, sir Admin\")\n        true\n    } else\
        \ {\n        false\n    }\n    println(hasAccess) // true\n}\n```\n\nWhen\
        \ a body has only one statement, its result is the result of our if-else expression.\
        \ In such a case, we donâ€™t need brackets.\n\n```kotlin\nval r: Int = if (one)\
        \ 1 else 0\n// a more readable alternative to\nval r: Int = if (one) {\n \
        \   1\n} else {\n    0\n}\n```\n\nThis way of using an if-statement is a Kotlin\
        \ alternative to the Java or JavaScript ternary operator.\n\n```\n// Java\n\
        final String name = user == null ? \"\" : user.name\n// JavaScript\nconst\
        \ name = user === null ? \"\" : user.name\n```\n\n```kotlin\n// Kotlin\nval\
        \ name = if (user == null) \"\" else user.name\n```\n\nIt should be said that\
        \ if-else is longer than the ternary operator syntax. I believe this is the\
        \ main reason why some developers want ternary operator syntax introduced\
        \ in Kotlin. However, I am against this as if-else is a good replacement that\
        \ is more readable and can be better formatted. Moreover, we have some additional\
        \ Kotlin tools, which are also replacements for some ternary-operator use\
        \ cases: the Elvis operator, extensions on nullable types (like `orEmpty`),\
        \ or safe-calls. All these will be explained in detail in the chapter *Nullability*.\n\
        \n```\n// Java\nString name = user == null ? \"\" : user.name\n\n// Kotlin\n\
        val name = user?.name ?: \"\"\n// or\nval name = user?.name.orEmpty()\n```\n\
        \nNotice that if you use the so-called if-else-if statement, it is just multiple\
        \ connected if-else statements.\n\n```kotlin\nfun main() {\n    println(\"\
        Is it going to rain?\")\n    val probability = 70\n    if (probability < 40)\
        \ {\n        println(\"Na-ha\")\n    } else if (probability <= 80) {\n   \
        \     println(\"Likely\")\n    } else if (probability < 100) {\n        println(\"\
        Yes\")\n    } else {\n        println(\"Holly Crab\")\n    }\n}\n```\n\nThere\
        \ is actually no such thing as an if-else-if expression: it is just one if-else\
        \ expression inside another, as can be seen in strange cases where a method\
        \ is executed on a whole if-else-if expression. Just take a look at the following\
        \ puzzle and try to predict the result of this code.\n\n```kotlin\n// Function\
        \ we can execute on any object, to print it\n// 10.print() prints 10\n// \"\
        ABC\".print() prints ABC\nfun Any?.print() {\n    print(this)\n}\n\nfun printNumberSign(num:\
        \ Int) {\n    if (num < 0) {\n        \"negative\"\n    } else if (num > 0)\
        \ {\n        \"positive\"\n    } else {\n        \"zero\"\n    }.print()\n\
        }\n\nfun main(args: Array<String>) {\n    printNumberSign(-2)\n    print(\"\
        ,\")\n    printNumberSign(0)\n    print(\",\")\n    printNumberSign(2)\n}\n\
        ```\n\nThe answer is **not** \"negative,zero,positive\", because there is\
        \ no such thing as a single if-else-if expression (just two nested if-else\
        \ expressions). So, the above `printNumberSign` implementation gives the same\
        \ result as the following implementation.\n\n```kotlin\nfun printNumberSign(num:\
        \ Int) {\n    if (num < 0) {\n        \"negative\"\n    } else {\n       \
        \ if (num > 0) {\n            \"positive\"\n        } else {\n           \
        \ \"zero\"\n        }.print()\n    }\n}\n```\n\nSo, when we call `print` on\
        \ the result, it is called on the result of the second if-else expression\
        \ only (the one with \"positive\" and \"zero\"). This means that the code\
        \ above will print \",zero,positive\". How can we fix this? We might use a\
        \ bracket, but it is generally suggested that, instead of using if-else-if,\
        \ we should use a when-statement when there is more than one condition. This\
        \ can help avoid mistakes like the one in the puzzle above, and it makes code\
        \ clearer and easier to read.\n\n```kotlin\n// Function we can execute on\
        \ any object, to print it\n// 10.print() prints 10\n// \"ABC\".print() prints\
        \ ABC\nfun Any?.print() {\n    print(this)\n}\n\nfun printNumberSign(num:\
        \ Int) {\n    when {\n        num < 0 -> \"negative\"\n        num > 0 ->\
        \ \"positive\"\n        else -> \"zero\"\n    }.print()\n}\n\nfun main(args:\
        \ Array<String>) {\n    printNumberSign(-2) // negative\n    print(\",\")\
        \ // ,\n    printNumberSign(0) // zero\n    print(\",\") // ,\n    printNumberSign(2)\
        \ // positive\n}\n```"
          - type: "text"
            stepId: "conditional-statements-section-2"
            question: "when-statement"
            explanation: "Content for when-statement"
            repetable: false
            text: "## when-statement\n\nThe when-statement is an alternative to if-else-if.\
        \ In every branch, we specify a predicate and the body that should be executed\
        \ if this predicate returns `true` (and previous predicates did not). So,\
        \ it works just like if-else-if but should be preferred because its syntax\
        \ is better suited for multiple conditions.\n\n```kotlin\nfun main() {\n \
        \   println(\"Is it going to rain?\")\n    val probability = 70\n    when\
        \ {\n        probability < 40 -> {\n            println(\"Na-ha\")\n     \
        \   }\n        probability <= 80 -> {\n            println(\"Likely\")\n \
        \       }\n        probability < 100 -> {\n            println(\"Yes\")\n\
        \        }\n        else -> {\n            println(\"Holly Crab\")\n     \
        \   }\n    }\n}\n```\n\nLike in an if-statement, braces are needed only for\
        \ bodies with more than one statement.\n\n```kotlin\nfun main() {\n    println(\"\
        Is it going to rain?\")\n    val probability = 70\n    when {\n        probability\
        \ < 40 -> println(\"Na-ha\")\n        probability <= 80 -> println(\"Likely\"\
        )\n        probability < 100 -> println(\"Yes\")\n        else -> println(\"\
        Holly Crab\")\n    }\n}\n```\n\nThe when-statement can also be used as an\
        \ expression because it can return a value. The result is the last expression\
        \ of the chosen branch, therefore the following example will print \"Likely\"\
        .\n\n```kotlin\nfun main() {\n    println(\"Is it going to rain?\")\n    val\
        \ probability = 70\n    val text = when {\n        probability < 40 -> \"\
        Na-ha\"\n        probability <= 80 -> \"Likely\"\n        probability < 100\
        \ -> \"Yes\"\n        else -> \"Holly Crab\"\n    }\n    println(text)\n}\n\
        ```\n\nThe when-statement is often used as an expression body[^05_3]:\n\n\
        ```kotlin\nprivate fun getEmailErrorId(email: String) = when {\n    email.isEmpty()\
        \ -> R.string.error_field_required\n    emailInvalid(email) -> R.string.error_invalid_email\n\
        \    else -> null\n}\n```"
          - type: "text"
            stepId: "conditional-statements-section-3"
            question: "when-statement with a value"
            explanation: "Content for when-statement with a value"
            repetable: false
            text: "## when-statement with a value\n\nThere is also another form of the when-statement.\
        \ If we add a value in brackets after the `when` keyword, then our when-statement\
        \ becomes an alternative to the switch-case. However, it is a much more powerful\
        \ alternative because it can not only compare values by equality, but it can\
        \ also check if an object is of some type (using `is`), or if an object contains\
        \ this value (using `in`). Each block can have multiple values we compare\
        \ against, separated with a comma.\n\n```kotlin\nprivate val magicNumbers\
        \ = listOf(7, 13)\n\nfun describe(a: Any?) {\n    when (a) {\n        null\
        \ -> println(\"Nothing\")\n        1, 2, 3 -> println(\"Small number\")\n\
        \        in magicNumbers -> println(\"Magic number\")\n        in 4..100 ->\
        \ println(\"Big number\")\n        is String -> println(\"This is just $a\"\
        )\n        is Long, is Int -> println(\"This is Int or Long\")\n        else\
        \ -> println(\"No idea, really\")\n    }\n}\n\nfun main() {\n    describe(null)\
        \ // Nothing\n    describe(1) // Small number\n    describe(3) // Small number\n\
        \    describe(7) // Magic number\n    describe(9) // Big number,\n    // because\
        \ 9 is in range from 4 to 100\n    describe(\"AAA\") // This is just AAA\n\
        \    describe(1L) // This is Int or Long\n    describe(-1) // This is Int\
        \ or Long\n    describe(1.0) // No idea, really,\n    // because 1.0 is Double\n\
        }\n```\n\nThe when-statement with a value can also be used as an expression\
        \ because it can produce a value:\n\n```kotlin\nprivate val magicNumbers =\
        \ listOf(7, 13)\n\nfun describe(a: Any?): String = when (a) {\n    null ->\
        \ \"Nothing\"\n    1, 2, 3 -> \"Small number\"\n    in magicNumbers -> \"\
        Magic number\"\n    in 4..100 -> \"Big number\"\n    is String -> \"This is\
        \ just $a\"\n    is Long, is Int -> \"This is Int or Long\"\n    else -> \"\
        No idea, really\"\n}\n\nfun main() {\n    println(describe(null)) // Nothing\n\
        \    println(describe(1)) // Small number\n    println(describe(3)) // Small\
        \ number\n    println(describe(7)) // Magic number\n    println(describe(9))\
        \ // Big number,\n    // because 9 is in range from 4 to 100\n    println(describe(\"\
        AAA\")) // This is just AAA\n    println(describe(1L)) // This is Int or Long\n\
        \    println(describe(-1)) // This is Int or Long\n    println(describe(1.0))\
        \ // No idea, really,\n    // because 1.0 is Double\n}\n```\n\nNote that if\
        \ we use a when-condition as an expression, its conditions must be exhaustive:\
        \ it should cover all possible branch conditions or provide an else branch,\
        \ as in the example above. If not all conditions are covered, a compiler error\
        \ is shown.\n\n> Kotlin does not support switch-case statements because we\
        \ use the when-statement instead.\n\nInside the â€śwhenâ€ť parentheses, where\
        \ we specify a value, we can also define a variable, and its value will be\
        \ used in each condition.\n\n```kotlin\nfun showUsers() =\n    when (val response\
        \ = requestUsers()) {\n        is Success -> showUsers(response.body)\n  \
        \      is HttpError -> showException(response.exception)\n    }\n```"
          - type: "text"
            stepId: "conditional-statements-section-4"
            question: "is check"
            explanation: "Content for is check"
            repetable: false
            text: "## is check\n\nSince we have already mentioned the `is` operator, let's\
        \ discuss it in a bit more depth. It checks if a value is of a certain type.\
        \ We know already that `123` is of type `Int`, and `\"ABC\"` is of type `String`.\
        \ Certainly, `123` is not of type `String`, and `\"ABC\"` is not of type `Int`.\
        \ We can confirm this using the `is` check.\n\n```kotlin\nfun main() {\n \
        \   println(123 is Int) // true\n    println(\"ABC\" is String) // true\n\
        \    println(123 is String) // false\n    println(\"ABC\" is Int) // false\n\
        }\n```\n\nNotice that `123` is an `Int`, but it is also a `Number`; the `is`\
        \ check returns `true` for both these types.\n\n```kotlin\nfun main() {\n\
        \    println(123 is Int) // true\n    println(123 is Number) // true\n   \
        \ println(3.14 is Double) // true\n    println(3.14 is Number) // true\n\n\
        \    println(123 is Double) // false\n    println(3.14 is Int) // false\n\
        }\n```\n\nWhen we want to check if a value **is not** of a certain type, we\
        \ can use `!is`; this is an equivalent of is-check, but its result value is\
        \ negated.\n\n```kotlin\nfun main() {\n    println(123 !is Int) // false\n\
        \    println(\"ABC\" !is String) // false\n    println(123 !is String) //\
        \ true\n    println(\"ABC\" !is Int) // true\n}\n```"
          - type: "text"
            stepId: "conditional-statements-section-5"
            question: "Explicit casting"
            explanation: "Content for Explicit casting"
            repetable: false
            text: "## Explicit casting\n\nYou can always use a value whose type is `Int`\
        \ as a `Number` because every `Int` is a `Number`. This process is known as\
        \ *up-casting* because we change the value type from lower (more specific)\
        \ to higher (less specific).\n\n```kotlin\nfun main() {\n    val i: Int =\
        \ 123\n    val l: Long = 123L\n    val d: Double = 3.14\n\n    var number:\
        \ Number = i // up-casting from Int to Number\n    number = l // up-casting\
        \ from Long to Number\n    number = d // up-casting from Double to Number\n\
        }\n```\n\nWe can implicitly cast from a lower type to a higher one, but not\
        \ the other way around. Every `Int` is a `Number`, but not every `Number`\
        \ is an `Int` because there are more subtypes of `Number`, including `Double`\
        \ or `Long`. This is why we cannot use `Number` where `Int` is expected. However,\
        \ sometimes we have a situation where we are certain that a value is of a\
        \ specified type, even though its supertype is used. Explicitly changing from\
        \ a higher type to a lower type is called *down-casting* and requires the\
        \ `as` operator in Kotlin.\n\n```kotlin\nvar i: Number = 123\n\nfun main()\
        \ {\n    val j = (i as Int) + 10\n    println(j) // 133\n}\n```\n\nIn general,\
        \ we avoid using `as` when not necessary because we consider it dangerous.\
        \ Consider the above example. What if someone changes `123` to `3.14`? Both\
        \ values are of type `Number`, so the code will compile without any problems\
        \ or warnings. But `3.14` is `Double` not `Int`, and casting is not possible;\
        \ therefore, the code above will break with a `ClassCastException` exception.\n\
        \n```kotlin\nvar i: Number = 3.14\n\nfun main() {\n    val j = (i as Int)\
        \ + 10 // RUNTIME ERROR!\n    println(j)\n}\n```\n\nThere are two ways to\
        \ deal with this. The first is to use one of many Kotlin alternatives to cast\
        \ our value safely. One example is using smart-casting, which will be described\
        \ in the next section. Another example is a conversion function, like the\
        \ `toInt` method, which transforms `Number` to `Int` (and possibly loses the\
        \ decimal part).\n\n```kotlin\nvar i: Number = 3.14\n\nfun main() {\n    val\
        \ j = i.toInt() + 10\n    println(j) // 13\n}\n```\n\nThe second option is\
        \ the `as?` operator, which, instead of throwing an exception, returns `null`\
        \ when casting is not possible. We will discuss handling nullable values later.\n\
        \n```kotlin\nvar n: Number = 123\n\nfun main() {\n    val i: Int? = n as?\
        \ Int\n    println(i) // 123\n    val d: Double? = n as? Double\n    println(d)\
        \ // null\n}\n```\n\nIn Kotlin, we consider `as?` a safer option than `as`,\
        \ but using both these operators too often is regarded as a code smell[^05_4].\
        \ Let's describe smart-casting, which is their popular alternative."
          - type: "text"
            stepId: "conditional-statements-section-6"
            question: "Smart-casting"
            explanation: "Content for Smart-casting"
            repetable: false
            text: "## Smart-casting\n\nKotlin has a powerful feature called smart-casting,\
        \ which allows automatic type casting when the compiler can be sure that a\
        \ variable is of a certain type. Take a look at the following example:\n\n\
        ```kotlin\nfun convertToInt(num: Number): Int =\n    if (num is Int) num \
        \ // the type of num here is Int\n    else num.toInt()\n```\n\nThe `convertToInt`\
        \ function converts an argument of type `Number` to `Int` in the following\
        \ way: if the argument is already of type `Int`, it is just returned; otherwise,\
        \ it is converted using the `toInt` method. Notice that for this code to compile,\
        \ the `num` inside the first body needs to be of type `Int`. In most languages,\
        \ it needs to be casted, but this happens automatically in Kotlin. Take a\
        \ look at another example:\n\n```kotlin\nfun lengthIfString(a: Any): Int {\n\
        \    if (a is String) {\n        return a.length // the type of a here is\
        \ String\n    }\n    return 0\n}\n```\n\nInside the if-condition predicate,\
        \ we checked if `a` is of type `String`. The body of this statement will only\
        \ be executed if the type check is successful. This is why `a` is of type\
        \ `String` inside this body, which is why we can check its length. Such a\
        \ conversion, from `Any` to `String`, is done implicitly by the Kotlin compiler.\
        \ This can happen only when Kotlin is sure that no other thread can change\
        \ our property, so when it is either a constant or a local variable. It will\
        \ not work for non-local `var` properties because, in such cases, there is\
        \ no guarantee that they have not been modified between check and usage (e.g.,\
        \ by another thread).\n\n```kotlin\nvar obj: Any = \"AAA\"\n\nfun main() {\n\
        \    if (obj is String) {\n        // println(obj.length) will not compile,\n\
        \        // because `obj` can be modified by some\n        // other thread,\
        \ so Kotlin cannot be sure,\n        // that at this point, is it still of\
        \ type String\n    }\n}\n```\n\nSmart-casting is often used together with\
        \ when-statements. When they are used together, they are sometimes referred\
        \ to as \"Kotlin type-safe pattern matching\" because they can nicely cover\
        \ the different possible types a value can be of. More examples will be presented\
        \ when we discuss the sealed modifier.\n\n```kotlin\nfun handleResponse(response:\
        \ Result<T>) {\n    when (response) {\n        is Success<*> -> showMessages(response.data)\
        \ \n        // response smart-casted to Success\n        is Failure -> showError(response.throwable)\n\
        \        // response smart-casted to Failure\n    }\n}\n```"
          - type: "text"
            stepId: "conditional-statements-section-7"
            question: "While and do-while statements"
            explanation: "Content for While and do-while statements"
            repetable: false
            text: "## While and do-while statements\n\nThe last important control structures\
        \ we need to mention are while and do-while statements. Both look and work\
        \ exactly the same as in Java, C++, and many other languages.\n\n```kotlin\n\
        fun main() {\n    var i = 1\n    // while-statement\n    while (i < 10) {\n\
        \        print(i)\n        i *= 2\n    }\n    // 1248\n\n    var j = 1\n \
        \   // do-while statement\n    do {\n        print(j)\n        j *= 2\n  \
        \  } while (j < 10)\n    // 1248\n}\n```\n\nI hope they donâ€™t need any more\
        \ explanation. When-statements and do-while-statements cannot be used as expressions.\
        \ I will only add that both while and do-while statements are rarely used\
        \ in Kotlin. Instead, we use collection or sequence processing functions,\
        \ which will be covered in the *Functional Kotlin* book. For instance, the\
        \ above code can be replaced with the following:\n\n```kotlin\nfun main()\
        \ {\n    generateSequence(1) { it * 2 }\n        .takeWhile { it < 10 }\n\
        \        .forEach(::print)\n    // 1248\n}\n```"
          - type: "text"
            stepId: "conditional-statements-section-8"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nAs you can see, Kotlin has introduced many powerful features\
        \ to conditional statements. The if-condition and when-condition can be used\
        \ as expressions. The when-statement is a more powerful alternative to if-else-if\
        \ or switch-case. Type checks with smart-casting are supported. All these\
        \ features make operating on nullable values both safe and pleasant, which\
        \ makes the `null` value our friend, not an enemy. Now, let's see what Kotlin\
        \ has changed in functions.\n\n[^05_0]: As I described in the introduction,\
        \ in this book, I decided to use a dash between â€śifâ€ť, â€śwhenâ€ť, â€śtryâ€ť, â€śwhileâ€ť\
        , â€śforâ€ť, and the word describing it, like â€śconditionâ€ť, â€śloopâ€ť, â€śstatementâ€ť\
        \ or â€śexpressionâ€ť. I do this to improve readability. So, I will write â€śif-conditionâ€ť\
        \ instead of â€śif conditionâ€ť. â€śifâ€ť and â€śwhenâ€ť are conditions; â€śwhileâ€ť and â€ś\
        forâ€ť are loops. All of them can be used as statements, but only â€śifâ€ť, â€śwhenâ€ť\
        \ and â€śtryâ€ť can be used as expressions. I decided not to use a dash after\
        \ â€śif-elseâ€ť or â€śif-else-ifâ€ť and their descriptor.\n[^05_1]: An expression\
        \ in programming is a part of code that returns a value.\n[^05_2]: `Unit`\
        \ is an object without special meaning. It reminds me of Javaâ€™s `Void`.\n\
        [^05_3]: An expression body is a special syntax to implement function bodies\
        \ with only one expression. This will be covered in the next chapter.\n[^05_4]:\
        \ I will use the term \"code smell\" to describe practices that are not explicitly\
        \ wrong but should generally be avoided."
          - type: "single-answer"
            stepId: "conditional-statements-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "conditional-statements-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "conditional-statements-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "conditional-statements-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "conditional-statements-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "functions"
        name: "Functions"
        steps:
          - type: "text"
            stepId: "functions-introduction"
            question: "Functions"
            explanation: "Introduction to Functions"
            repetable: false
            text: "{sample: true}\n# Functions\n\nWhen Andrey Breslav, the initial Kotlin\
        \ creator, was asked about his favourite feature during a discussion panel\
        \ at KotlinConf Amsterdam, he said it was functions[^06_1]. In the end, functions\
        \ are our programs' most important building blocks. If you look at real-life\
        \ applications, most of the code either defines or calls functions.\n\n![As\
        \ an example, I used a random class from the APKUpdater open-source project.\
        \ Notice that nearly every line either defines or calls a function.](06_example_app.png)\n\
        \nIn Kotlin, we define functions using the `fun` keyword. This is why we have\
        \ so much \"fun\" in Kotlin. With a bit of creativity, a function can consist\
        \ only of `fun`:\n\n```kotlin\nfun <Fun> `fun`(`fun`: Fun): Fun = `fun`\n\
        ```\n\n> This is the so-called *identity function*, a function that returns\
        \ its argument without any modifications. It has a generic type parameter\
        \ `Fun`, but this will be explained in the chapter *Generics*.\n\nBy convention,\
        \ we name functions using lower camelCase syntax[^06_0]. Formally, we can\
        \ use characters, underscore `_`, and numbers (but not at the first position),\
        \ but in general just characters should be used.\n\n{width: 50%}\n![In Kotlin,\
        \ we name functions with lowerCamelCase.](camelCase.png)\n\nThis is what a\
        \ typical function looks like:\n\n```kotlin\nfun square(x: Double): Double\
        \ {\n    return x * x\n}\n\nfun main() {\n    println(square(10.0)) // 100.0\n\
        }\n```\n\nNotice that the parameter type is specified after the variable name\
        \ and a colon, and the result type is specified after a colon inside the parameter\
        \ brackets. Such notation is typical of languages with powerful support for\
        \ type inference because it is easier to add or remove explicit type definitions.\n\
        \n```kotlin\nval a: Int = 123\n// easy to transform from or to\nval a = 123\n\
        \nfun add(a: Int, b: Int): Int = a + b\n\n// easy to transform from or to\n\
        fun add(a: Int, b: Int) = a + b\n```\n\nTo use a reserved keyword as a function\
        \ name (like `fun` or `when`), use backticks, as in the example below. When\
        \ a function has an illegal name, both its definition and calls require backticks.\n\
        \nAnother use case for backticks is naming unit-test functions so that they\
        \ can be described in plain English, as in the example below. This is not\
        \ standard practice, but it is still quite a popular practice that many teams\
        \ choose to adopt.\n\n```kotlin\nclass CartViewModelTests {\n    @Test\n \
        \   fun `should show error dialog when no items loaded`() {\n        ...\n\
        \    }\n}\n```"
          - type: "text"
            stepId: "functions-section-1"
            question: "Single-expression functions"
            explanation: "Content for Single-expression functions"
            repetable: false
            text: "## Single-expression functions\n\nMany functions in real-life projects\
        \ just have a single expression[^06_2], so they start and immediately use\
        \ the `return` keyword. The `square` function defined above is a great example.\
        \ For such functions, instead of defining the body with braces, we can use\
        \ the equality sign (`=`) and just specify the expression that calculates\
        \ the result without specifying `return`. This is *single-expression syntax*,\
        \ and functions that use it are called *single-expression functions*.\n\n\
        ```kotlin\nfun square(x: Double): Double = x * x\n\nfun main() {\n    println(square(10.0))\
        \ // 100.0\n}\n```\n\nAn expression can be more complicated and take multiple\
        \ lines. This is fine as long as its body is a single statement.\n\n```kotlin\n\
        fun findUsers(userFilter: UserFilter): List<User> =\n    userRepository\n\
        \        .getUsers()\n        .map { it.toDomain() }\n        .filter { userFilter.accepts(it)\
        \ }\n```\n\nWhen we use single-expression function syntax, we can infer the\
        \ result type. We donâ€™t need to, as explicit result type might still be useful\
        \ for safety and readability[^06_3], but we can.\n\n```kotlin\nfun square(x:\
        \ Double) = x * x\n\nfun main() {\n    println(square(10.0)) // 100.0\n}\n\
        ```"
          - type: "text"
            stepId: "functions-section-2"
            question: "Functions on all levels"
            explanation: "Content for Functions on all levels"
            repetable: false
            text: "## Functions on all levels\n\nKotlin allows us to define functions on\
        \ many levels, but this isnâ€™t very obvious as Java only allows functions inside\
        \ classes. In Kotlin, we can define:\n* functions in files outside any classes,\
        \ called **top-level functions**,\n* functions inside classes or objects,\
        \ called **member functions** (they are also called **methods**),\n* functions\
        \ inside functions, called **local functions** or **nested functions**.\n\n\
        ```kotlin\n// Top-level function\nfun double(i: Int) = i * 2\n\nclass A {\n\
        \    // Member function (method)\n    private fun triple(i: Int) = i * 3\n\
        \n    // Member function (method)\n    fun twelveTimes(i: Int): Int {\n  \
        \      // Local function\n        fun fourTimes() = double(double(i))\n  \
        \      return triple(fourTimes())\n    }\n}\n\n// Top-level function\nfun\
        \ main(args: Array<String>) {\n    double(1) // 2\n    A().twelveTimes(2)\
        \ // 24\n}\n```\n\nTop-level functions (defined outside classes) are often\
        \ used to define utils, small but useful functions that help us with development.\
        \ Top-level functions can be moved and split across files. In many cases,\
        \ top-level functions in Kotlin are better than static functions in Java.\
        \ Using them seems intuitive and convenient for developers.\n\nHowever, itâ€™\
        s a different story with local functions (defined inside functions). I often\
        \ see that developers lack the imagination to use them (due to lack of exposure\
        \ to them). Local functions are popular in JavaScript and Python, but thereâ€™\
        s nothing like this in Java. The power of local functions is that they can\
        \ directly access or modify local variables. They are used to extract repetitive\
        \ code inside a function that operates on local variables. Longer functions\
        \ should tell a \"story\", and local subroutines can wrap a block expression\
        \ in a descriptive name.\n\nTake a look at the below example, which presents\
        \ a function that validates a form. It checks conditions for the form fields.\
        \ If a condition is not matched, we should show an error and change the local\
        \ variable `isValid` to `false`, in which case we should not return from the\
        \ function because we want to check all the fields (we should not stop at\
        \ the first one that fails). This is an example of where a local function\
        \ can help us extract repetitive behavior.\n\n```kotlin\nfun validateForm()\
        \ {\n    var isValid = true\n    val errors = mutableListOf<String>()\n  \
        \  fun addError(view: FormView, error: String) {\n        view.error = error\n\
        \        errors += error\n        isValid = false\n    }\n\n    val email\
        \ = emailView.text\n    if (email.isBlank()) {\n        addError(emailView,\
        \ \"Email cannot be empty or blank\")\n    }\n\n    val pass = passView.text.trim()\n\
        \    if (pass.length < 3) {\n        addError(passView, \"Password too short\"\
        )\n    }\n\n    if (isValid) {\n        tryLogin(email, pass)\n    } else\
        \ {\n        showErrors(errors)\n    }\n}\n```"
          - type: "text"
            stepId: "functions-section-3"
            question: "Parameters and arguments"
            explanation: "Content for Parameters and arguments"
            repetable: false
            text: "## Parameters and arguments\n\nA variable defined as a part of a function\
        \ definition is called a **parameter**. The value that is passed when we call\
        \ a function is called an **argument**.\n\n```kotlin\nfun square(x: Double)\
        \ = x * x // x is a parameter\n\nfun main() {\n    println(square(10.0)) //\
        \ 10.0 is an argument\n    println(square(0.0)) // 0.0 is an argument\n}\n\
        ```\n\nIn Kotlin, parameters are read-only, so we cannot reassign their value.\n\
        \n```kotlin\nfun a(i: Int) {\n    i = i + 10 // ERROR\n    // ...\n}\n```\n\
        \nIf you need to modify a parameter variable, the only way is to shadow it\
        \ with a local variable that is mutable.\n\n```kotlin\nfun a(i: Int) {\n \
        \   var i = i + 10\n    // ...\n}\n```\n\nThis is possible but discouraged.\
        \ A parameter holds a value that was used as an argument, and this value should\
        \ not change. A local read-write variable represents a different concept and\
        \ should therefore have a different name."
          - type: "text"
            stepId: "functions-section-4"
            question: "`Unit` return type"
            explanation: "Content for `Unit` return type"
            repetable: false
            text: "## `Unit` return type\n\nIn Kotlin, all functions have a result type,\
        \ so every function call is an expression. When a type is not specified, the\
        \ default result type is `Unit`, and the default result value is the `Unit`\
        \ object.\n\n```kotlin\nfun someFunction() {}\n\nfun main() {\n    val res:\
        \ Unit = someFunction()\n    println(res) // kotlin.Unit\n}\n```\n\n`Unit`\
        \ is just a very simple object that is used as a placeholder when nothing\
        \ else is returned. When you specify a function without an explicit result\
        \ type, its result type will implicitly be `Unit`. When you define a function\
        \ without `return` in the last line, it is the same as using `return` with\
        \ no value. Using `return` with no value is the same as returning `Unit`.\n\
        \n```kotlin\nfun a() {}\n\n// the same as\nfun a(): Unit {}\n\n// the same\
        \ as\nfun a(): Unit {\n    return\n}\n\n// the same as\nfun a(): Unit {\n\
        \    return Unit\n}\n```"
          - type: "text"
            stepId: "functions-section-5"
            question: "Vararg parameters"
            explanation: "Content for Vararg parameters"
            repetable: false
            text: "## Vararg parameters\n\nEach parameter expects one argument, except for\
        \ parameters marked with the `vararg` modifier. Such parameters accept any\
        \ number of arguments.\n\n```kotlin\nfun a(vararg params: Int) {}\n\nfun main()\
        \ {\n    a()\n    a(1)\n    a(1, 2)\n    a(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\
        }\n```\n\nA good example of such a function is `listOf`, which produces a\
        \ list from values used as arguments.\n\n```kotlin\nfun main() {\n    println(listOf(1,\
        \ 3, 5, 6)) // [1, 3, 5, 6]\n    println(listOf(\"A\", \"B\", \"C\")) // [A,\
        \ B, C]\n}\n```\n\nThis means a vararg parameter holds a collection of values,\
        \ therefore it cannot have the type of a single object. So the vararg parameter\
        \ represents an array of the declared type, and we can iterate over arrays\
        \ using a for loop (which will be explained in more depth in the next chapter).\n\
        \n```kotlin\nfun concatenate(vararg strings: String): String {\n    // The\
        \ type of `strings` is Array<String>\n    var accumulator = \"\"\n    for\
        \ (s in strings) accumulator += s\n    return accumulator\n}\n\nfun sum(vararg\
        \ ints: Int): Int {\n    // The type of `ints` is IntArray\n    var accumulator\
        \ = 0\n    for (i in ints) accumulator += i\n    return accumulator\n}\n\n\
        fun main() {\n    println(concatenate()) //\n    println(concatenate(\"A\"\
        , \"B\")) // AB\n    println(sum()) // 0\n    println(sum(1, 2, 3)) // 6\n\
        }\n```\n\nWe will get back to vararg parameters in the chapter *Collections*,\
        \ in the section dedicated to arrays."
          - type: "text"
            stepId: "functions-section-6"
            question: "Named parameter syntax and default arguments"
            explanation: "Content for Named parameter syntax and default arguments"
            repetable: false
            text: "## Named parameter syntax and default arguments\n\nWhen we declare functions,\
        \ we often specify optional parameters. A good example is `joinToString`,\
        \ which transforms an iterable into a `String`. It can be used without any\
        \ arguments, or we might change its behavior with concrete arguments.\n\n\
        ```kotlin\nfun main() {\n    val list = listOf(1, 2, 3, 4)\n    println(list.joinToString())\
        \ // 1, 2, 3, 4\n    println(list.joinToString(separator = \"-\")) //  1-2-3-4\n\
        \    println(list.joinToString(limit = 2)) //  1, 2, ...\n}\n```\n\nMany more\
        \ functions in Kotlin use optional parametrization, but how is this done?\
        \ It is enough to place an equality sign after a parameter and then specify\
        \ the default value.\n\n```kotlin\nfun cheer(how: String = \"Hello,\", who:\
        \ String = \"World\") {\n    println(\"$how $who\")\n}\n\nfun main() {\n \
        \   cheer() // Hello, World\n    cheer(\"Hi\") // Hi World\n}\n```\n\nValues\
        \ specified this way are created on-demand when there is no parameter for\
        \ their position. This is not Python, therefore they are not stored statically,\
        \ which is why itâ€™s safe to use mutable values as default arguments.\n\n```kotlin\n\
        fun addOneAndPrint(list: MutableList<Int> = mutableListOf()) {\n    list.add(1)\n\
        \    println(list)\n}\n\nfun main() {\n    addOneAndPrint() // [1]\n    addOneAndPrint()\
        \ // [1]\n    addOneAndPrint() // [1]\n}\n```\n\n> In Python, the analogous\
        \ code would produce `[1]`, `[1, 1]`, and `[1, 1, 1]`.\n\nWhen we call a function,\
        \ we can specify an argumentâ€™s position by its parameter name, like in the\
        \ example below. This way, we can specify later optional positions without\
        \ specifying previous ones. This is called *named parameter syntax*.\n\n```kotlin\n\
        fun cheer(how: String = \"Hello,\", who: String = \"World\") {\n    print(\"\
        $how $who\")\n}\n\nfun main() {\n    cheer(who = \"Group\") // Hello, Group\n\
        }\n```\n\nNamed parameter syntax is very useful for improving our codeâ€™s readability.\
        \ When an argument's meaning is not clear, it is better to specify a parameter\
        \ name for it.\n\n```kotlin\nfun main() {\n    val list = listOf(1, 2, 3,\
        \ 4)\n    println(list.joinToString(\"-\")) // 1-2-3-4\n    // better\n  \
        \  println(list.joinToString(separator = \"-\")) //  1-2-3-4\n}\n```\n\nNaming\
        \ arguments also prevents mistakes that are a result of changing parameter\
        \ positions.\n\n```kotlin\nclass User(\n    val name: String,\n    val surname:\
        \ String,\n)\n\nval user = User(\n    name = \"Norbert\",\n    surname = \"\
        MoskaĹ‚a\",\n)\n```\n\nIn the above example, without named arguments a developer\
        \ might flip the `name` and `surname` positions; if named arguments were not\
        \ used here, this would lead to an incorrect name and surname in the object.\
        \ Named arguments protect us from such situations.\n\nIt is considered a good\
        \ practice to use the named arguments convention when we call functions with\
        \ many arguments, some of whose meanings might not be obvious to developers\
        \ reading our code in the future."
          - type: "text"
            stepId: "functions-section-7"
            question: "Function overloading"
            explanation: "Content for Function overloading"
            repetable: false
            text: "## Function overloading\n\nIn Kotlin, we can define functions with the\
        \ same name in the same scope (file or class) as long as they have different\
        \ parameter types or a different number of parameters. This is known as function\
        \ **overloading**. Kotlin decides which function to execute based on the types\
        \ of the specified arguments.\n\n```kotlin\nfun a(a: Any) = \"Any\"\nfun a(i:\
        \ Int) = \"Int\"\nfun a(l: Long) = \"Long\"\n\nfun main() {\n    println(a(1))\
        \ // Int\n    println(a(18L)) // Long\n    println(a(\"ABC\")) // Any\n}\n\
        ```\n\nA practical example of function overloading is providing multiple function\
        \ variants for user convenience.\n\n```kotlin\nimport java.math.BigDecimal\n\
        \nclass Money(val amount: BigDecimal, val currency: String)\n\nfun pln(amount:\
        \ BigDecimal) = Money(amount, \"PLN\")\nfun pln(amount: Int) = pln(amount.toBigDecimal())\n\
        fun pln(amount: Double) = pln(amount.toBigDecimal())\n```"
          - type: "text"
            stepId: "functions-section-8"
            question: "Infix syntax"
            explanation: "Content for Infix syntax"
            repetable: false
            text: "## Infix syntax\n\nMethods with a single parameter can use the `infix`\
        \ modifier, which allows a special kind of function call: without the dot\
        \ and the argument parentheses.\n\n```kotlin\nclass View\nclass ViewInteractor\
        \ {\n    infix fun clicks(view: View) { \n        // ...\n    }\n}\n\nfun\
        \ main() {\n    val aView = View()\n    val interactor = ViewInteractor()\n\
        \n    // regular notation\n    interactor.clicks(aView)\n    // infix notation\n\
        \    interactor clicks aView\n}\n```\n\nThis notation is used by some functions\
        \ from Kotlin stdlib (Standard Library), like the `and`, `or` and `xor` bitwise\
        \ operations on numbers (presented in the chapter *Basic types, their literals\
        \ and operations*).\n\n```kotlin\nfun main() {\n    // infix notation\n  \
        \  println(0b011 and 0b001) // 1, that is 0b001\n    println(0b011 or 0b001)\
        \ // 3, that is 0b011\n    println(0b011 xor 0b001) // 2, that is 0b010\n\n\
        \    // regular notation\n    println(0b011.and(0b001)) // 1, that is 0b001\n\
        \    println(0b011.or(0b001)) // 3, that is 0b011\n    println(0b011.xor(0b001))\
        \ // 2, that is 0b010\n}\n```\n\nInfix notation is only for our convenience.\
        \ It is an example of Kotlin syntactic sugar - syntax that is designed only\
        \ to make things easier to read or express.\n\n> Regarding the position of\
        \ operators or functions in relation to their operands or arguments, we use\
        \ three kinds of position types: prefix, infix, and postfix. Prefix notation\
        \ is when we place the operator or function **before** the operands or arguments[^06_8].\
        \ A good example is a plus or minus placed before a single number (like `+12`\
        \ or `-3.14`). One might argue that a top-level function call also uses prefix\
        \ notation because the function name comes before the arguments (like `maxOf(10,\
        \ 20)`). Infix notation is when we place the operator or function **between**\
        \ the operands or arguments[^06_6]. A good example is a plus or minus between\
        \ two numbers (like `1 + 2` or `10 - 7`). One might argue that a method call\
        \ with arguments also uses infix notation because the function name comes\
        \ between the receiver (the object we call this method on) and arguments (like\
        \ `account.add(money)`). In Kotlin, we use the term \"infix notation\" more\
        \ restrictively to reference the special notation we use for methods with\
        \ the `infix` modifier. Postfix notation is when we place the operator or\
        \ function **after** the operands or arguments[^06_7]. In modern programming,\
        \ postfix notation is practically not used anymore. One might argue that calling\
        \ a method with no arguments is postfix notation, as in `str.uppercase()`."
          - type: "text"
            stepId: "functions-section-9"
            question: "Function formatting"
            explanation: "Content for Function formatting"
            repetable: false
            text: "## Function formatting\n\nWhen a function declaration (name, parameters,\
        \ and result type) is too long to fit in a single line, we split it such that\
        \ every parameter definition is on a different line, and the beginning and\
        \ end of the function declaration are also on separate lines.\n\n```kotlin\n\
        fun veryLongFunction(\n    param1: Param1Type,\n    param2: Param2Type,\n\
        \    param3: Param3Type,\n): ResultType {\n    // body\n}\n```\n\nClasses\
        \ are formatted in the same way[^06_5]:\n\n```kotlin\nclass VeryLongClass(\n\
        \    val property1: Type1,\n    val property2: Type2,\n    val property3:\
        \ Type3,\n) : ParentClass(), Interface1, Interface2 {\n    // body\n}\n```\n\
        \nWhen a function call[^06_4] is too long, we format it similarly: each argument\
        \ is on a different line. However, there are exceptions to this rule, such\
        \ as keeping multiple vararg parameters on the same line.\n\n```kotlin\nfun\
        \ makeUser(\n    name: String,\n    surname: String,\n): User = User(\n  \
        \  name = name,\n    surname = surname,\n)\n\nclass User(\n    val name: String,\n\
        \    val surname: String,\n)\n\nfun main() {\n    val user = makeUser(\n \
        \       name = \"Norbert\",\n        surname = \"MoskaĹ‚a\",\n    )\n\n   \
        \ val characters = listOf(\n        \"A\", \"B\", \"C\", \"D\", \"E\", \"\
        F\", \"G\", \"H\", \"I\", \"J\",\n        \"K\", \"L\", \"M\", \"N\", \"O\"\
        , \"P\", \"R\", \"S\", \"T\", \"U\",\n        \"W\", \"X\", \"Y\", \"Z\",\n\
        \    )\n}\n```\n\nIn this book, the width of my lines is much smaller than\
        \ in regular projects, so I am forced to break lines much more often than\
        \ I would like to.\n\nNotice that when I specify arguments or parameters,\
        \ I sometimes add a comma at the end. This is a so-called **trailing comma**.\
        \ Such notation is optional.\n\n```kotlin\nfun printName(\n    name: String,\n\
        \    surname: String, // <- trailing comma\n) {\n    println(\"$name $surname\"\
        )\n}\n\nfun main() {\n    printName(\n        name = \"Norbert\",\n      \
        \  surname = \"MoskaĹ‚a\", // <- trailing comma\n    )\n}\n```\n\nI like using\
        \ trailing comma notation because it makes it easier to add another element\
        \ in the future. Without it, adding or removing an element requires not only\
        \ a new line but also an additional comma after the last element. This leads\
        \ to meaningless line modifications on Git, which makes it harder to read\
        \ what has actually changed in our project. Some developers donâ€™t like trailing\
        \ comma notation, which can sometimes lead to a holy war. Decide in your team\
        \ if you like it or not, and be consistent in your projects.\n\n![Adding a\
        \ parameter and an argument on git when a trailing comma is used.](trailing_comma_used.png)\n\
        \n![Adding a parameter and an argument on git when a trailing comma is not\
        \ used.](trailing_comma_not_used.png)"
          - type: "text"
            stepId: "functions-section-10"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nAs you can see, functions in Kotlin have a lot of powerful\
        \ features. Single-expression syntax makes simple functions shorter. Named\
        \ and default arguments help us improve safety and readability. The `Unit`\
        \ result type makes every function call an expression. Vararg parameters allow\
        \ any number of arguments to be used for one parameter position. Infix notation\
        \ introduces a more convenient way to call certain kinds of functions. Trailing\
        \ commas minimize the number of changes on git. All this is for our convenience.\
        \ For now though, let's move on to another topic: using a for-loop.\n\n[^06_0]:\
        \ This rule has some exceptions. For example, on Android, Jetpack Compose\
        \ functions should be named using UpperCamelCase by convention. Also, unit\
        \ tests are often named with full sentences inside braces.\n[^06_1]: Source:\
        \ youtu.be/heqjfkS4z2I?t=660\n[^06_2]: As a reminder, an expression is a part\
        \ of our code that returns a value.\n[^06_3]: See *Effective Kotlin* *Item\
        \ 14: Consider referencing receivers explicitly*\n[^06_4]: A constructor call\
        \ is also considered a function call in Kotlin.\n[^06_5]: We will discuss\
        \ classes later in this book, in the chapter *Classes and interfaces*.\n[^06_6]:\
        \ From the Latin word infixus, the past participle of infigere, which we might\
        \ translate as \"fixed in between\".\n[^06_7]: Made from the prefix \"post-\"\
        , which means \"after, behind\", and the word \"fix\", meaning \"fixed in\
        \ place\".\n[^06_8]: From the Latin word praefixus, which means \"fixed in\
        \ front\"."
          - type: "single-answer"
            stepId: "functions-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "functions-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "functions-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "functions-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "functions-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "for"
        name: "The power of the for-loop"
        steps:
          - type: "text"
            stepId: "for-introduction"
            question: "The power of the for-loop"
            explanation: "Introduction to The power of the for-loop"
            repetable: false
            text: "# The power of the for-loop\n\nIn Java and other older languages, a for-loop\
        \ typically has three parts: the first initializes the variable before the\
        \ loop starts; the second contains the condition for the execution of the\
        \ code block; the third is executed after the code block.\n\n```    \n// Java\n\
        for(int i=0; i < 5; i++){\n   System.out.println(i);\n}\n```\n\nHowever, this\
        \ is considered complicated and error-prone. Just consider a situation in\
        \ which someone uses `>` or `<=` instead of `<`. Such a small difference is\
        \ not easy to notice, but it essentially influences the behavior of this for-loop.\n\
        \nAs an alternative to this classic for-loop, many languages have introduced\
        \ a modern alternative for iterating over collections. This is why, in languages\
        \ like Java or JavaScript, there are two completely different kinds of for-loops,\
        \ both of which are defined with the same `for` keyword. Kotlin has simplified\
        \ this. In Kotlin, we have one universal for-loop that can be expressively\
        \ used to iterate over a collection, a map, a range of numbers, and much more.\n\
        \nIn general, a for-loop is used in Kotlin to iterate over something that\
        \ is iterable[^07_1].\n\n{width: 60%}\n![](for_described.jpg)\n\nWe can iterate\
        \ over lists or sets.\n\n```kotlin\nfun main() {\n    val list = listOf(\"\
        A\", \"B\", \"C\")\n    for (letter in list) {\n        print(letter)\n  \
        \  }\n\n    // Variable type can be explicit\n    for (str: String in setOf(\"\
        D\", \"E\", \"F\")) {\n        print(str)\n    }\n}\n// ABCDEF\n```\n\nWe\
        \ can also iterate over any other object as long as it contains the `iterator`\
        \ method with no parameters, plus the `Iterator` result type and the `operator`\
        \ modifier. The easiest way to define this operator method is to make your\
        \ class implement the `Iterable` interface (then you do not need to define\
        \ `operator` modifier yourself, as it is inherited from `Iterable`). In the\
        \ below example, we define a `Tree` class that implements `Iterable<String>`,\
        \ so we must override the `iterator` method, and we can iterate over an instance\
        \ of this class.\n\n```kotlin\nfun main() {\n    val tree = Tree(\n      \
        \  value = \"B\",\n        left = Tree(\"A\"),\n        right = Tree(\"D\"\
        , left = Tree(\"C\"))\n    )\n\n    for (value in tree) {\n        print(value)\
        \ // ABCD\n    }\n}\n\nclass Tree(\n    val value: String,\n    val left:\
        \ Tree? = null,\n    val right: Tree? = null,\n) : Iterable<String> {\n\n\
        \    override fun iterator(): Iterator<String> = iterator {\n        if (left\
        \ != null) yieldAll(left)\n        yield(value)\n        if (right != null)\
        \ yieldAll(right)\n    }\n}\n```\n\nThe inferred variable type of the variable\
        \ defined inside the for-loop comes from the `Iterable` type argument. When\
        \ we iterate over `Iterable<User>`, the inferred element type will be `User`.\
        \ When we iterate over `Iterable<Long?>`, the inferred element type will be\
        \ `Long?`. The same applies to all other types.\n\nThis mechanism, which relies\
        \ on `Iterable`, is really powerful and allows us to cover numerous use cases,\
        \ one of the most notable of which is the use of *ranges* to express progressions."
          - type: "text"
            stepId: "for-section-1"
            question: "Ranges"
            explanation: "Content for Ranges"
            repetable: false
            text: "## Ranges\n\nIn Kotlin, if you place two dots between two numbers, like\
        \ `1..5`, you create an `IntRange`. This class implements `Iterable<Int>`,\
        \ so we can use it in a for-loop:\n\n```kotlin\nfun main() {\n    for (i in\
        \ 1..5) {\n        print(i)\n    }\n}\n// 12345\n```\n\nThis solution is efficient\
        \ as well as convenient because the Kotlin compiler optimizes its performance\
        \ under the hood.\n\nRanges created with `..` include the last value (which\
        \ means they are **closed ranges**). If you want a range that stops before\
        \ the last value, use the `..<` operator or `until` infix function instead.\n\
        \n```kotlin\nfun main() {\n    for (i in 1..<5) {\n        print(i)\n    }\n\
        }\n// 1234\n```\n\n```kotlin\nfun main() {\n    for (i in 1 until 5) {\n \
        \       print(i)\n    }\n}\n// 1234\n```\n\nBoth `..` and `..<` start with\
        \ the value on their left and progress toward the right number in increments\
        \ of one. If you use a bigger number on the left, the result is an empty range.\n\
        \n```kotlin\nfun main() {\n    for (i in 5..1) {\n        print(i)\n    }\n\
        \    for (i in 5..<1) {\n        print(i)\n    }\n}\n// (nothing is printed)\n\
        ```\n\nIf you want to iterate in the other direction, from larger to smaller\
        \ numbers, use the `downTo` function.\n\n```kotlin\nfun main() {\n    for\
        \ (i in 5 downTo 1) {\n        print(i)\n    }\n}\n// 54321\n```\n\nThe default\
        \ step in all those cases is `1`. If you want to use a different step, you\
        \ should use the `step` infix function.\n\n```kotlin\nfun main() {\n    for\
        \ (i in 1..10 step 3) {\n        print(\"$i \")\n    }\n    println()\n  \
        \  for (i in 1..<10 step 3) {\n        print(\"$i \")\n    }\n    println()\n\
        \    for (i in 10 downTo 1 step 3) {\n        print(\"$i \")\n    }\n}\n//\
        \ 1 4 7 10 \n// 1 4 7 \n// 10 7 4 1 \n```"
          - type: "text"
            stepId: "for-section-2"
            question: "Break and continue"
            explanation: "Content for Break and continue"
            repetable: false
            text: "## Break and continue\n\nInside loops, we can use the `break` and `continue`\
        \ keywords:\n* `break` - terminates the nearest enclosing loop.\n* `continue`\
        \ - proceeds to the next step of the nearest enclosing loop.\n\n```kotlin\n\
        fun main() {\n    for (i in 1..5) {\n        if (i == 3) break\n        print(i)\n\
        \    }\n    // 12\n\n    println()\n\n    for (i in 1..5) {\n        if (i\
        \ == 3) continue\n        print(i)\n    }\n    // 1245\n}\n```\n\nBoth are\
        \ used rather rarely, and I had trouble finding even one real-life example\
        \ in the commercial projects I have co-created. I also assume that they are\
        \ well-known to developers whoâ€™ve come to Kotlin from older languages. This\
        \ is why I present these keywords so briefly."
          - type: "text"
            stepId: "for-section-3"
            question: "Use cases"
            explanation: "Content for Use cases"
            repetable: false
            text: "## Use cases\n\nDevelopers with experience in older languages often use\
        \ a for-loop where slightly more-modern alternatives should be used instead.\
        \ For instance, in some projects I can find a for-loop that is used to iterate\
        \ over elements with indices.\n\n```kotlin\nfun main() {\n    val names =\
        \ listOf(\"Alex\", \"Bob\", \"Celina\")\n\n    for (i in 0..<names.size) {\n\
        \        val name = names[i]\n        println(\"[$i] $name\")\n    }\n}\n\
        // [0] Alex\n// [1] Bob\n// [2] Celina\n```\n\nThis is not a good solution.\
        \ There are multiple ways to do this better in Kotlin.\n\nFirst, instead of\
        \ explicitly iterating over a range `0..<names.size`, we could use the `indices`\
        \ property, which returns a range of available indices.\n\n```kotlin\nfun\
        \ main() {\n    val names = listOf(\"Alex\", \"Bob\", \"Celina\")\n\n    for\
        \ (i in names.indices) {\n        val name = names[i]\n        println(\"\
        [$i] $name\")\n    }\n}\n// [0] Alex\n// [1] Bob\n// [2] Celina\n```\n\nSecond,\
        \ instead of iterating over indices and finding an element for each of them,\
        \ we could instead iterate over indexed values. We can create indexed values\
        \ using `withIndex` on iterable. Each indexed value includes both an index\
        \ and a value. Such objects can be destructured in a for-loop[^07_2].\n\n\
        ```kotlin\nfun main() {\n    val names = listOf(\"Alex\", \"Bob\", \"Celina\"\
        )\n\n    for ((i, name) in names.withIndex()) {\n        println(\"[$i] $name\"\
        )\n    }\n}\n// [0] Alex\n// [1] Bob\n// [2] Celina\n```\n\nThird, an even\
        \ better solution is to use `forEachIndexed`, which is explained in the next\
        \ book: *Functional Kotlin*.\n\n```kotlin\nfun main() {\n    val names = listOf(\"\
        Alex\", \"Bob\", \"Celina\")\n\n    names.forEachIndexed { i, name ->\n  \
        \      println(\"[$i] $name\")\n    }\n}\n// [0] Alex\n// [1] Bob\n// [2]\
        \ Celina\n```\n\nAnother popular use case is iterating over a map. Developers\
        \ with a Java background often do it this way:\n\n```kotlin\nfun main() {\n\
        \    val capitals = mapOf(\n        \"USA\" to \"Washington DC\",\n      \
        \  \"Poland\" to \"Warsaw\",\n        \"Ukraine\" to \"Kiev\"\n    )\n\n \
        \   for (entry in capitals.entries) {\n        println(\"The capital of ${entry.key}\
        \ is ${entry.value}\")\n    }\n}\n// The capital of USA is Washington DC\n\
        // The capital of Poland is Warsaw\n// The capital of Ukraine is Kiev\n```\n\
        \nThis can be improved by directly iterating over a map, so calling `entries`\
        \ is unnecessary. Also, we can destructure entries to better name the values.\n\
        \n```kotlin\nfun main() {\n    val capitals = mapOf(\n        \"USA\" to \"\
        Washington DC\",\n        \"Poland\" to \"Warsaw\",\n        \"Ukraine\" to\
        \ \"Kiev\"\n    )\n\n    for ((country, capital) in capitals) {\n        println(\"\
        The capital of $country is $capital\")\n    }\n}\n// The capital of USA is\
        \ Washington DC\n// The capital of Poland is Warsaw\n// The capital of Ukraine\
        \ is Kiev\n```\n\nWe can use `forEach` for a map.\n\n```kotlin\nfun main()\
        \ {\n    val capitals = mapOf(\n        \"USA\" to \"Washington DC\",\n  \
        \      \"Poland\" to \"Warsaw\",\n        \"Ukraine\" to \"Kiev\"\n    )\n\
        \n    capitals.forEach { (country, capital) ->\n        println(\"The capital\
        \ of $country is $capital\")\n    }\n}\n// The capital of USA is Washington\
        \ DC\n// The capital of Poland is Warsaw\n// The capital of Ukraine is Kiev\n\
        ```"
          - type: "text"
            stepId: "for-section-4"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nIn this chapter, we've learned about using the for-loop.\
        \ It is really simple and powerful in Kotlin, so itâ€™s worth knowing how it\
        \ works, even though itâ€™s not used very often (due to Kotlinâ€™s amazing functional\
        \ features, which are often used instead).\n\nNow, let's talk about one of\
        \ the most important Kotlin improvements over Java: good support for handling\
        \ nullability.\n\n[^07_1]: Has the `iterator` operator method.\n[^07_2]: Destructuring\
        \ will be explained in more depth in the *Data classes* chapter."
          - type: "single-answer"
            stepId: "for-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "for-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "for-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "for-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "for-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "nullability"
        name: "Nullability"
        steps:
          - type: "text"
            stepId: "nullability-introduction"
            question: "Nullability"
            explanation: "Introduction to Nullability"
            repetable: false
            text: "# Nullability\n\nKotlin started as a remedy to Java problems, and the\
        \ biggest problem in Java is nullability. In Java, like in many other languages,\
        \ every variable is nullable, so it might have the `null` value. Every call\
        \ on a `null` value leads to the famous `NullPointerException` (NPE). This\
        \ is the #1 exception in most Java projects[^08_0]. It is so common that it\
        \ is often referred to as â€śthe billion dollar mistakeâ€ť after the famous speech\
        \ by Sir Charles Antony Richard Hoare, where he said: â€śI call it my billion-dollar\
        \ mistake. It was the invention of the null reference in 1965â€¦ This has led\
        \ to innumerable errors, vulnerabilities, and system crashes, which have probably\
        \ caused a billion dollars of pain and damage in the last forty yearsâ€ť.\n\n\
        One of Kotlin's priorities was to solve this problem finally, and it achieved\
        \ this perfectly. The mechanisms introduced in Kotlin are so effective that\
        \ seeing `NullPointerException` thrown from Kotlin code is extremely rare.\
        \ The `null` value stopped being a problem, and Kotlin developers are no longer\
        \ scared of it. It has become our friend.\n\nSo, how does nullability work\
        \ in Kotlin? Everything is based on a few rules:\n\n1. Every property needs\
        \ to have an explicit value. There is no such thing as an implicit `null`\
        \ value.\n\n```kotlin\nvar person: Person // COMPILATION ERROR, \n// the property\
        \ needs to be initialized\n```\n\n2. A regular type does not accept the `null`\
        \ value.\n\n```kotlin\nvar person: Person = null // COMPILATION ERROR,\n//\
        \ Person is not a nullable type, and cannot be `null`\n```\n\n3. To specify\
        \ a nullable type, you need to end a regular type with a question mark (`?`).\n\
        \n```kotlin\nvar person: Person? = null // OK\n```\n\n4. Nullable values cannot\
        \ be used directly. They must be used safely or cast first (using one of the\
        \ tools presented later in this chapter).\n\n```kotlin\nperson.name // COMPILATION\
        \ ERROR,\n// person type is nullable, so we cannot use it directly\n```\n\n\
        Thanks to all these mechanisms, we always know what can be `null` and what\
        \ cannot. We use nullability only when we need it - when there is a reason\
        \ to. In such cases, users are forced to explicitly handle this nullability.\
        \ In all other cases, there is no need to do this. This is a perfect solution,\
        \ but good tools are needed to deal with nullability in a way thatâ€™s convenient\
        \ for developers.\n\nKotlin supports a variety of ways of using a nullable\
        \ value, including safe calls, not-null assertions, smart-casting, or the\
        \ Elvis operator. Let's discuss these one by one."
          - type: "text"
            stepId: "nullability-section-1"
            question: "Safe calls"
            explanation: "Content for Safe calls"
            repetable: false
            text: "## Safe calls\n\nThe simplest way to call a method or a property on a\
        \ nullable value is with a safe call, which is a question mark and a dot (`?.`)\
        \ instead of just a regular dot (`.`). Safe calls work as follows:\n* if a\
        \ value is `null`, it does nothing and returns `null`,\n* if a value is not\
        \ `null`, it works like a regular call.\n\n```kotlin\nclass User(val name:\
        \ String) {\n    fun cheer() {\n        println(\"Hello, my name is $name\"\
        )\n    }\n}\n\nvar user: User? = null\n\nfun main() {\n    user?.cheer() //\
        \ (does nothing)\n    println(user?.name) // null\n    user = User(\"Cookie\"\
        )\n    user?.cheer() // Hello, my name is Cookie\n    println(user?.name)\
        \ // Cookie\n}\n```\n\nNotice that the result of a safe call is always a nullable\
        \ type because a safe call returns `null` when it is called on a `null`. This\
        \ means that nullability propagates. If you need to find out the length of\
        \ a user's name, calling `user?.name.length` will not compile. Even though\
        \ `name` is not nullable, the result of `user?.name` is `String?`, so we need\
        \ to use a safe call again: `user?.name?.length`.\n\n```kotlin\nclass User(val\
        \ name: String) {\n    fun cheer() {\n        println(\"Hello, my name is\
        \ $name\")\n    }\n}\n\nvar user: User? = null\n\nfun main() {\n    // println(user?.name.length)\
        \ // ILLEGAL\n    println(user?.name?.length) // null\n    user = User(\"\
        Cookie\")\n    // println(user?.name.length) // ILLEGAL\n    println(user?.name?.length)\
        \ // 6\n}\n```"
          - type: "text"
            stepId: "nullability-section-2"
            question: "Not-null assertion"
            explanation: "Content for Not-null assertion"
            repetable: false
            text: "## Not-null assertion\n\nWhen we donâ€™t expect a `null` value, and we\
        \ want to throw an exception if one occurs, we can use the not-null assertion\
        \ `!!`.\n\n```kotlin\nclass User(val name: String) {\n    fun cheer() {\n\
        \        println(\"Hello, my name is $name\")\n    }\n}\n\nvar user: User?\
        \ = User(\"Cookie\")\n\nfun main() {\n    println(user!!.name.length) // 6\n\
        \    user = null\n    println(user!!.name.length) // throws NullPointerException\n\
        }\n```\n\nThis is not a very safe option because if we are wrong and a `null`\
        \ value is where we don't expect it, this leads to a `NullPointerException`.\
        \ Sometimes we want to throw an exception to ensure that there are no situations\
        \ where `null` is used, but we generally prefer to throw a more meaningful\
        \ exception[^08_4]. For this, the most popular options are:\n- `requireNotNull`,\
        \ which accepts a nullable value as an argument and throws `IllegalArgumentException`\
        \ if this value is null. Otherwise, it returns this value as non-nullable.\n\
        - `checkNotNull`, which accepts a nullable value as an argument and throws\
        \ `IllegalStateException` if this value is null. Otherwise, it returns this\
        \ value as non-nullable.\n\n```kotlin\nprivate val connections = ConcurrentHashMap<String,\
        \ Connection>()\n\nfun sendData(dataWrapped: Wrapper<Data>) {\n    val data\
        \ = requireNotNull(dataWrapped.data)\n    val connection = checkNotNull(connections[\"\
        db\"])\n    connection.send(data)\n}\n```"
          - type: "text"
            stepId: "nullability-section-3"
            question: "Smart-casting"
            explanation: "Content for Smart-casting"
            repetable: false
            text: "## Smart-casting\n\nSmart-casting also works for nullability. Therefore,\
        \ in the scope of a non-nullability check, a nullable type is cast to a non-nullable\
        \ type.\n\n```kotlin\nfun printLengthIfNotNull(str: String?) {\n    if (str\
        \ != null) {\n        println(str.length) // str smart-casted to String\n\
        \    }\n}\n```\n\nSmart-casting also works when we use `return` or `throw`\
        \ if a value is not `null`.\n\n```kotlin\nfun printLengthIfNotNull(str: String?)\
        \ {\n    if (str == null) return\n    println(str.length) // str smart-casted\
        \ to String\n}\n```\n\n```kotlin\nfun printLengthIfNotNullOrThrow(str: String?)\
        \ {\n    if (str == null) throw Error()\n    println(str.length) // str smart-casted\
        \ to String\n}\n```\n\nSmart-casting is quite smart and works in different\
        \ cases, such as after `&&` and `||` in logical expressions.\n\n```kotlin\n\
        fun printLengthIfNotNull(str: String?) {\n    if (str != null && str.length\
        \ > 0) {\n        // str in expression above smart-casted to String\n    \
        \    // ...\n    }\n}\n```\n\n```kotlin\nfun printLengthIfNotNull(str: String?)\
        \ {\n    if (str == null || str.length == 0) {\n        // str in expression\
        \ above smart-casted to String\n        // ...\n    }\n}\n```\n\n```kotlin\n\
        fun printLengthIfNotNullOrThrow(str: String?) {\n    requireNotNull(str) //\
        \ str smart-casted to String\n    println(str.length)\n}\n```\n\n> Smart-casting\
        \ works in the code above thanks to a feature called **contracts**, which\
        \ is explained in the book *Advanced Kotlin*."
          - type: "text"
            stepId: "nullability-section-4"
            question: "The Elvis operator"
            explanation: "Content for The Elvis operator"
            repetable: false
            text: "## The Elvis operator\n\nThe last special Kotlin feature that is used\
        \ to support nullability is the Elvis operator `?:`. Yes, it is a question\
        \ mark and a colon. It is called the Elvis operator because it looks like\
        \ Elvis Presley (with his characteristic hair), looking at us from behind\
        \ a wall, so we can only see his hair and eyes.\n\n![](elvis.png)\n\nIt is\
        \ placed between two values. If the value on the left side of the Elvis operator\
        \ is not `null`, we use the nullable value that results from the Elvis operator.\
        \ If the left side is `null`, then the right side is returned.\n\n```kotlin\n\
        fun main() {\n    println(\"A\" ?: \"B\") // A\n    println(null ?: \"B\"\
        ) // B\n    println(\"A\" ?: null) // A\n    println(null ?: null) // null\n\
        }\n```\n\nWe can use the Elvis operator to provide a default value for nullable\
        \ values.\n\n```kotlin\nclass User(val name: String)\n\nfun printName(user:\
        \ User?) {\n    val name: String = user?.name ?: \"default\"\n    println(name)\n\
        }\n\nfun main() {\n    printName(User(\"Cookie\")) // Cookie\n    printName(null)\
        \ // default\n}\n```"
          - type: "text"
            stepId: "nullability-section-5"
            question: "Extensions on nullable types"
            explanation: "Content for Extensions on nullable types"
            repetable: false
            text: "## Extensions on nullable types\n\nRegular functions cannot be called\
        \ on nullable variables. However, there is a special kind of function that\
        \ can be defined such that it can be called on nullable variables[^08_3].\
        \ Thanks to this, Kotlin stdlib defines the following functions that can be\
        \ called on `String?`:\n* `orEmpty` returns the value if it is not `null`.\
        \ Otherwise it returns an empty string.\n* `isNullOrEmpty` returns `true`\
        \ if the value is `null` or empty. Otherwise, it returns `false`.\n* `isNullOrBlank`\
        \ returns `true` if the value is `null` or blank. Otherwise, it returns `false`.\n\
        \n```kotlin\nfun check(str: String?) {\n    println(\"The value: \\\"$str\\\
        \"\")\n    println(\"The value or empty: \\\"${str.orEmpty()}\\\"\")\n   \
        \ println(\"Is it null or empty? \" + str.isNullOrEmpty())\n    println(\"\
        Is it null or blank? \" + str.isNullOrBlank())\n}\n\nfun main() {\n    check(\"\
        ABC\")\n    // The value: \"ABC\"\n    // The value or empty: \"ABC\"\n  \
        \  // Is it null or empty? false\n    // Is it null or blank? false\n    check(null)\n\
        \    // The value: \"null\"\n    // The value or empty: \"\"\n    // Is it\
        \ null or empty? true\n    // Is it null or blank? true\n    check(\"\")\n\
        \    // The value: \"\"\n    // The value or empty: \"\"\n    // Is it null\
        \ or empty? true\n    // Is it null or blank? true\n    check(\"       \"\
        )\n    // The value: \"       \"\n    // The value or empty: \"       \"\n\
        \    // Is it null or empty? false\n    // Is it null or blank? true\n}\n\
        ```\n\nKotlin stdlib also includes similar functions for nullable lists:\n\
        * `orEmpty` returns the value if it is not `null`. Otherwise, it returns an\
        \ empty list .\n* `isNullOrEmpty` returns `true`, returns `true` if the value\
        \ is `null` or empty. Otherwise, it returns `false`.\n\n```kotlin\nfun check(list:\
        \ List<Int>?) {\n    println(\"The list: \\\"$list\\\"\")\n    println(\"\
        The list or empty: \\\"${list.orEmpty()}\\\"\")\n    println(\"Is it null\
        \ or empty? \" + list.isNullOrEmpty())\n}\n\nfun main() {\n    check(listOf(1,\
        \ 2, 3))\n    // The list: \"[1, 2, 3]\"\n    // The list or empty: \"[1,\
        \ 2, 3]\"\n    // Is it null or empty? false\n    check(null)\n    // The\
        \ list: \"null\"\n    // The list or empty: \"[]\"\n    // Is it null or empty?\
        \ true\n    check(listOf())\n    // The list: \"[]\"\n    // The list or empty:\
        \ \"[]\"\n    // Is it null or empty? true\n}\n```\n\nThese functions help\
        \ us operate on nullable values."
          - type: "text"
            stepId: "nullability-section-6"
            question: "`null` is our friend"
            explanation: "Content for `null` is our friend"
            repetable: false
            text: "## `null` is our friend\n\nNullability was a source of pain in many languages\
        \ like Java, where every object can be nullable. As a result, people started\
        \ avoiding nullability. As a result, you can find suggestions like \"Item\
        \ 43. Return empty arrays or collections, not nulls\" from *Effective Java*\
        \ 2nd Edition by Joshua Bloch. Such practices make literally no sense in Kotlin,\
        \ where we have a proper nullability system and should not be worried about\
        \ `null` values. In Kotlin, we treat `null` as our friend, not as a mistake[^08_1].\
        \ Consider the `getUsers` function. There is an essential difference between\
        \ returning an empty list and `null`. An empty list should be interpreted\
        \ as \"the result is an empty list of users because none are available\".\
        \ The `null` result should be interpreted as \"could not produce the result,\
        \ and the list of users remains unknown\". Forget about outdated practices\
        \ regarding nullability. The `null` value is our friend in Kotlin[^08_2]."
          - type: "text"
            stepId: "nullability-section-7"
            question: "lateinit"
            explanation: "Content for lateinit"
            repetable: false
            text: "## lateinit\n\nThere are situations where we want to keep a property\
        \ type not nullable, and yet we cannot specify its value during object creation.\
        \ Consider properties whose value is injected by a dependency injection framework,\
        \ or consider properties that are created for every test in the setup phase.\
        \ Making such properties nullable would lead to inconvenient usage: you would\
        \ use a not-null assertion even though you know that the value cannot be `null`\
        \ because it will surely be initialized before usage. For such situations,\
        \ Kotlin creators introduced the `lateinit` property. Such properties have\
        \ non-nullable types, and cannot be initialized during creation.\n\n```kotlin\n\
        @AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    @Inject\n\
        \    lateinit var presenter: MainPresenter\n\n    override fun onCreate(savedInstanceState:\
        \ Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\
        \        presenter.onCreate()\n    }\n}\n\nclass UserServiceTest {\n    lateinit\
        \ var userRepository: InMemoryUserRepository\n    lateinit var userService:\
        \ UserService\n\n    @Before\n    fun setup() {\n        userRepository =\
        \ InMemoryUserRepository()\n        userService = UserService(userRepository)\n\
        \    }\n\n    @Test\n    fun `should register new user`() {\n        // when\n\
        \        userService.registerUser(aRegisterUserRequest)\n\n        // then\n\
        \        userRepository.hasUserId(aRegisterUserRequest.id)\n        // ...\n\
        \    }\n}\n```\n\nWhen we use a lateinit property, we must set its value before\
        \ its first use. If we don't, the program throws an `UninitializedPropertyAccessException`\
        \ at runtime.\n\n```kotlin\nlateinit var text: String\n\nfun main() {\n  \
        \  println(text) // RUNTIME ERROR!\n    // lateinit property text has not\
        \ been initialized\n}\n```\n\nYou can always check if a property has been\
        \ initialized using the `isInitialized` property on its reference. To reference\
        \ a property, use two colons and a property name[^08_5].\n\n```kotlin\nlateinit\
        \ var text: String\n\nprivate fun printIfInitialized() {\n    if (::text.isInitialized)\
        \ {\n        println(text)\n    } else {\n        println(\"Not initialized\"\
        )\n    }\n}\n\nfun main() {\n    printIfInitialized() // Not initialized\n\
        \    text = \"ABC\"\n    printIfInitialized() // ABC\n}\n```"
          - type: "text"
            stepId: "nullability-section-8"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nKotlin offers powerful nullability support that turns nullability\
        \ from scary and tricky into useful and safe. This is supported by the type\
        \ system, which separates what is nullable or not nullable. Variables that\
        \ are nullable must be used safely; for this, we can use safe-calls, not-null\
        \ assertions, smart-casting, or the Elvis operator. Now, let's finally move\
        \ on to classes. Weâ€™ve used them many times already, but we finally have everything\
        \ we need to describe them well.\n\n[^08_0]: Some research confirms this:\
        \ for example, data collected by OverOps confirms that `NullPointerException`\
        \ is the most common exception in 70% of production environments.  \n[^08_1]:\
        \ See the \"Null is your friend, not a mistake\" (link kt.academy/l/re-null)\
        \ article by Roman Elizarov, current Project Lead for the Kotlin Programming\
        \ Language.\n[^08_2]: There is more on using nullability in the book *Effective\
        \ Kotlin*.\n[^08_3]: These are extension functions, which we will discuss\
        \ in the chapter *Extensions*.\n[^08_4]: There is more about exceptions, `IllegalArgumentException`\
        \ and `IllegalStateException` in the chapter *Exceptions*.\n[^08_5]: To reference\
        \ a property from another object, we need to start with the object before\
        \ we use `::` and the property name. There is more about referencing properties\
        \ in the Advanced Kotlin book."
          - type: "single-answer"
            stepId: "nullability-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "nullability-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "nullability-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "nullability-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "nullability-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "classes"
        name: "Classes"
        steps:
          - type: "text"
            stepId: "classes-introduction"
            question: "Classes"
            explanation: "Introduction to Classes"
            repetable: false
            text: "# Classes\n\nTake a look at the world around you and you will likely\
        \ notice plenty of objects. It might be a book, an Ebook reader, a monitor,\
        \ or a mug of coffee. We are surrounded by objects. This idea leads to the\
        \ conclusion that we are living in a world of objects, therefore our programs\
        \ should be constructed in the same way. This is the conceptual basis of the\
        \ Object-Oriented Programming approach. Not everyone shares this worldview\
        \ - some prefer to see the world as a place of possible actions[^09_0], which\
        \ is the conceptual basis of the Functional Programming approach - but whichever\
        \ approach we prefer, classes and objects are important structures in Kotlin\
        \ programming.\n\nA class is a template that is used to create an object with\
        \ concrete characteristics. To create a class in Kotlin, we use the `class`\
        \ keyword followed by the name. This is literally all that is needed to create\
        \ the simplest class because a class body is optional. To create an object,\
        \ which is an instance of a class, we use the default constructor function,\
        \ which is the class name and round brackets. Unlike in other languages like\
        \ C++ or Java, we do not use the `new` keyword in Kotlin.\n\n```kotlin\n//\
        \ Simplest class definition\nclass A\n\nfun main() {\n    // Object creation\
        \ from a class\n    val a: A = A()\n}\n```"
          - type: "text"
            stepId: "classes-section-1"
            question: "Member functions"
            explanation: "Content for Member functions"
            repetable: false
            text: "## Member functions\n\nInside classes, we can define functions. To do\
        \ that, we first need to open braces in the class definition in order to specify\
        \ the class body.\n\n```kotlin\nclass A {\n    // class body\n}\n```\n\nThere,\
        \ we can specify functions. Functions defined this way have two important\
        \ characteristics:\n* Functions need to be called on an instance of this class.\
        \ This means that to call a method, an object needs to be created first.\n\
        * Inside methods, we can use `this`, which is a reference to the instance\
        \ of the class we called this function on.\n\n```kotlin\nclass A {\n    fun\
        \ printMe() {\n        println(this)\n    }\n}\n\nfun main() {\n    val a\
        \ = A()\n    println(a) // A@ADDRESS\n    a.printMe() // A@ADDRESS (the same\
        \ address)\n}\n```\n\nAll the elements defined inside a class body are called\
        \ **members**, so a function defined inside a class body is called a **member\
        \ function**. Functions that are associated with classes are called **methods**,\
        \ so all member functions are methods, but extension functions (which will\
        \ be covered in a later chapter) are methods too.\n\nConceptually speaking,\
        \ methods represent what an object can do. For instance, a coffee machine\
        \ should be able to produce coffee, which we might represent by the method\
        \ `makeCoffee` in the `CoffeeMachine` class. This is how classes with methods\
        \ help us model the world."
          - type: "text"
            stepId: "classes-section-2"
            question: "Properties"
            explanation: "Content for Properties"
            repetable: false
            text: "## Properties\n\nInside class bodies, we can also define variables. Variables\
        \ defined inside classes are called **fields**. There is an important idea\
        \ known as \"encapsulation\" which means that fields should never be used\
        \ directly from outside the class because if that happens, we lose control\
        \ over their state. Instead, fields should be used through accessors:\n* getter\
        \ - the function that is used to get the current value of this field,\n* setter\
        \ - the function that is used to set new values for this field.\n\nThis pattern\
        \ is highly influential; in Java projects, you can see plenty of getter and\
        \ setter functions, which are mainly used in classes that hold data. They\
        \ are needed to achieve encapsulation, but they are also disturbing boilerplate\
        \ code. So, language creators invented a more powerful concept called \"properties\"\
        . A **property** is a variable in a class that is automatically encapsulated\
        \ so that it uses a getter and a setter under the hood. In Kotlin, all variables\
        \ defined inside classes are properties, not fields.\n\nSome languages, like\
        \ JavaScript, have built-in support for properties, but Java does not. So,\
        \ in Kotlin/JVM, accessor functions are generated for each property: a getter\
        \ for `val`, and a getter and a setter for `var`.\n\n```kotlin\n// Kotlin\
        \ code\nclass User {\n    var name: String = \"\"\n}\n\nfun main(args: Array<String>)\
        \ {\n    val user = User()\n    user.name = \"Alex\" // setter call\n    println(user.name)\
        \ // getter call\n}\n```\n\n```javascript\n// equivalent JavaScript code\n\
        function User() {\n    this.name = '';\n}\n\nfunction main(args) {\n    var\
        \ user = new User();\n    user.name = 'Alex';\n    println(user.name);\n}\n\
        ```\n\n```java\n// equivalent Java code\npublic final class User {\n    @NotNull\n\
        \    private String name = \"\";\n\n    // getter\n    @NotNull\n    public\
        \ final String getName() {\n        return this.name;\n    }\n\n    // setter\n\
        \    public final void setName(@NotNull String name) {\n        this.name\
        \ = name;\n    }\n}\n\npublic final class PlaygroundKt {\n    public static\
        \ void main(String[] var0) {\n        User user = new User();\n        user.setName(\"\
        Alex\"); // setter call\n        System.out.println(user.getName()); // getter\
        \ call\n    }\n}\n```\n\nEach property in Kotlin has accessors, therefore\
        \ we should not define getters or setters using explicit functions. If you\
        \ want to change the default accessor, there is a special syntax for that.\n\
        \n```kotlin\nclass User {\n    private var name: String = \"\"\n\n    // DO\
        \ NOT DO THAT! DEFINE PROPERTY GETTER INSTEAD\n    fun getName() = name\n\n\
        \    // DO NOT DO THAT! DEFINE PROPERTY SETTER INSTEAD\n    fun setName(name:\
        \ String) {\n        this.name = name\n    }\n}\n```\n\nTo specify a custom\
        \ getter, we use the `get` keyword after the property definition. The rest\
        \ is equivalent to defining a function with no parameters. Inside this function,\
        \ we use the `field` keyword to reference the backing field. The default getter\
        \ returns the `field` value, but we can change this behavior so that this\
        \ value is modified in some way before it is returned. When we define a getter,\
        \ we can use single-expression syntax or a regular body and the `return` keyword.\n\
        \n```kotlin\nclass User {\n    var name: String = \"\"\n        get() = field.uppercase()\n\
        \    // or\n    // var name: String = \"\"\n    //     get() {\n    //   \
        \      return field.uppercase()\n    //     }\n}\n\nfun main() {\n    val\
        \ user = User()\n    user.name = \"norbert\"\n    println(user.name) // NORBERT\n\
        }\n```\n\nA getter must always have the same visibility and result type as\
        \ the property. Getters should not throw exceptions and should not perform\
        \ intensive calculations.\n\nBeware that all property usages are accessors'\
        \ usages. Inside accessors, you should use `field` instead of the property\
        \ name because, otherwise, you will likely end up with infinite recursion.\n\
        \n```kotlin\nclass User {\n    // DON'T DO THAT\n    var name: String = \"\
        \"\n        // Using property name inside getter\n        // leads to infinitive\
        \ recursion\n        get() = name.uppercase()\n}\n\nfun main() {\n    val\
        \ user = User()\n    user.name = \"norbert\"\n    println(user.name) // Error:\
        \ java.lang.StackOverflowError\n}\n```\n\nSetters can be specified similarly,\
        \ but we need to use the `set` keyword, and we need a single parameter that\
        \ represents the value that is set. The default setter is used to assign a\
        \ new value to the `field`, but we can modify this behavior, for instance,\
        \ to set a new value only if it satisfies some conditions.\n\n```kotlin\n\
        class User {\n    var name: String = \"\"\n        get() = field.uppercase()\n\
        \        set(value) {\n            if (value.isNotBlank()) {\n           \
        \     field = value\n            }\n        }\n}\n\nfun main() {\n    val\
        \ user = User()\n    user.name = \"norbert\"\n    user.name = \"\"\n    user.name\
        \ = \"  \"\n    println(user.name) // NORBERT\n}\n```\n\nSetters might have\
        \ more restrictive visibility than properties, which we will show in the next\
        \ chapter.\n\nIf a property's custom accessors do not use the `field` keyword,\
        \ then the backing field will not be generated. For example, we can define\
        \ a property to represent a full name that is calculated based on a name and\
        \ surname. This means that some properties might not need a field at all.\n\
        \n```kotlin\nclass User {\n    var name: String = \"\"\n    var surname: String\
        \ = \"\"\n    val fullName: String\n        get() = \"$name $surname\"\n}\n\
        \nfun main() {\n    val user = User()\n    user.name = \"Maja\"\n    user.surname\
        \ = \"MoskaĹ‚a\"\n    println(user.fullName) // Maja MoskaĹ‚a\n}\n```\n\nThe\
        \ `fullName` property needs only a getter because it is a read-only `val`\
        \ property. Whenever we ask for this propertyâ€™s value, a full name will be\
        \ calculated based on the `name` and `surname`. Notice that this property\
        \ is calculated on demand, which is an advantage over using a regular property.\n\
        \n```kotlin\nclass User(\n    var name: String,\n    var surname: String,\n\
        ) {\n    val fullName1: String\n        get() = \"$name $surname\"\n    val\
        \ fullName2: String = \"$name $surname\"\n}\n\nfun main() {\n    val user\
        \ = User(\"Maja\", \"Markiewicz\")\n    println(user.fullName1) // Maja Markiewicz\n\
        \    println(user.fullName2) // Maja Markiewicz\n    user.surname = \"MoskaĹ‚\
        a\"\n    println(user.fullName1) // Maja MoskaĹ‚a\n    println(user.fullName2)\
        \ // Maja Markiewicz\n}\n```\n\nThis difference is only visible when the values\
        \ our property is based on are mutable; therefore, when we define an immutable\
        \ object, either calculating the property value on the getter or during class\
        \ creation should both produce the same result. The difference is in performance:\
        \ we calculate constant property values during object creation, but getter\
        \ values are calculated on demand every time they are asked for.\n\n```kotlin\n\
        class Holder {\n    val v1: Int get() = calculate(\"v1\")\n    val v2: Int\
        \ = calculate(\"v2\")\n\n    private fun calculate(propertyName: String):\
        \ Int {\n        println(\"Calculating $propertyName\")\n        return 42\n\
        \    }\n}\n\nfun main() {\n    val h1 = Holder() // Calculating v2\n    //\
        \ h1 never used v1, so it was never calculated\n    // it calculated v2 even\
        \ though it was not used either\n    val h2 = Holder() // Calculating v2\n\
        \    println(h2.v1) // Calculating v1 and 42\n    println(h2.v1) // Calculating\
        \ v1 and 42\n    println(h2.v2) // 42\n    println(h2.v2) // 42\n    // h2\
        \ used v1 two times, and it was calculated two times, it \n    // calculated\
        \ v2 only once, even though it was used two times.\n}\n```\n\nAs another example,\
        \ let's imagine we need to keep the user's birthdate. Initially, we represented\
        \ it with `Date` from the Java Standard Library.\n\n```kotlin\nimport java.util.Date\n\
        \nclass User {\n    // ...\n    var birthdate: Date? = null\n}\n```\n\nTime\
        \ has passed, and `Date` is no longer a good way to represent this attribute.\
        \ Maybe we have problems with serialization; maybe we need to make our object\
        \ multiplatform; or maybe we need to represent time in another calendar not\
        \ supported by `Date`. So, weâ€™ve decided to use a different type instead of\
        \ `Date`. Let's say that weâ€™ve decided to use a `Long` property to keep milliseconds,\
        \ but we cannot get rid of the previous property because it is used by many\
        \ other parts of our code. To have our cake and eat it, we can transform our\
        \ `birthdate` property to fully depend on the new representation. This way,\
        \ we have changed how the birthdate is represented without changing the previous\
        \ usage.\n\n```kotlin\nclass User {\n    // ...\n    var birthdateMillis:\
        \ Long? = null\n\n    var birthdate: Date?\n        get() {\n            val\
        \ millis = birthdateMillis\n            return if (millis == null) null else\
        \ Date(millis)\n        }\n        set(value) {\n            birthdateMillis\
        \ = value?.time\n        }\n}\n```\n\n> In the above getter, I use `let` and\
        \ a constructor reference. Both these Kotlin features are explained in the\
        \ book **Functional Kotlin**.\n\nSuch a `birthdate` property can also be defined\
        \ as an extension function, which will be presented in the chapter *Extensions*."
          - type: "text"
            stepId: "classes-section-3"
            question: "Constructors"
            explanation: "Content for Constructors"
            repetable: false
            text: "## Constructors\n\nWhen we create an object, we often want to initialize\
        \ it with specific values. This is what we use constructors for. As we've\
        \ seen already, when no constructors are specified, an empty default constructor\
        \ is generated with no parameters.\n\n```kotlin\nclass A\n\nval a = A()\n\
        ```\n\nTo specify our custom constructor, the classic way is to use the `constructor`\
        \ keyword inside the class body, and then we define its parameters and body.\n\
        \n```kotlin\nclass User {\n    var name: String = \"\"\n    var surname: String\
        \ = \"\"\n\n    constructor(name: String, surname: String) {\n        this.name\
        \ = name\n        this.surname = surname\n    }\n}\n\nfun main() {\n    val\
        \ user = User(\"Johnny\", \"Depp\")\n    println(user.name) // Johnny\n  \
        \  println(user.surname) // Depp\n}\n```\n\nConstructors are typically used\
        \ to set initial values of our properties. To simplify this, Kotlin introduced\
        \ a special kind of constructor called the **primary constructor**. It is\
        \ defined just after the class name, and its parameters can be used during\
        \ the initialization of properties.\n\n```kotlin\nclass User constructor(name:\
        \ String, surname: String) {\n    var name: String = name\n    var surname:\
        \ String = surname\n}\n\nfun main() {\n    val user = User(\"Johnny\", \"\
        Depp\")\n    println(user.name) // Johnny\n    println(user.surname) // Depp\n\
        }\n```\n\nWhen we specify a primary constructor, use of the `constructor`\
        \ keyword is optional, so we can just skip it.\n\n```kotlin\nclass User(name:\
        \ String, surname: String) {\n    var name: String = name\n    var surname:\
        \ String = surname\n}\n\nfun main() {\n    val user = User(\"Johnny\", \"\
        Depp\")\n    println(user.name) // Johnny\n    println(user.surname) // Depp\n\
        }\n```\n\nThere can be only one primary constructor. We can define another\
        \ constructor, called **secondary constructor**, but it needs to call the\
        \ primary constructor using the `this` keyword.\n\n```kotlin\nclass User(name:\
        \ String, surname: String) {\n    var name: String = name\n    var surname:\
        \ String = surname\n\n    // Secondary constructor\n    constructor(user:\
        \ User) : this(user.name, user.surname) {\n        // optional body\n    }\n\
        }\n\nfun main() {\n    val user = User(\"Johnny\", \"Depp\")\n    println(user.name)\
        \ // Johnny\n    println(user.surname) // Depp\n\n    val user2 = User(user)\n\
        \    println(user2.name) // Johnny\n    println(user2.surname) // Depp\n}\n\
        ```\n\nThe primary constructor is typically used to specify initial values\
        \ for our properties. These properties often have the same names as other\
        \ parameters, so Kotlin introduced better support for this: we can define\
        \ properties inside the primary constructor. Such properties define a class\
        \ property and a constructor parameter, both of which have the same name.\n\
        \n```kotlin\nclass User(\n    var name: String,\n    var surname: String,\n\
        ) {\n    // optional body\n}\n\nfun main() {\n    val user = User(\"Johnny\"\
        , \"Depp\")\n    println(user.name) // Johnny\n    println(user.surname) //\
        \ Depp\n}\n```\n\nThis is how the vast majority of Kotlin classes are defined:\
        \ using a primary constructor with properties. We rarely use other kinds of\
        \ constructors.\n\nWe often define primary constructors with default values.\
        \ Here, we create an instance of `User` without providing the `surname` argument,\
        \ so the default value we specified will be used during `User` creation.\n\
        \n```kotlin\nclass User(\n    var name: String = \"\",\n    var surname: String\
        \ = \"Anonim\",\n)\n\nfun main() {\n    val user = User(\"Johnny\")\n    println(user.name)\
        \ // Johnny\n    println(user.surname) // Anonim\n}\n```"
          - type: "text"
            stepId: "classes-section-4"
            question: "Classes representing data in Kotlin and Java"
            explanation: "Content for Classes representing data in Kotlin and Java"
            repetable: false
            text: "## Classes representing data in Kotlin and Java\n\nWhen comparing classes\
        \ defined in Kotlin and Java, we can see how much boilerplate code Kotlin\
        \ has eliminated. In Java, to represent a simple user, with a name, surname,\
        \ and age, the typical implementation looks as follows:\n\n```java\npublic\
        \ final class User {\n    @NotNull\n    private final String name;\n    @NotNull\n\
        \    private final String surname;\n    private final int age;\n\n    public\
        \ User(\n        @NotNull String name,\n        @NotNull String surname,\n\
        \        int age\n    ) {\n        this.name = name;\n        this.surname\
        \ = surname;\n        this.age = age;\n    }\n\n    @NotNull\n    public String\
        \ getName() {\n        return name;\n    }\n\n    @NotNull\n    public String\
        \ getSurname() {\n        return surname;\n    }\n\n    public int getAge()\
        \ {\n        return age;\n    }\n}\n```\n\nIn Kotlin, we represent the same\
        \ class in the following way:\n\n```kotlin\nclass User(\n    val name: String,\n\
        \    val surname: String,\n    val age: Int?,\n)\n```\n\nThe result of the\
        \ compilation is practically the same. Getters and constructors are there.\
        \ If you donâ€™t believe it, check it yourself (as presented in the *What is\
        \ under the hood on JVM?* section in the *Your first program in Kotlin* chapter).\
        \ Kotlin is a concise but powerful language."
          - type: "text"
            stepId: "classes-section-5"
            question: "Inner classes"
            explanation: "Content for Inner classes"
            repetable: false
            text: "## Inner classes\n\nIn Kotlin, we can define classes inside classes.\
        \ They are static by default, which means that they do not have access to\
        \ outer classes, therefore they can be created without a reference to an outer\
        \ class.\n\n```kotlin\nclass Puppy(val name: String) {\n\n    class InnerPuppy\
        \ {\n        fun think() {\n            // we have no access to name here\n\
        \            println(\"Inner puppy is thinking\")\n        }\n    }\n}\n\n\
        fun main() {\n    val innerPuppy = Puppy.InnerPuppy()\n    // We create InnerPuppy\
        \ on class, not object\n    innerPuppy.think() // Inner puppy is thinking\n\
        }\n```\n\nIf you want your inner class to have a reference to its outer class,\
        \ you need to make it inner using the `inner` modifier. However, creating\
        \ objects from such classes requires an instance of the outer class.\n\n```kotlin\n\
        class Puppy(val name: String) {\n\n    inner class InnerPuppy {\n        fun\
        \ think() {\n            println(\"Inner $name is thinking\")\n        }\n\
        \    }\n}\n\nfun main() {\n    val puppy = Puppy(\"Cookie\")\n    val innerPuppy\
        \ = puppy.InnerPuppy() // We need puppy\n    innerPuppy.think() // Inner Cookie\
        \ is thinking\n}\n```\n\nExamples of inner classes in the standard library\
        \ are:\n* private implementations of iterators;\n* classes, where there is\
        \ a close association between the outer class and the inner class, and the\
        \ inner class is used to not define another name in the library namespace.\n\
        \n```kotlin\n// A class from Kotlin stdlib\nclass FileTreeWalk(\n    ...\n\
        ) : Sequence<File> {\n\n    /** Returns an iterator walking through files.\
        \ */\n    override fun iterator(): Iterator<File> =\n        FileTreeWalkIterator()\n\
        \n    private inner class FileTreeWalkIterator\n        : AbstractIterator<File>()\
        \ {\n        ...\n    }\n\n    ...\n}\n```"
          - type: "text"
            stepId: "classes-section-6"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nAs you can see, in Kotlin we can define classes using really\
        \ concise syntax, and the result is very readable. The primary constructor\
        \ is an amazing invention, as is the fact that Kotlin uses properties instead\
        \ of fields. You have also learned about inner classes. This is all great,\
        \ but we haven't yet touched on inheritance, which is so important for developers\
        \ who like Object-Oriented style. We will discuss this along with interfaces\
        \ and abstract classes in the next chapter.\n\n[^09_0]: See \"Object-oriented\
        \ or functional? Two ways to see the world\" by Marcin MoskaĹ‚a, link: kt.academy/article/oop-vs-fp"
          - type: "single-answer"
            stepId: "classes-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "classes-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "classes-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "classes-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "classes-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "inheritance"
        name: "Inheritance"
        steps:
          - type: "text"
            stepId: "inheritance-introduction"
            question: "Inheritance"
            explanation: "Introduction to Inheritance"
            repetable: false
            text: "# Inheritance\n\nAncient philosophers observed that many classes of objects\
        \ share the same characteristics[^10_1]. For instance, all mammals have hair\
        \ or fur, are warm-blooded, and feed their young with milk[^10_0]. In programming,\
        \ we represent such relationships using **inheritance**.\n\nWhen a class inherits\
        \ from another class, it has all its member functions and properties. The\
        \ class that inherits is known as a **subclass** of the class it inherits\
        \ from, which is called a **superclass**. They are also known as **child**\
        \ and **parent**.\n\nIn Kotlin, all classes are closed by default, which means\
        \ we cannot inherit from them. We need to open a class using the `open` keyword\
        \ to allow inheritance from it. To inherit from a class, we place a colon\
        \ after the primary constructor (or after the class name if there is no primary\
        \ constructor), and then we invoke the superclass constructor. In the example\
        \ below, the class `Dog` inherits from the class `Mammal`. Since `Mammal`\
        \ has no constructor specified, we call it without arguments, so with `Mammal()`.\
        \ This way, `Dog` inherits all the properties and methods from `Mammal`.\n\
        \n```kotlin\nopen class Mammal {\n    val haveHairOrFur = true\n    val warmBlooded\
        \ = true\n    var canFeed = false\n\n    fun feedYoung() {\n        if (canFeed)\
        \ {\n            println(\"Feeding young with milk\")\n        }\n    }\n\
        }\n\nclass Dog : Mammal() {\n    fun makeVoice() {\n        println(\"Bark\
        \ bark\")\n    }\n}\n\nfun main() {\n    val dog = Dog()\n    dog.makeVoice()\
        \ // Bark bark\n    println(dog.haveHairOrFur) // true\n    println(dog.warmBlooded)\
        \ // true\n    // Dog is Mammal, so we can up-cast it\n    val mammal: Mammal\
        \ = dog\n    mammal.canFeed = true\n    mammal.feedYoung() // Feeding young\
        \ with milk\n}\n```\n\nConceptually, we treat subclasses as if they *are*\
        \ their superclasses: so, if `Dog` inherits from `Mammal`, we say that `Dog`\
        \ **is** a `Mammal`. Likewise, wherever `Mammal` is expected, we can use an\
        \ instance of `Dog`. Taking this into account, inheritance should only be\
        \ used if a real \"is a\" relationship between two classes exists."
          - type: "text"
            stepId: "inheritance-section-1"
            question: "Overriding elements"
            explanation: "Content for Overriding elements"
            repetable: false
            text: "## Overriding elements\n\nBy default, subclasses cannot override elements\
        \ defined in superclasses. To make this possible, these elements need to allow\
        \ it with the `open` modifier, because in Kotlin all elements are closed by\
        \ default. Then, subclasses can override their parents' implementation, which\
        \ looks just like defining the same function in children but with the `override`\
        \ modifier (this modifier is required in Kotlin).\n\n```kotlin\nopen class\
        \ Mammal {\n    val haveHairOrFur = true\n    val warmBlooded = true\n   \
        \ var canFeed = false\n\n    open fun feedYoung() {\n        if (canFeed)\
        \ {\n            println(\"Feeding young with milk\")\n        }\n    }\n\
        }\n\nclass Cat : Mammal() {\n    override fun feedYoung() {\n        if (canFeed)\
        \ {\n            println(\"Feeding young with milk\")\n        } else {\n\
        \            println(\"Feeding young with milk from bottle\")\n        }\n\
        \    }\n}\n\nfun main() {\n    val dog = Mammal()\n    dog.feedYoung() //\
        \ Nothing printed\n    val cat = Cat()\n    cat.feedYoung() // Feeding young\
        \ with milk from bottle\n    cat.canFeed = true\n    cat.feedYoung() // Feeding\
        \ young with milk\n}\n```"
          - type: "text"
            stepId: "inheritance-section-2"
            question: "Parents with non-empty constructors"
            explanation: "Content for Parents with non-empty constructors"
            repetable: false
            text: "## Parents with non-empty constructors\n\nSo far, we have inherited only\
        \ from classes with empty constructors; so, when we were specifying the superclass,\
        \ we used empty parentheses. However, if the superclass has constructor parameters,\
        \ we need to define some arguments inside these parentheses.\n\n```kotlin\n\
        open class Animal(val name: String)\n\nclass Dodo : Animal(\"Dodo\")\n```\n\
        \nWe can use primary constructor properties as superclass constructor arguments\
        \ or to construct these arguments.\n\n```kotlin\nopen class Animal(val name:\
        \ String)\n\nclass Dog(name: String) : Animal(name)\n\nclass Cat(name: String)\
        \ : Animal(\"Mr $name\")\n\nclass Human(\n   firstName: String,\n   lastName:\
        \ String,\n) : Animal(\"$firstName $lastName\")\n\nfun main() {\n   val dog\
        \ = Dog(\"Cookie\")\n   println(dog.name) // Cookie\n   val cat = Cat(\"MiauMiau\"\
        )\n   println(cat.name) // Mr MiauMiau\n}\n```"
          - type: "text"
            stepId: "inheritance-section-3"
            question: "Super call"
            explanation: "Content for Super call"
            repetable: false
            text: "## Super call\n\nWhen a class extends another class, it takes the behavior\
        \ from the superclass but also adds some behavior that is specific to the\
        \ subclass. This is why overriding methods often need to include the behavior\
        \ of the methods they override. For this, it is useful to call the superclass\
        \ implementation in these subclass methods. We do this using the `super` keyword,\
        \ followed by a dot, and then we call the method we want to override.\n\n\
        Consider the classes `Dog` and `BorderCollie` that are presented in the example\
        \ below. The default behavior for a dog is to wave its tail when it sees a\
        \ dog friend. Border Collies should behave the same but additionally lie down.\
        \ In this case, to call the superclass implementation, we need to use `super.seeFriend()`.\n\
        \n```kotlin\nopen class Dog {\n    open fun seeFriend() {\n        println(\"\
        Wave its tail\")\n    }\n}\n\nclass BorderCollie : Dog() {\n    override fun\
        \ seeFriend() {\n        println(\"Lie down\")\n        super.seeFriend()\n\
        \    }\n}\n\nfun main() {\n    val dog = Dog()\n    dog.seeFriend() // Wave\
        \ its tail\n    val borderCollie = BorderCollie()\n    borderCollie.seeFriend()\n\
        \    // Lie down\n    // Wave its tail\n}\n```"
          - type: "text"
            stepId: "inheritance-section-4"
            question: "Abstract class"
            explanation: "Content for Abstract class"
            repetable: false
            text: "## Abstract class\n\nA mammal is a group of animals, not a concrete species.\
        \ It defines a set of characteristics but might not exist in itself. To define\
        \ a class that can only be used as a superclass of other classes but cannot\
        \ produce an object, we use the `abstract` keyword before its class definition.\
        \ You can interpret the `open` modifier as \"one can inherit from this class\"\
        , whereas `abstract` means \"one must inherit from this class to use it\"\
        .\n\n```kotlin\nabstract class Mammal {\n   val haveHairOrFur = true\n   val\
        \ warmBlooded = true\n   var canFeed = false\n\n   fun feedYoung() {\n   \
        \    if (canFeed) {\n           println(\"Feeding young with milk\")\n   \
        \    }\n   }\n}\n```\n\nAbstract classes are open, so there is no need to\
        \ use the `open` modifier when a class has the `abstract` modifier already.\n\
        \nWhen a class is abstract, it can have abstract functions and properties.\
        \ Such functions do not have a body, and each subclass needs to override them.\
        \ Thanks to that, when we have an object whose type is an abstract class,\
        \ we can call its abstract functions because whatever the actual class of\
        \ this object is, it still needs to define these functions.\n\n```kotlin\n\
        abstract class Mammal {\n    val haveHairOrFur = true\n    val warmBlooded\
        \ = true\n    var canFeed = false\n\n    abstract fun feedYoung()\n}\n\nclass\
        \ Dog : Mammal() {\n    override fun feedYoung() {\n        if (canFeed) {\n\
        \            println(\"Feeding young with milk\")\n        }\n    }\n}\n\n\
        class Human : Mammal() {\n    override fun feedYoung() {\n        if (canFeed)\
        \ {\n            println(\"Feeding young with milk\")\n        } else {\n\
        \            println(\"Feeding young with milk from bottle\")\n        }\n\
        \    }\n}\n\nfun feedYoung(mammal: Mammal) {\n    // We can do that, because\
        \ feedYoung is an abstract\n    // function in Mammal\n    mammal.feedYoung()\n\
        }\n\nfun main() {\n    val dog = Dog()\n    dog.canFeed = true\n    feedYoung(dog)\
        \ // Feeding young with milk\n    feedYoung(Human()) // Feeding young with\
        \ milk from bottle\n}\n```\n\nAn abstract class can also have non-abstract\
        \ methods, which have a body. Such methods can be used by other methods. Therefore,\
        \ abstract classes can be used as templates with partial implementation for\
        \ other classes. Consider the `CoffeeMachine` abstract class below, which\
        \ specifies how latte or doppio can be prepared, but it needs a subclass to\
        \ override the `prepareEspresso` and `addMilk` methods. This class provides\
        \ implementation for only some methods, so it is a partial implementation.\n\
        \n```kotlin\nabstract class CoffeeMachine {\n    abstract fun prepareEspresso()\n\
        \    abstract fun addMilk()\n\n    fun prepareLatte() {\n        prepareEspresso()\n\
        \        addMilk()\n    }\n    fun prepareDoppio() {\n        prepareEspresso()\n\
        \        prepareEspresso()\n    }\n}\n```\n\nKotlin does not support multiple\
        \ inheritance, so a class can inherit only from one open class. I do not find\
        \ this a problem because inheritance is not so popular nowadays - interfaces\
        \ are implemented instead."
          - type: "text"
            stepId: "inheritance-section-5"
            question: "Interfaces"
            explanation: "Content for Interfaces"
            repetable: false
            text: "## Interfaces\n\nAn interface defines a set of properties and methods\
        \ that a class should have. We define interfaces with the `interface` keyword,\
        \ a name, and a body with the expected properties and methods.\n\n```kotlin\n\
        interface CoffeeMaker {\n    val type: String\n    fun makeCoffee(size: Size):\
        \ Coffee\n}\n```\n\nWhen a class implements an interface, this class has to\
        \ override all the elements defined by this interface. Thanks to that, we\
        \ can treat an instance of a class as an instance of an interface. We implement\
        \ interfaces similarly to how we extend classes, but without calling a constructor\
        \ because interfaces cannot have constructors.\n\n```kotlin\nclass User(val\
        \ id: Int, val name: String)\n\ninterface UserRepository {\n    fun findUser(id:\
        \ Int): User?\n    fun addUser(user: User)\n}\n\nclass FakeUserRepository\
        \ : UserRepository {\n    private var users = mapOf<Int, User>()\n\n    override\
        \ fun findUser(id: Int): User? = users[id]\n\n    override fun addUser(user:\
        \ User) {\n        users += user.id to user\n    }\n}\n\nfun main() {\n  \
        \  val repo: UserRepository = FakeUserRepository()\n    repo.addUser(User(123,\
        \ \"Zed\"))\n    val user = repo.findUser(123)\n    println(user?.name) //\
        \ Zed\n}\n```\n\nAs mentioned already, interfaces can specify that they expect\
        \ a class to have a particular property. Such properties can either be defined\
        \ as regular properties, or they can be defined by accessors (getter for `val`,\
        \ or getter and setter for `var`).\n\n```kotlin\ninterface Named {\n    val\
        \ name: String\n    val fullName: String\n}\n\nclass User(\n    override val\
        \ name: String,\n    val surname: String,\n) : Named {\n    override val fullName:\
        \ String\n        get() = \"$name $surname\"\n}\n```\n\nThe read-only `val`\
        \ property can be overridden with a read-write `var` property. This is because\
        \ the `val` property expects a getter, and the `var` property provides a getter\
        \ as well as an additional setter.\n\n```kotlin\ninterface Named {\n    val\
        \ name: String\n}\n\nclass NameBox : Named {\n    override var name = \"(default)\"\
        \n}\n```\n\nA class can implement multiple interfaces.\n\n```kotlin\ninterface\
        \ Drinkable {\n    fun drink()\n}\n\ninterface Spillable {\n    fun spill()\n\
        }\n\nclass Mug : Drinkable, Spillable {\n    override fun drink() {\n    \
        \    println(\"Ummm\")\n    }\n    override fun spill() {\n        println(\"\
        Ow, ow, OWWW\")\n    }\n}\n```\n\nInterfaces can specify default bodies for\
        \ their methods. Such methods do not need to (but can) be implemented by subclasses.\n\
        \n```kotlin\nclass User(val id: Int, val name: String)\n\ninterface UserRepository\
        \ {\n    fun findUser(id: Int): User? =\n        getUsers().find { it.id ==\
        \ id }\n\n    fun getUsers(): List<User>\n}\n\nclass FakeUserRepository :\
        \ UserRepository {\n    private var users = listOf<User>()\n\n    override\
        \ fun getUsers(): List<User> = users\n\n    fun addUser(user: User) {\n  \
        \      users += user\n    }\n}\n\nfun main() {\n    val repo = FakeUserRepository()\n\
        \    repo.addUser(User(123, \"Zed\"))\n    val user = repo.findUser(123)\n\
        \    println(user?.name) // Zed\n}\n```\n\nWhen we override a method, we can\
        \ still call its default body using the `super` keyword and a regular method\
        \ call[^10_6].\n\n```kotlin\ninterface NicePerson {\n   fun cheer() {\n  \
        \     println(\"Hello\")\n   }\n}\n\nclass Alex : NicePerson\n\nclass Ben\
        \ : NicePerson {\n   override fun cheer() {\n       super.cheer()\n      \
        \ println(\"My name is Ben\")\n   }\n}\n\nfun main() {\n   val alex = Alex()\n\
        \   alex.cheer() // Hello\n  \n   val ben = Ben()\n   ben.cheer()\n   // Hello\n\
        \   // My name is Ben\n}\n```\n\nWhen two interfaces define a method with\
        \ the same name and parameters, the class that implements both these interfaces\
        \ **must** override this method. To call the default bodies of these methods,\
        \ we need to use `super` with the name of the class we want to use in angle\
        \ brackets. So, to call `start` from `Boat` use `super<Boat>.start()`. Or,\
        \ to call `start` from `Car` use `super<Car>.start()`.\n\n```kotlin\ninterface\
        \ Boat {\n   fun start() {\n       println(\"Ready to swim\")\n   }\n}\n\n\
        interface Car {\n   fun start() {\n       println(\"Ready to drive\")\n  \
        \ }\n}\n\nclass Amphibian: Car, Boat {\n   override fun start() {\n      \
        \ super<Car>.start()\n       super<Boat>.start()\n   }\n}\n\nfun main() {\n\
        \   val vehicle = Amphibian()\n   vehicle.start()\n   // Ready to drive\n\
        \   // Ready to swim\n}\n```"
          - type: "text"
            stepId: "inheritance-section-6"
            question: "Visibility"
            explanation: "Content for Visibility"
            repetable: false
            text: "## Visibility\n\nWhen we design our classes, we prefer to expose as little\
        \ as possible[^10_3]. If there is no reason for an element to be visible[^10_4],\
        \ we prefer to keep it hidden. This is why if there is no good reason to have\
        \ a less restrictive visibility type, it is good practice to make the visibility\
        \ of classes and elements as restrictive as possible. We do this using visibility\
        \ modifiers.\n\nFor class members, these are the 4 visibility modifiers we\
        \ can use:\n* `public` (default) - visible everywhere for clients which can\
        \ see the declaring class.\n* `private` - visible inside this class only.\n\
        * `protected` - visible inside this class and in subclasses.\n* `internal`\
        \ - visible inside this module for clients which can see the declaring class.\n\
        \nTop-level elements have 3 visibility modifiers:\n* `public` (default) -\
        \ visible everywhere.\n* `private` - visible inside the same file only.\n\
        * `internal` - visible inside this module.\n\nNote that a module is not the\
        \ same as a package. In Kotlin, a module is defined as a set of Kotlin sources\
        \ that are compiled together. This might mean:\n* a Gradle source set,\n*\
        \ a Maven project,\n* an IntelliJ IDEA module,\n* a set of files compiled\
        \ with one invocation of an Ant task.\n\nLet's see some examples, starting\
        \ with the default visibility, which makes elements visible everywhere and\
        \ can be explicitly specified using the `public` modifier.\n\n```kotlin\n\
        // File1.kt\nopen class A {\n   public val a = 10\n   public fun b() {\n \
        \      println(a) // Can use it\n   }\n}\n\npublic val c = 20\npublic fun\
        \ d() {}\n\nclass B: A() {\n   fun e() {\n       println(a) // Can use it\n\
        \       println(b()) // Can use it\n   }\n}\n\nfun main() {\n   println(A().a)\
        \ // Can use it\n   println(A().b()) // Can use it\n   println(c) // Can use\
        \ it\n   println(d()) // Can use it\n}\n\n// File2.kt in the same or different\
        \ module as File1.kt\nfun main() {\n   println(A().a) // Can use it\n   println(A().b())\
        \ // Can use it\n   println(c) // Can use it\n   println(d()) // Can use it\n\
        }\n```\n\nThe `private` modifier can be interpreted as \"visible in the creation\
        \ scope\"; so, if we define an element in a class, it will be visible only\
        \ in this class; if we define an element in a file, it will be visible only\
        \ in this file.\n\n```kotlin\n// File1.kt\nopen class A {\n    private val\
        \ a = 10\n    private fun b() {\n        println(a) // Can use it\n    }\n\
        }\n\nprivate val c = 20\nprivate fun d() {}\n\nclass B : A() {\n    fun e()\
        \ {\n        println(a) // Error, cannot use a!\n        println(b()) // Error,\
        \ cannot use b!\n    }\n}\n\nfun main() {\n    println(A().a) // Error, cannot\
        \ use a!\n    println(A().b()) // Error, cannot use b!\n    println(c) //\
        \ Can use it\n    println(d()) // Can use it\n}\n\n// File2.kt in the same\
        \ or different module as File1.kt\nfun main() {\n    println(A().a) // Error,\
        \ cannot use a!\n    println(A().b()) // Error, cannot use b!\n    println(c)\
        \ // Error, cannot use c!\n    println(d()) // Error, cannot use d!\n}\n```\n\
        \nThe `protected` modifier can be interpreted as \"visible in the class and\
        \ its subclasses\". `protected` only makes sense for elements defined inside\
        \ classes. It is similar to `private`, but protected elements are also visible\
        \ inside subclasses of the class where these elements are defined.\n\n```kotlin\n\
        // File1.kt\nopen class A {\n   protected val a = 10\n   protected fun b()\
        \ {\n       println(a) // Can use it\n   }\n}\n\nopen class B: A() {\n   fun\
        \ e() {\n       println(a) // Can use it!\n       println(b()) // Can use\
        \ it!\n   }\n}\n\nclass C: A() {\n   fun f() {\n       println(a) // Can use\
        \ it!\n       println(b()) // Can use it!\n   }\n}\n\nfun main() {\n   println(A().a)\
        \ // Error, cannot use a!\n   println(A().b()) // Error, cannot use b!\n}\n\
        \n// File2.kt in the same or different module as File1.kt\nfun main() {\n\
        \   println(A().a) // Error, cannot use a!\n   println(A().b()) // Error,\
        \ cannot use b!\n}\n```\n\nThe `internal` modifier makes elements visible\
        \ in the same module. It is useful for library creators who use the `internal`\
        \ modifier for elements they want to be visible in their project but donâ€™\
        t want to expose to library users. It is also useful in multi-module projects\
        \ to limit access to a single module. It's useless in single-module projects[^10_5].\n\
        \n```kotlin\n// File1.kt\nopen class A {\n   internal val a = 10\n   internal\
        \ fun b() {\n       println(a) // Can use it\n   }\n}\n\ninternal val c =\
        \ 20\ninternal fun d() {}\n\nclass B: A() {\n   fun e() {\n       println(a)\
        \ // Can use it\n       println(b()) // Can use it\n   }\n}\n\nfun main()\
        \ {\n   println(A().a) // Can use it\n   println(A().b()) // Can use it\n\
        \   println(c) // Can use it\n   println(d()) // Can use it\n}\n\n// File2.kt\
        \ in the same module as File1.kt\nfun main() {\n   println(A().a) // Can use\
        \ it\n   println(A().b()) // Can use it\n   println(c) // Can use it\n   println(d())\
        \ // Can use it\n}\n\n// File3.kt in a different module than File1.kt\nfun\
        \ main() {\n   println(A().a) // Error, cannot use a!\n   println(A().b())\
        \ // Error, cannot use b!\n   println(c) // Error, cannot use c!\n   println(d())\
        \ // Error, cannot use d!\n}\n```\n\nIf your module might be used by another\
        \ module, change the visibility of public elements that you donâ€™t want to\
        \ expose to `internal`. If an element is designed for inheritance and is only\
        \ used in a class and subclasses, make it `protected`. If you use an element\
        \ only in the same file or class, make it `private`.\n\nChanging the visibility\
        \ of a property means changing the visibility of its accessors. A property's\
        \ field is always private. To change setter visibility, place the visibility\
        \ modifier before the `set` keyword. The getter must have the same visibility\
        \ as the property.\n\n```kotlin\nclass View {\n   var isVisible: Boolean =\
        \ true\n       private set\n\n   fun hide() {\n       isVisible = false\n\
        \   }\n}\n\nfun main() {\n   val view = View()\n   println(view.isVisible)\
        \ // true\n   view.hide()\n   println(view.isVisible) // false\n   view.isVisible\
        \ = true // ERROR\n   // Cannot assign to 'isVisible',\n   // the setter is\
        \ private in 'View'\n}\n```"
          - type: "text"
            stepId: "inheritance-section-7"
            question: "`Any`"
            explanation: "Content for `Any`"
            repetable: false
            text: "## `Any`\n\nIf a class has no explicit parent, its implicit parent is\
        \ `Any`, which is a superclass of all the classes in Kotlin. This means that\
        \ when we expect the `Any?` type parameter, we accept all possible objects\
        \ as arguments.\n\n```kotlin\nfun consumeAnything(a: Any?) {\n    println(\"\
        Om nom $a\")\n}\n\nfun main() {\n    consumeAnything(null) // Om nom null\n\
        \    consumeAnything(123) // Om nom 123\n    consumeAnything(\"ABC\") // Om\
        \ nom ABC\n}\n```\n\nYou can think of `Any` as an open class with three methods:\
        \ `toString`, `equals` and `hashCode`. These will be better explained in the\
        \ next chapter, *Data classes*. Overriding methods defined by `Any` is optional\
        \ because each is an open function with a default body."
          - type: "text"
            stepId: "inheritance-section-8"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nIn this chapter, weâ€™ve learned how to use inheritance in\
        \ Kotlin. Weâ€™ve got familiar with open and abstract classes, interfaces, and\
        \ visibility modifiers. These are useful when we want to represent hierarchies\
        \ of classes.\n\nInstead of using classes to represent hierarchies, we can\
        \ also treat them as holders of data; for this we use the `data` modifier,\
        \ which is presented in the next chapter.\n\n[^10_0]: A fun fact for dog or\
        \ cat owners is that, like all mammals, they too have belly buttons; however,\
        \ it is often not easy to find them as they are small and sometimes hidden\
        \ under fur.\n[^10_1]: I believe it was Aristotle who mainly contributed to\
        \ the development and popularization of this idea.\n[^10_3]: A deeper explanation\
        \ of the reasons behind this general programming rule is presented in *Effective\
        \ Kotlin*, *Item 29: Minimize elementsâ€™ visibility*.\n[^10_4]: Visibility\
        \ defines where an element can be used. If an element is not visible, it will\
        \ not be suggested by the IDE and cannot be used.\n[^10_5]: However, I've\
        \ seen cases where teams used the `internal` visibility modifier as a substitute\
        \ for the Java package-private modifier. Even though it has different behavior,\
        \ some developers treat this modifier as a form of documentation that should\
        \ be interpreted as \"this element should not be used in different packages\"\
        . I am not a fan of such practices, therefore I suggest using annotation instead.\n\
        [^10_6]: Default methods make interfaces more than what they were traditionally\
        \ considered to be. They make it possible for interfaces to define behavior\
        \ that is inherited by classes that implement these interfaces. The concept\
        \ which represents a set of methods that can be used to extend the functionality\
        \ of a class is known in programming as a **trait**. This is why in early\
        \ versions of Kotlin, we used the `trait` keyword instead of the `interface`\
        \ keyword. However, version 8 of Java introduced default bodies for interface\
        \ methods, so Kotlin creators assumed that the JVM community would expand\
        \ the meaning of an interface, and this is why we now use the `interface`\
        \ keyword. The concept of traits is used in Kotlin. An example can be found\
        \ in my article *Traits for testing in Kotlin*, which you can find under `kt.academy/article/traits-testing`."
          - type: "single-answer"
            stepId: "inheritance-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "inheritance-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "inheritance-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "inheritance-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "inheritance-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "data-classes"
        name: "Data classes"
        steps:
          - type: "text"
            stepId: "data-classes-introduction"
            question: "Data classes"
            explanation: "Introduction to Data classes"
            repetable: false
            text: "{sample: true}\n# Data classes\n\nIn Kotlin, we say that all classes\
        \ inherit from the `Any` superclass, which is at the top of the class hierarchy[^11_3].\
        \ Methods defined in `Any` can be called on all objects. These methods are:\n\
        * `equals` - used when two objects are compared using `==`,\n* `hashCode`\
        \ - used by collections that use the hash table algorithm,\n* `toString` -\
        \ used to represent an object as a string, e.g., in a string template or the\
        \ `print` function.\n\nThanks to these methods, we can represent any object\
        \ as a string or check the equality of any two objects.\n\n```kotlin\n// Any\
        \ formal definition\nopen class Any {\n   open operator fun equals(other:\
        \ Any?): Boolean\n   open fun hashCode(): Int\n   open fun toString(): String\n\
        }\n\nclass A // Implicitly inherits from Any\n\nfun main() {\n   val a = A()\n\
        \   a.equals(a)\n   a == a\n   a.hashCode()\n   a.toString()\n   println(a)\n\
        }\n```\n\n> Truth be told, `Any` is represented as a class, but it should\
        \ actually be considered the head of the type hierarchy, but with some special\
        \ functions. Consider the fact that `Any` is also the supertype of all interfaces,\
        \ even though interfaces cannot inherit from classes.\n\nThe default implementations\
        \ of `equals`, `hashCode`, and `toString` are strongly based on the objectâ€™\
        s address in memory. The `equals` method returns `true` only when the address\
        \ of both objects is the same, which means the same object is on both sides.\
        \ The `hashCode` method typically transforms an address into a number. `toString`\
        \ produces a string that starts with the class name, then the at sign \"@\"\
        , then the unsigned hexadecimal representation of the hash code of the object.\n\
        \n```kotlin\nclass A\n\nfun main() {\n   val a1 = A()\n   val a2 = A()\n\n\
        \   println(a1.equals(a1)) // true\n   println(a1.equals(a2)) // false\n \
        \  // or\n   println(a1 == a1) // true\n   println(a1 == a2) // false\n\n\
        \   println(a1.hashCode()) // Example: 149928006\n   println(a2.hashCode())\
        \ // Example: 713338599\n\n   println(a1.toString()) // Example: A@8efb846\n\
        \   println(a2.toString()) // Example: A@2a84aee7\n   // or\n   println(a1)\
        \ // Example: A@8efb846\n   println(a2) // Example: A@2a84aee7\n}\n```\n\n\
        By overriding these methods, we can decide how a class should behave. Consider\
        \ the following class `A`, which is equal to other instances of the same class\
        \ and returns a constant hash code and string representation.\n\n```kotlin\n\
        class A {\n   override fun equals(other: Any?): Boolean = other is A\n\n \
        \  override fun hashCode(): Int = 123\n\n   override fun toString(): String\
        \ = \"A()\"\n}\n\nfun main() {\n   val a1 = A()\n   val a2 = A()\n\n   println(a1.equals(a1))\
        \ // true\n   println(a1.equals(a2)) // true\n   // or\n   println(a1 == a1)\
        \ // true\n   println(a1 == a2) // true\n\n   println(a1.hashCode()) // 123\n\
        \   println(a2.hashCode()) // 123\n\n   println(a1.toString()) // A()\n  \
        \ println(a2.toString()) // A()\n   // or\n   println(a1) // A()\n   println(a2)\
        \ // A()\n}\n```\n\nI've dedicated separate items in the *Effective Kotlin*\
        \ book to implementing a custom `equals` and `hashCode`[^11_0], but in practice\
        \ we rarely need to do that. As it turns out, in modern projects we almost\
        \ solely operate on only two kinds of objects:\n* Active objects, like services,\
        \ controllers, repositories, etc. Such classes donâ€™t need to override any\
        \ methods from `Any` because the default behavior is perfect for them.\n*\
        \ Data model class objects, which represent bundles of data. For such objects,\
        \ we use the `data` modifier, which overrides the `toString`, `equals`, and\
        \ `hashCode` methods. The `data` modifier also implements the methods `copy`\
        \ and `componentN` (`component1`, `component2`, etc.), which are not inherited\
        \ and cannot be modified[^11_1].\n\n```kotlin\ndata class Player(\n   val\
        \ id: Int,\n   val name: String,\n   val points: Int\n)\n\nval player = Player(0,\
        \ \"Gecko\", 9999)\n```\n\nLet's discuss the aforementioned implicit data\
        \ class methods and the differences between regular class behavior and data\
        \ class behavior."
          - type: "text"
            stepId: "data-classes-section-1"
            question: "Transforming to a string"
            explanation: "Content for Transforming to a string"
            repetable: false
            text: "## Transforming to a string\n\nThe default `toString` transformation\
        \ produces a string that starts with the class name, then the at sign \"@\"\
        , and then the unsigned hexadecimal representation of the hash code of the\
        \ object. The purpose of this is to display the class name and to determine\
        \ whether two strings represent the same object or not.\n\n```kotlin\nclass\
        \ FakeUserRepository\n\nfun main() {\n   val repository1 = FakeUserRepository()\n\
        \   val repository2 = FakeUserRepository()\n   println(repository1) // e.g.\
        \ FakeUserRepository@8efb846\n   println(repository1) // e.g. FakeUserRepository@8efb846\n\
        \   println(repository2) // e.g. FakeUserRepository@2a84aee7\n}\n```\n\nWith\
        \ the `data` modifier, the compiler generates a `toString` that displays the\
        \ class name and then pairs with the name and value for each primary constructor\
        \ property. We assume that data classes are represented by their primary constructor\
        \ properties, so all these properties, together with their values, are displayed\
        \ during a transformation to a string. This is useful for logging and debugging.\n\
        \n```kotlin\ndata class Player(\n   val id: Int,\n   val name: String,\n \
        \  val points: Int\n)\n\nfun main() {\n   val player = Player(0, \"Gecko\"\
        , 9999)\n   println(player) \n   // Player(id=0, name=Gecko, points=9999)\n\
        \   println(\"Player: $player\")\n   // Player: Player(id=0, name=Gecko, points=9999)\n\
        }\n```\n\n{width: 84%}\n![](data_toString.png)"
          - type: "text"
            stepId: "data-classes-section-2"
            question: "Objects equality"
            explanation: "Content for Objects equality"
            repetable: false
            text: "## Objects equality\n\nIn Kotlin, we check the equality of two objects\
        \ using `==`, which uses the `equals` method from `Any`. So, this method decides\
        \ if two objects should be considered equal or not. By default, two different\
        \ instances are never equal. This is perfect for active objects, i.e., objects\
        \ that work independently of other instances of the same class and possibly\
        \ have a protected mutable state.\n\n```kotlin\nclass FakeUserRepository\n\
        \nfun main() {\n   val repository1 = FakeUserRepository()\n   val repository2\
        \ = FakeUserRepository()\n   println(repository1 == repository1) // true\n\
        \   println(repository1 == repository2) // false\n}\n```\n\nClasses with the\
        \ `data` modifier represent bundles of data; they are considered equal to\
        \ other instances if:\n* both are of the same class,\n* their primary constructor\
        \ property values are equal.\n\n```kotlin\ndata class Player(\n   val id:\
        \ Int,\n   val name: String,\n   val points: Int\n)\n\nfun main() {\n   val\
        \ player = Player(0, \"Gecko\", 9999)\n   println(player == Player(0, \"Gecko\"\
        , 9999)) // true\n   println(player == Player(0, \"Ross\", 9999)) // false\n\
        }\n```\n\nThis is what a simplified implementation of the `equals` method\
        \ generated by the `data` modifier for the `Player` class looks like:\n\n\
        ```kotlin\noverride fun equals(other: Any?): Boolean = other is Player &&\n\
        \   other.id == this.id &&\n   other.name == this.name &&\n   other.points\
        \ == this.points\n```\n\n> Implementing a custom `equals` is described in\
        \ *Effective Kotlin*, *Item 42: Respect the contract of `equals`*."
          - type: "text"
            stepId: "data-classes-section-3"
            question: "Hash code"
            explanation: "Content for Hash code"
            repetable: false
            text: "## Hash code\n\nAnother method from `Any` is `hashCode`, which is used\
        \ to transform an object into an `Int`. With a `hashCode` method, the object\
        \ instance can be stored in the hash table data structure implementations\
        \ that are part of many popular classes, including `HashSet` and `HashMap`.\
        \ The most important rule of the `hashCode` implementation is that it should:\n\
        * be consistent with `equals`, so it should return the same `Int` for equal\
        \ objects, and it must always return the same hash code for the same object.\n\
        * spread objects as uniformly as possible in the range of all possible `Int`\
        \ values.\n\nThe default `hashCode` is based on an object's address in memory.\
        \ The `hashCode` generated by the `data` modifier is based on the hash codes\
        \ of this objectâ€™s primary constructor properties. In both cases, the same\
        \ number is returned for equal objects.\n\n```kotlin\ndata class Player(\n\
        \   val id: Int,\n   val name: String,\n   val points: Int\n)\n\nfun main()\
        \ {\n   println(Player(0, \"Gecko\", 9999).hashCode()) // 2129010918\n   println(Player(0,\
        \ \"Gecko\", 9999).hashCode()) // 2129010918\n   println(Player(0, \"Ross\"\
        , 9999).hashCode())  // 79159602\n}\n```\n\nTo learn more about the hash table\
        \ algorithm and implementing a custom `hashCode` method, see *Effective Kotlin*,\
        \ *Item 43: Respect the contract of `hashCode`*."
          - type: "text"
            stepId: "data-classes-section-4"
            question: "Copying objects"
            explanation: "Content for Copying objects"
            repetable: false
            text: "## Copying objects\n\nAnother method generated by the `data` modifier\
        \ is `copy`, which is used to create a new instance of a class but with a\
        \ concrete modification. The idea is very simple: it is a function with parameters\
        \ for each primary constructor property, but each of these parameters has\
        \ a default value, i.e., the current value of the associated property.\n\n\
        ```kotlin\n// This is how copy generated by data modifier\n// for Person class\
        \ looks like under the hood\nfun copy(\n   id: Int = this.id,\n   name: String\
        \ = this.name,\n   points: Int = this.points\n) = Player(id, name, points)\n\
        ```\n\nThis means we can call `copy` with no parameters to make a copy of\
        \ our object with no modifications, but we can also specify new values for\
        \ the properties we want to change.\n\n```kotlin\ndata class Player(\n   val\
        \ id: Int,\n   val name: String,\n   val points: Int\n)\n\nfun main() {\n\
        \   val p = Player(0, \"Gecko\", 9999)\n\n   println(p.copy()) // Player(id=0,\
        \ name=Gecko, points=9999)\n\n   println(p.copy(id = 1, name = \"New name\"\
        ))\n   // Player(id=1, name=New name, points=9999)\n\n   println(p.copy(points\
        \ = p.points + 1))\n   // Player(id=0, name=Gecko, points=10000)\n}\n```\n\
        \nNote that `copy` creates a shallow copy of an object; so, if our object\
        \ holds a mutable state, a change in one object will be a change in all its\
        \ copies too.\n\n```kotlin\ndata class StudentGrades(\n   val studentId: String,\n\
        \   // Code smell: Avoid using mutable objects in data classes\n   val grades:\
        \ MutableList<Int>\n)\n\nfun main() {\n   val grades1 = StudentGrades(\"1\"\
        , mutableListOf())\n   val grades2 = grades1.copy(studentId = \"2\")\n   println(grades1)\
        \ // Grades(studentId=1, grades=[])\n   println(grades2) // Grades(studentId=2,\
        \ grades=[])\n   grades1.grades.add(5)\n   println(grades1) // Grades(studentId=1,\
        \ grades=[5])\n   println(grades2) // Grades(studentId=2, grades=[5])\n  \
        \ grades2.grades.add(1)\n   println(grades1) // Grades(studentId=1, grades=[5,\
        \ 1])\n   println(grades2) // Grades(studentId=2, grades=[5, 1])\n}\n```\n\
        \nWe do not have this problem when we use `copy` for immutable classes, i.e.,\
        \ classes with only `val` properties that hold immutable values. `copy` was\
        \ introduced as special support for immutability (for details, see *Effective\
        \ Kotlin*, *Item 1: Limit mutability*).\n\n```kotlin\ndata class StudentGrades(\n\
        \   val studentId: String,\n   val grades: List<Int>\n)\n\nfun main() {\n\
        \   var grades1 = StudentGrades(\"1\", listOf())\n   var grades2 = grades1.copy(studentId\
        \ = \"2\")\n   println(grades1) // Grades(studentId=1, grades=[])\n   println(grades2)\
        \ // Grades(studentId=2, grades=[])\n   grades1 = grades1.copy(grades = grades1.grades\
        \ + 5)\n   println(grades1) // Grades(studentId=1, grades=[5])\n   println(grades2)\
        \ // Grades(studentId=2, grades=[])\n   grades2 = grades2.copy(grades = grades2.grades\
        \ + 1)\n   println(grades1) // Grades(studentId=1, grades=[5])\n   println(grades2)\
        \ // Grades(studentId=2, grades=[1])\n}\n```\n\nNotice that data classes are\
        \ unsuitable for objects that must maintain invariant constraints on mutable\
        \ properties. For example, in the `User` example below, the class would not\
        \ be able to guarantee that the `name` and `surname` values are not blank\
        \ if these variables were mutable (so, defined with `var`). Data classes are\
        \ perfectly fit for immutable properties, whose constraints might be checked\
        \ during the creation of these objects. In the example below, we can be sure\
        \ that the `name` and `surname` values are not blank in an instance of `User`.\
        \ \n\n```kotlin\ndata class User(\n   val name: String,\n   val surname: String,\n\
        ) {\n   init {\n       require(name.isNotBlank())\n       // throws exception\
        \ if name is blank\n       require(surname.isNotBlank())\n       // throws\
        \ exception if surname is blank\n   }\n}\n```"
          - type: "text"
            stepId: "data-classes-section-5"
            question: "Destructuring"
            explanation: "Content for Destructuring"
            repetable: false
            text: "## Destructuring\n\nKotlin supports a feature called position-based destructuring,\
        \ which lets us assign multiple variables to components of a single object.\
        \ For that, we place our variable names in round brackets.\n\n```kotlin\n\
        data class Player(\n   val id: Int,\n   val name: String,\n   val points:\
        \ Int\n)\n\nfun main() {\n   val player = Player(0, \"Gecko\", 9999)\n   val\
        \ (id, name, pts) = player\n   println(id) // 0\n   println(name) // Gecko\n\
        \   println(pts) // 9999\n}\n```\n\nThis mechanism relies on position, not\
        \ names. The object on the right side of the equality sign needs to provide\
        \ the functions `component1`, `component2`, etc., and the variables are assigned\
        \ to the results of these methods.\n\n```kotlin\nval (id, name, pts) = player\n\
        // is compiled to\nval id: Int = player.component1()\nval name: String = player.component2()\n\
        val pts: Int = player.component3()\n```\n\nThis code works because the `data`\
        \ modifier generates `componentN` functions for each primary constructor parameter,\
        \ according to their order in the constructor.\n\nThese are currently all\
        \ the functionalities that the `data` modifier provides. Don't use it if you\
        \ don't need `toString`, `equals`, `hashCode`, `copy` or destructuring. If\
        \ you need some of these functionalities for a class representing a bundle\
        \ of data, use the `data` modifier instead of implementing the methods yourself."
          - type: "text"
            stepId: "data-classes-section-6"
            question: "When and how should we use destructuring?"
            explanation: "Content for When and how should we use destructuring?"
            repetable: false
            text: "## When and how should we use destructuring?\n\nPosition-based destructuring\
        \ has pros and cons. Its biggest advantage is that we can name variables however\
        \ we want, so we can use names like `country` and `city` in the example below.\
        \ We can also destructure anything we want as long as it provides `componentN`\
        \ functions. This includes `List` and `Map.Entry`, both of which have `componentN`\
        \ functions defined as extensions:\n\n```kotlin\nfun main() {\n   val visited\
        \ = listOf(\"Spain\", \"Morocco\", \"India\")\n   val (first, second, third)\
        \ = visited\n   println(\"$first $second $third\")\n   // Spain Morocco India\n\
        \n   val trip = mapOf(\n       \"Spain\" to \"Gran Canaria\",\n       \"Morocco\"\
        \ to \"Taghazout\",\n       \"India\" to \"Rishikesh\"\n   )\n   for ((country,\
        \ city) in trip) {\n       println(\"We loved $city in $country\")\n     \
        \  // We loved Gran Canaria in Spain\n       // We loved Taghazout in Morocco\n\
        \       // We loved Rishikesh in India\n   }\n}\n```\n\nOn the other hand,\
        \ position-based destructuring is dangerous. We need to adjust every destructuring\
        \ when the order or number of elements in a data class changes. When we use\
        \ this feature, it is very easy to introduce errors into our code by changing\
        \ the order of the primary constructorâ€™s properties.\n\n```kotlin\ndata class\
        \ FullName(\n   val firstName: String,\n   val secondName: String,\n   val\
        \ lastName: String\n)\n\nval elon = FullName(\"Elon\", \"Reeve\", \"Musk\"\
        )\nval (name, surname) = elon\nprint(\"It is $name $surname!\") // It is Elon\
        \ Reeve!\n```\n\nWe need to be careful with destructuring. It is useful to\
        \ use the same names as data class primary constructor properties. In the\
        \ case of an incorrect order, an IntelliJ/Android Studio warning will be shown.\
        \ It might even be useful to upgrade this warning to an error.\n\n{width:\
        \ 84%}\n![](data_fullname.png)\n\nDestructuring a single value in lambda is\
        \ very confusing, especially since parentheses around arguments in lambda\
        \ expressions are either optional or required in some languages.\n\n```kotlin\n\
        data class User(\n   val name: String,\n   val surname: String,\n)\n\nfun\
        \ main() {\n   val users = listOf(\n       User(\"Nicola\", \"Corti\")\n \
        \  )\n   users.forEach { u -> println(u) }\n   // User(name=Nicola, surname=Corti)\n\
        \   users.forEach { (u) -> println(u) }\n   // Nicola\n}\n```"
          - type: "text"
            stepId: "data-classes-section-7"
            question: "Data class limitations"
            explanation: "Content for Data class limitations"
            repetable: false
            text: "## Data class limitations\n\nThe idea behind data classes is that they\
        \ represent a bundle of data; their constructors allow us to specify all this\
        \ data, and we can access it through destructuring or by copying them to another\
        \ instance with the `copy` method. This is why only primary constructor properties\
        \ are considered by the methods defined in data classes.\n\n```kotlin\ndata\
        \ class Dog(\n   val name: String,\n) {\n   // Bad practice, avoid mutable\
        \ properties in data classes\n   var trained = false\n}\n\nfun main() {\n\
        \   val d1 = Dog(\"Cookie\")\n   d1.trained = true\n   println(d1) // Dog(name=Cookie)\n\
        \   // so nothing about trained property\n\n   val d2 = d1.copy()\n   println(d1.trained)\
        \ // true\n   println(d2.trained) // false\n   // so trained value not copied\n\
        }\n```\n\nData classes are supposed to keep all the essential properties in\
        \ their primary constructor. Inside the body, we should only keep redundant\
        \ immutable properties, which means properties whose value is distinctly calculated\
        \ from primary constructor properties, like `fullName`, which is calculated\
        \ from `name` and `surname`. Such values are also ignored by data class methods,\
        \ but their value will always be correct because it will be calculated when\
        \ a new object is created.\n\n```kotlin\ndata class FullName(\n   val name:\
        \ String,\n   val surname: String,\n) {\n   val fullName = \"$name $surname\"\
        \n}\n\nfun main() {\n   val d1 = FullName(\"Cookie\", \"MoskaĹ‚a\")\n   println(d1.fullName)\
        \ // Cookie MoskaĹ‚a\n   println(d1) // FullName(name=Cookie, surname=MoskaĹ‚\
        a)\n\n   val d2 = d1.copy()\n   println(d2.fullName) // Cookie MoskaĹ‚a\n \
        \  println(d2) // FullName(name=Cookie, surname=MoskaĹ‚a)\n}\n```\n\nYou should\
        \ also remember that data classes must be **final** and so cannot be used\
        \ as a super-type for inheritance."
          - type: "text"
            stepId: "data-classes-section-8"
            question: "Prefer data classes instead of tuples"
            explanation: "Content for Prefer data classes instead of tuples"
            repetable: false
            text: "## Prefer data classes instead of tuples\n\nData classes offer more than\
        \ what is generally provided by tuples. Historically, they replaced tuples\
        \ in Kotlin since they are considered better practice[^11_2]. The only tuples\
        \ that are left are `Pair` and `Triple`, but these are data classes under\
        \ the hood:\n\n```kotlin\ndata class Pair<out A, out B>(\n   val first: A,\n\
        \   val second: B\n) : Serializable {\n\n   override fun toString(): String\
        \ =\n       \"($first, $second)\"\n}\n\ndata class Triple<out A, out B, out\
        \ C>(\n   val first: A,\n   val second: B,\n   val third: C\n) : Serializable\
        \ {\n\n   override fun toString(): String =\n       \"($first, $second, $third)\"\
        \n}\n```\n\nThe easiest way to create a `Pair` is by using the `to` function.\
        \ This is a generic infix extension function, defined as follows (we will\
        \ discuss both generic and extension functions in later chapters).\n\n```kotlin\n\
        infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n```\n\nThanks\
        \ to the infix modifier, a method can be used by placing its name between\
        \ arguments, as the infix name suggests. The result `Pair` is typed, so the\
        \ result type from the `\"ABC\" to 123` expression is `Pair<String, Int>`.\n\
        \n```kotlin\nfun main() {\n   val p1: Pair<String, Int> = \"ABC\" to 123\n\
        \   println(p1) // (ABC, 123)\n   val p2 = 'A' to 3.14 \n   // the type of\
        \ p2 is Pair<Char, Double>\n   println(p2) // (A, 123)\n   val p3 = true to\
        \ false\n   // the type of p3 is Pair<Boolean, Boolean>\n   println(p3) //\
        \ (true, false)\n}\n```\n\nThese tuples remain because they are very useful\
        \ for local purposes, like:\n\n* When we immediately name values:\n\n```kotlin\n\
        val (description, color) = when {\n   degrees < 5 -> \"cold\" to Color.BLUE\n\
        \   degrees < 23 -> \"mild\" to Color.YELLOW\n   else -> \"hot\" to Color.RED\n\
        }\n```\n\n* To represent an aggregate that is not known in advance, as is\
        \ commonly the case in standard library functions:\n\n```kotlin\nval (odd,\
        \ even) = numbers.partition { it % 2 == 1 }\nval map = mapOf(1 to \"San Francisco\"\
        , 2 to \"Amsterdam\")\n```\n\nIn other cases, we prefer data classes. Take\
        \ a look at an example: letâ€™s say that we need a function that parses a full\
        \ name into a name and a surname. One might represent this name and surname\
        \ as a `Pair<String, String>`:\n\n```kotlin\nfun String.parseName(): Pair<String,\
        \ String>? {\n   val indexOfLastSpace = this.trim().lastIndexOf(' ')\n   if\
        \ (indexOfLastSpace < 0) return null\n   val firstName = this.take(indexOfLastSpace)\n\
        \   val lastName = this.drop(indexOfLastSpace)\n   return Pair(firstName,\
        \ lastName)\n}\n\n// Usage\nfun main() {\n  val fullName = \"Marcin MoskaĹ‚\
        a\"\n  val (firstName, lastName) = fullName.parseName() ?: return\n}\n```\n\
        \nThe problem is that when someone reads this code, it is not clear that `Pair<String,\
        \ String>` represents a full name. What is more, it is not clear what the\
        \ order of the values is, therefore someone might think that the surname goes\
        \ first:\n\n```kotlin\nval fullName = \"Marcin MoskaĹ‚a\"\nval (lastName, firstName)\
        \ = fullName.parseName() ?: return\nprint(\"His name is $firstName\") // His\
        \ name is MoskaĹ‚a\n```\n\nTo make usage safer and the function easier to read,\
        \ we should use a data class instead:\n\n```kotlin\ndata class FullName(\n\
        \   val firstName: String,\n   val lastName: String\n)\n\nfun String.parseName():\
        \ FullName? {\n   val indexOfLastSpace = this.trim().lastIndexOf(' ')\n  \
        \ if (indexOfLastSpace < 0) return null\n   val firstName = this.take(indexOfLastSpace)\n\
        \   val lastName = this.drop(indexOfLastSpace)\n   return FullName(firstName,\
        \ lastName)\n}\n\n// Usage\nfun main() {\n  val fullName = \"Marcin MoskaĹ‚\
        a\"\n  val (firstName, lastName) = fullName.parseName() ?: return\n  print(\"\
        His name is $firstName $lastName\") \n  // His name is Marcin MoskaĹ‚a\n}\n\
        ```\n\nThis costs nearly nothing and improves the function significantly:\n\
        \n* The return type of this function is more clear.\n\n* The return type is\
        \ shorter and easier to pass forward.\n\n* If a user destructures variables\
        \ with correct names but in incorrect positions, a warning will be displayed\
        \ in IntelliJ.\n\nIf you donâ€™t want this class in a wider scope, you can restrict\
        \ its visibility. It can even be private if you only need to use it for some\
        \ local processing in a single file or class. It is worth using data classes\
        \ instead of tuples. Classes are cheap in Kotlin, so donâ€™t be afraid to use\
        \ them in your projects."
          - type: "text"
            stepId: "data-classes-section-9"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nIn this chapter, we've learned about `Any`, which is a\
        \ superclass of all classes. Weâ€™ve also learned about methods defined by `Any`:\
        \ `equals`, `hashCode`, and `toString`. Weâ€™ve also learned that there are\
        \ two primary types of objects. Regular objects are considered unique and\
        \ do not expose their details. Data class objects, which we made using the\
        \ `data` modifier, represent bundles of data (we keep them in primary constructor\
        \ properties). They are equal when they hold the same data. When transformed\
        \ to a string, they print all their data. They additionally support destructuring\
        \ and making a copy with the `copy` method. Two generic data classes in Kotlin\
        \ stdlib are `Pair` and `Triple`, but (apart from certain cases) we prefer\
        \ to use custom data classes instead of these. Also, for the sake of safety,\
        \ when we destructure a data class, we prefer to match the variable names\
        \ with the parameter names.\n\nNow, let's move on to a topic dedicated to\
        \ special Kotlin syntax that lets us create objects without defining a class.\n\
        \n[^11_0]: These are *Item 42: Respect the contract of `equals`* and *Item\
        \ 43: Respect the contract of `hashCode`*.\n[^11_1]: This type of class is\
        \ so popular that in Java it is common practice to auto-generate `equals`,\
        \ `hashCode`, and `toString` in IntelliJ or using the Lombok library.\n[^11_2]:\
        \ Kotlin had support for tuples when it was still in the beta version. We\
        \ were able to define a tuple by brackets and a set of types, like `(Int,\
        \ String, String, Long)`. What we achieved behaved the same as data classes\
        \ in the end, but it was far less readable. Can you guess what type this set\
        \ of types represents? It can be anything. Using tuples is tempting, but using\
        \ data classes is nearly always better. This is why tuples were removed, and\
        \ only `Pair` and `Triple` are left.\n[^11_3]: So `Any` is an analog to `Object`\
        \ in Java, JavaScript or C#. There is no direct analog in C++."
          - type: "single-answer"
            stepId: "data-classes-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "data-classes-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "data-classes-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "data-classes-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "data-classes-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "objects"
        name: "Objects"
        steps:
          - type: "text"
            stepId: "objects-introduction"
            question: "Objects"
            explanation: "Introduction to Objects"
            repetable: false
            text: "# Objects\n\nWhat is an object? This is the question I often start this\
        \ section with in my workshops, and I generally get an instant response, \"\
        An instance of a class\". That is right, but how do we create objects? One\
        \ way is easy: using constructors.\n\n```kotlin\nclass A\n\n// Using a constructor\
        \ to create an object\nval a = A()\n```\n\nHowever, this is not the only way.\
        \ In Kotlin, we can also create objects using **object expression** and **object\
        \ declaration**. Let's discuss these two options."
          - type: "text"
            stepId: "objects-section-1"
            question: "Object expressions"
            explanation: "Content for Object expressions"
            repetable: false
            text: "## Object expressions\n\nTo create an empty object using an expression,\
        \ we use the `object` keyword and braces. This syntax for creating objects\
        \ is known as *object expression*.\n\n```kotlin\nval instance = object {}\n\
        ```\n\nAn empty object extends no classes (except for `Any`, which is extended\
        \ by all objects in Kotlin), implements no interfaces, and has nothing inside\
        \ its body. Nevertheless, it is useful. Its power lies in its uniqueness:\
        \ such an object equals nothing else but itself. Therefore, it is perfectly\
        \ suited to be used as some kind of token or synchronization lock.\n\n```kotlin\n\
        class Box {\n    var value: Any? = NOT_SET\n\n    fun initialized() = value\
        \ != NOT_SET\n\n    companion object {\n        private val NOT_SET = object\
        \ {}\n    }\n}\n\nprivate val LOCK = object {}\nfun synchronizedOperation()\
        \ = synchronized(LOCK) {\n    // ...\n}\n```\n\nAn empty object can also be\
        \ created with the constructor of `Any`, so `Any()` is an alternative to `object\
        \ {}`.\n\n```kotlin\nprivate val NOT_SET = Any()\n```\n\nHowever, objects\
        \ created with an object expression do not need to be empty. They can have\
        \ bodies, extend classes, implement interfaces, etc. The syntax is the same\
        \ as for classes, but object declarations use the `object` keyword instead\
        \ of `class` and should not define the name or constructor.\n\n```kotlin\n\
        data class User(val name: String)\n\ninterface UserProducer {\n    fun produce():\
        \ User\n}\n\nfun printUser(producer: UserProducer) {\n    println(producer.produce())\n\
        }\n\nfun main() {\n    val user = User(\"Jake\")\n    val producer = object\
        \ : UserProducer {\n        override fun produce(): User = user\n    }\n \
        \   printUser(producer) // User(name=Jake)\n}\n```\n\nIn a local scope, object\
        \ expressions define an anonymous type that wonâ€™t work outside the class where\
        \ it is defined. This means the non-inherited members of object expressions\
        \ are accessible only when an anonymous object is declared in a local or class-private\
        \ scope; otherwise, the object is just an opaque `Any` type, or the type of\
        \ the class or interface it inherits from. This makes non-inherited members\
        \ of object expressions hard to use in real-life projects.\n\n```kotlin\n\
        class Robot {\n    // Possible, but rarely useful\n    // prefer regular member\
        \ properties instead\n    private val point = object {\n        var x = 0\n\
        \        var y = 0\n    }\n\n    fun moveUp() {\n        point.y += 10\n \
        \   }\n\n    fun show() {\n        println(\"(${point.x}, ${point.y})\")\n\
        \    }\n}\n\nfun main() {\n    val robot = Robot()\n    robot.show() // (0,\
        \ 0)\n    robot.moveUp()\n    robot.show() // (0, 10)\n\n    val point = object\
        \ {\n        var x = 0\n        var y = 0\n    }\n    println(point.x) //\
        \ 0\n    point.y = 10\n    println(point.y) // 10\n}\n```\n\nIn practice,\
        \ object expressions are used as an alternative to Java anonymous classes,\
        \ i.e., when we need to create a watcher or a listener with multiple handler\
        \ methods.\n\n```kotlin\ntaskNameView.addTextChangedListener(object : TextWatcher\
        \ {\n    override fun afterTextChanged(\n        editable: Editable?\n   \
        \ ) {\n        //...\n    }\n\n    override fun beforeTextChanged(\n     \
        \   text: CharSequence?,\n        start: Int,\n        count: Int,\n     \
        \   after: Int\n    ) {\n        //...\n    }\n\n    override fun onTextChanged(\n\
        \        text: CharSequence?,\n        start: Int,\n        before: Int,\n\
        \        count: Int\n    ) {\n        //...\n    }\n})\n```\n\nNote that \"\
        object expression\" is a better name than \"anonymous class\" since this is\
        \ an expression that produces an object."
          - type: "text"
            stepId: "objects-section-2"
            question: "Object declaration"
            explanation: "Content for Object declaration"
            repetable: false
            text: "## Object declaration\n\nIf we take an object expression and give it\
        \ a name, we get an **object declaration**. This structure also creates a\
        \ single object, but this object is not anonymous: it has a name that can\
        \ be used to reference it.\n\n```kotlin\nobject Point {\n    var x = 0\n \
        \   var y = 0\n}\n\nfun main() {\n    println(Point.x) // 0\n    Point.y =\
        \ 10\n    println(Point.y) // 10\n\n    val p = Point\n    p.x = 20\n    println(Point.x)\
        \ // 20\n    println(Point.y) // 10\n}\n```\n\nObject declaration is an implementation\
        \ of a singleton pattern[^12_4], so this declaration creates a class with\
        \ a single instance. Whenever we want to use this class, we need to operate\
        \ on this single instance. Object declarations support all the features that\
        \ classes support; for example, they can extend classes or implement interfaces.\n\
        \n```kotlin\ndata class User(val name: String)\n\ninterface UserProducer {\n\
        \    fun produce(): User\n}\n\nobject FakeUserProducer : UserProducer {\n\
        \    override fun produce(): User = User(\"fake\")\n}\n\nfun setUserProducer(producer:\
        \ UserProducer) {\n    println(producer.produce())\n}\n\nfun main() {\n  \
        \  setUserProducer(FakeUserProducer) // User(name=fake)\n}\n```"
          - type: "text"
            stepId: "objects-section-3"
            question: "Companion objects"
            explanation: "Content for Companion objects"
            repetable: false
            text: "## Companion objects\n\nWhen I reflect on the times when I worked as\
        \ a Java developer, I remember discussions about what features should be introduced\
        \ into that language. A common idea I often heard was introducing inheritance\
        \ for static elements. In the end, inheritance is very important in Java,\
        \ so why can't we use it for static elements? Kotlin has addressed this problem\
        \ with companion objects; however, to make that possible, it first needed\
        \ to eliminate actual static elements, i.e., elements that are called on classes,\
        \ not on objects.\n\n```\n// Java\nclass User {\n   // Static element definition\n\
        \   public static User empty() {\n       return new User();\n   }\n}\n\n//\
        \ Static element usage\nUser user = User.empty()\n```\n\nYes, we donâ€™t have\
        \ static elements in Kotlin, but we donâ€™t need them because we use object\
        \ declarations instead. If we define an object declaration in a class, it\
        \ is static by default (just like classes defined inside classes), so we can\
        \ directly call its elements.\n\n```kotlin\n// Kotlin\nclass User {\n    object\
        \ Producer {\n        fun empty() = User()\n    }\n}\n\n// Usage\nval user:\
        \ User = User.Producer.empty()\n```\n\nThis is not as convenient as static\
        \ elements, but we can improve it. If we use the `companion` keyword before\
        \ an object declaration defined inside a class, then we can call these object\
        \ methods implicitly \"on the class\".\n\n```kotlin\nclass User {\n    companion\
        \ object Producer {\n        fun empty() = User()\n    }\n}\n\n// Usage\n\
        val user: User = User.empty()\n// or\nval user: User = User.Producer.empty()\n\
        ```\n\nObjects with the `companion` modifier, also known as companion objects,\
        \ do not need an explicit name. Their default name is `Companion`.\n\n```kotlin\n\
        class User {\n    companion object {\n        fun empty() = User()\n    }\n\
        }\n\n// Usage\nval user: User = User.empty()\n// or\nval user: User = User.Companion.empty()\n\
        ```\n\nThis is how we achieved a syntax that is nearly as convenient as static\
        \ elements. The only inconvenience is that we must locate all the â€śstaticâ€ť\
        \ elements inside a single object (there can be only one companion object\
        \ in a class). This is a limitation, but we have something in return: companion\
        \ objects are objects, so they can extend classes or implement interfaces.\n\
        \nLet me show you an example. Letâ€™s say that you represent money in different\
        \ currencies using different classes like `USD`, `EUR`, or `PLN`. For convenience,\
        \ each of these defines `from` builder functions, which simplify object creation.\n\
        \n```kotlin\nimport java.math.BigDecimal\nimport java.math.MathContext\nimport\
        \ java.math.RoundingMode.HALF_EVEN\n\nabstract class Money(\n    val amount:\
        \ BigDecimal,\n    val currency: String\n)\n\nclass USD(amount: BigDecimal)\
        \ : Money(amount, \"USD\") {\n    companion object {\n        private val\
        \ MATH = MathContext(2, HALF_EVEN)\n        fun from(amount: Int): USD =\n\
        \            USD(amount.toBigDecimal(MATH))\n        fun from(amount: Double):\
        \ USD =\n            USD(amount.toBigDecimal(MATH))\n        fun from(amount:\
        \ String): USD =\n            USD(amount.toBigDecimal(MATH))\n    }\n}\n\n\
        class EUR(amount: BigDecimal) : Money(amount, \"EUR\") {\n    companion object\
        \ {\n        private val MATH = MathContext(2, HALF_EVEN)\n        fun from(amount:\
        \ Int): EUR =\n            EUR(amount.toBigDecimal(MATH))\n        fun from(amount:\
        \ Double): EUR =\n            EUR(amount.toBigDecimal(MATH))\n        fun\
        \ from(amount: String): EUR =\n            EUR(amount.toBigDecimal(MATH))\n\
        \    }\n}\n\nclass PLN(amount: BigDecimal) : Money(amount, \"PLN\") {\n  \
        \  companion object {\n        private val MATH = MathContext(2, HALF_EVEN)\n\
        \        fun from(amount: Int): PLN =\n            PLN(amount.toBigDecimal(MATH))\n\
        \        fun from(amount: Double): PLN =\n            PLN(amount.toBigDecimal(MATH))\n\
        \        fun from(amount: String): PLN =\n            PLN(amount.toBigDecimal(MATH))\n\
        \    }\n}\n\nfun main() {\n    val eur: EUR = EUR.from(\"12.00\")\n    val\
        \ pln: PLN = PLN.from(20)\n    val usd: USD = USD.from(32.5)\n}\n```\n\nThe\
        \ repetitive functions for creating objects from different types can be extracted\
        \ into an abstract `MoneyMaker` class, which can be extended by companion\
        \ objects of different currencies. This class can offer a range of methods\
        \ to create a currency. This way, we use companion object inheritance to extract\
        \ a pattern that is common to all companion objects of classes that represent\
        \ money.\n\n```kotlin\nimport java.math.BigDecimal\nimport java.math.MathContext\n\
        import java.math.RoundingMode.HALF_EVEN\n\nabstract class Money(\n    val\
        \ amount: BigDecimal,\n    val currency: String\n)\n\nabstract class MoneyMaker<M\
        \ : Money> {\n    private val MATH = MathContext(2, HALF_EVEN)\n    abstract\
        \ fun from(amount: BigDecimal): M\n    fun from(amount: Int): M = from(amount.toBigDecimal(MATH))\n\
        \    fun from(amount: Double): M = from(amount.toBigDecimal(MATH))\n    fun\
        \ from(amount: String): M = from(amount.toBigDecimal(MATH))\n}\n\nclass USD(amount:\
        \ BigDecimal) : Money(amount, \"USD\") {\n    companion object : MoneyMaker<USD>()\
        \ {\n        override fun from(amount: BigDecimal): USD = USD(amount)\n  \
        \  }\n}\n\nclass EUR(amount: BigDecimal) : Money(amount, \"EUR\") {\n    companion\
        \ object : MoneyMaker<EUR>() {\n        override fun from(amount: BigDecimal):\
        \ EUR = EUR(amount)\n    }\n}\n\nclass PLN(amount: BigDecimal) : Money(amount,\
        \ \"PLN\") {\n    companion object : MoneyMaker<PLN>() {\n        override\
        \ fun from(amount: BigDecimal): PLN = PLN(amount)\n    }\n}\n\nfun main()\
        \ {\n    val eur: EUR = EUR.from(\"12.00\")\n    val pln: PLN = PLN.from(20)\n\
        \    val usd: USD = USD.from(32.5)\n}\n```\n\nOur community is still learning\
        \ how to use these capabilities, but you can already find plenty of examples\
        \ in projects and libraries. Here are a few interesting examples[^12_6]:\n\
        \n```kotlin\n// Using companion object inheritance for logging\n// from the\
        \ Kotlin Logging framework\nclass FooWithLogging {\n    fun bar(item: Item)\
        \ {\n        logger.info { \"Item $item\" }\n        // Logger comes from\
        \ the companion object\n    }\n\n    companion object : KLogging()\n    //\
        \ companion inherits logger property\n}\n```\n\n```kotlin\n// Android-specific\
        \ example of using an abstract factory \n// for companion object\nclass MainActivity\
        \ : Activity() {\n    //...\n\n    // Using companion object as a factory\n\
        \    companion object : ActivityFactory() {\n        override fun getIntent(context:\
        \ Context): Intent =\n            Intent(context, MainActivity::class.java)\n\
        \    }\n}\n\nabstract class ActivityFactory {\n    abstract fun getIntent(context:\
        \ Context): Intent\n\n    fun start(context: Context) {\n        val intent\
        \ = getIntent(context)\n        context.startActivity(intent)\n    }\n\n \
        \   fun startForResult(activity: Activity, requestCode: Int) {\n        val\
        \ intent = getIntent(activity)\n        activity.startActivityForResult(intent,\
        \ requestCode)\n    }\n}\n```\n\n```kotlin\n// Usage of all the members of\
        \ the companion ActivityFactory\nval intent = MainActivity.getIntent(context)\n\
        MainActivity.start(context)\nMainActivity.startForResult(activity, requestCode)\n\
        \n// In contexts on Kotlin Coroutines, companion objects are\n// used as keys\
        \ to identify contexts\ndata class CoroutineName(\n    val name: String\n\
        ) : AbstractCoroutineContextElement(CoroutineName) {\n\n    // Companion object\
        \ is a key\n    companion object Key : CoroutineContext.Key<CoroutineName>\n\
        \n    override fun toString(): String = \"CoroutineName($name)\"\n}\n\n//\
        \ Finding a context by key\nval name1 = context[CoroutineName] // Yes, this\
        \ is a companion\n\n// You can also refer to companion objects by its name\n\
        val name2 = context[CoroutineName.Key]\n```"
          - type: "text"
            stepId: "objects-section-4"
            question: "Data object declarations"
            explanation: "Content for Data object declarations"
            repetable: false
            text: "## Data object declarations\n\nSince Kotlin 1.8, you can use the `data`\
        \ modifier for object declarations. It generates the `toString` method for\
        \ the object; this method includes the object name as a string.\n\n```kotlin\n\
        data object ABC\n\nfun main() {\n    println(ABC) // ABC\n}\n```"
          - type: "text"
            stepId: "objects-section-5"
            question: "Constant values"
            explanation: "Content for Constant values"
            repetable: false
            text: "## Constant values\n\nItâ€™s common practice to generally extract constant\
        \ values as properties of companion objects and name them using UPPER_SNAKE_CASE[^12_5].\
        \ This way, we name those values and simplify their changes in the future.\
        \ We name constant values in a characteristic way to make it clear that they\
        \ represent a constant[^12_2].\n\n```kotlin\nclass Product(\n    val code:\
        \ String,\n    val price: Double,\n) {\n    init {\n        require(price\
        \ > MIN_AMOUNT)\n    }\n\n    companion object {\n        val MIN_AMOUNT =\
        \ 5.00\n    }\n}\n```\n\nWhen companion object properties or top-level properties\
        \ represent a constant value (known at compile time) that is either a primitive\
        \ or a `String`[^12_3], we can add the `const` modifier. This is an optimization.\
        \ All usages of such variables will be replaced with their values at compile\
        \ time.\n\n```kotlin\nclass Product(\n    val code: String,\n    val price:\
        \ Double,\n) {\n    init {\n        require(price > MIN_AMOUNT)\n    }\n\n\
        \    companion object {\n        const val MIN_AMOUNT = 5.00\n    }\n}\n```\n\
        \nSuch properties can also be used in annotations:\n\n```kotlin\nprivate const\
        \ val OUTDATED_API: String =\n    \"This is a part of an outdated API.\"\n\
        \n@Deprecated(OUTDATED_API)\nfun foo() {\n    ...\n}\n\n@Deprecated(OUTDATED_API)\n\
        fun boo() {\n    ...\n}\n```"
          - type: "text"
            stepId: "objects-section-6"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nIn this chapter, we've learned that objects can be created\
        \ not only from classes but also using object expressions and object declarations.\
        \ Both these kinds of objects have practical usages. Object expression is\
        \ used as an alternative to Java anonymous objects, but it offers more. Object\
        \ declaration is Kotlin's implementation of the singleton pattern. A special\
        \ form of object declaration, known as a companion object, is used as an alternative\
        \ to static elements but with additional support for inheritance. We also\
        \ have the `const` modifier, which offers better support for constant elements\
        \ defined at the top level or in object declarations.\n\nIn the previous chapter,\
        \ we discussed data classes, but there are other modifiers we use for classes\
        \ in Kotlin. In the next chapter, we will learn about another important type\
        \ of class: exceptions.\n\n[^12_2]: This practice is better described in *Effective\
        \ Kotlin*, *Item 26: Use abstraction to protect code against changes*.\n[^12_3]:\
        \ So, the accepted types are `Int`, `Long`, `Double`, `Float`, `Short`, `Byte`,\
        \ `Boolean`, `Char`, and `String`.\n[^12_4]: A programming pattern where a\
        \ class is implemented such that it can have only one instance.\n[^12_5]:\
        \ UPPER_SNAKE_CASE is a naming convention where each character is capitalized,\
        \ and we separate words with an underscore, like in the UPPER_SNAKE_CASE name.\
        \ Using it for constants is suggested in the Kotlin documentation in the section\
        \ *Kotlin Coding Convention*.\n[^12_6]: Do not treat them as best practices\
        \ but rather as examples of what you might do with the fact that companion\
        \ objects can inherit from classes and implement interfaces."
          - type: "single-answer"
            stepId: "objects-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "objects-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "objects-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "objects-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "objects-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "exceptions"
        name: "Exceptions"
        steps:
          - type: "text"
            stepId: "exceptions-introduction"
            question: "Exceptions"
            explanation: "Introduction to Exceptions"
            repetable: false
            text: "# Exceptions\n\nAn exception is a generally unwanted event that interrupts\
        \ the regular flow of your program. It might occur when you perform an illegal\
        \ operation. Exceptions contain information that helps developers find out\
        \ what led to this problem.\n\nLet's take a look at an example. When you divide\
        \ an integer by 0, an exception of type `ArithmeticException` will be thrown.\
        \ Each exception might have a message included that should explain what went\
        \ wrong. In this case, the message will be \"/ by zero\". Each exception also\
        \ includes its stack trace, which is a list of the method calls that the application\
        \ was in the middle of when the exception was thrown. In this example, it\
        \ includes information that this exception was thrown from the `calculate`\
        \ function, which was called from the `printCalculated` function, which was\
        \ called from the `main` function. Exception interrupts program execution,\
        \ so statements after it won't be executed. In the example below, notice that\
        \ \"After\" is never printed.\n\n```kotlin\nprivate fun calculate(): Int {\n\
        \    return 1 / 0\n}\n\nprivate fun printCalculated() {\n    println(calculate())\n\
        }\n\nfun main() {\n    println(\"Before\")\n    printCalculated()\n    println(\"\
        After\")\n}\n// Before\n// Exception java.lang.ArithmeticException: / by zero\n\
        //     at PlaygroundKt.calculate(Playground.kt:2)\n//     at PlaygroundKt.printCalculated(Playground.kt:6)\n\
        //     at PlaygroundKt.main(Playground.kt:11)\n//     at PlaygroundKt.main(Playground.kt)\n\
        ```\n\nAs another example, we can parse a string to an integer using the `toInt`\
        \ method, but this only works when the string is a number. When it isnâ€™t,\
        \ we will see `NumberFormatException` with a message explaining which string\
        \ was used.\n\n```kotlin\nfun main() {\n    val i1 = \"10\".toInt()\n    println(i1)\n\
        \    val i2 = \"ABC\".toInt()\n    println(i2)\n}\n// 10\n// Exception in\
        \ thread \"main\" java.lang.NumberFormatException:\n// For input string: \"\
        ABC\"\n//   at java.base/java.lang.NumberFormatException.\n//   forInputString(NumberFormatException.java:67)\n\
        //   at java.base/java.lang.Integer.parseInt(Integer.java:660)\n//   at java.base/java.lang.Integer.parseInt(Integer.java:778)\n\
        //   at PlaygroundKt.main(Playground.kt:4)\n//   at PlaygroundKt.main(Playground.kt)\n\
        ```"
          - type: "text"
            stepId: "exceptions-section-1"
            question: "Throwing exceptions"
            explanation: "Content for Throwing exceptions"
            repetable: false
            text: "## Throwing exceptions\n\nWe can throw exceptions ourselves using the\
        \ `throw` keyword and a value that can be used as an exception, like the aforementioned\
        \ `ArithmeticException` or `NumberFormatException`.\n\n```kotlin\nprivate\
        \ fun functionThrowing() {\n    throw ArithmeticException(\"Some message\"\
        )\n}\n\nfun main() {\n    println(\"Before\")\n    functionThrowing()\n  \
        \  println(\"After\")\n}\n// Before\n// Exception in thread \"main\" java.lang.ArithmeticException:\n\
        // Some message\n//  at PlaygroundKt.functionThrowing(Playground.kt:2)\n//\
        \  at PlaygroundKt.main(Playground.kt:7)\n//  at PlaygroundKt.main(Playground.kt)\n\
        ```\n\nExceptions communicate conditions that a function is not prepared to\
        \ handle or is not responsible for. This isnâ€™t necessarily an indication of\
        \ an error; itâ€™s more like a notification event that can be dealt with in\
        \ another place that is set up to catch it."
          - type: "text"
            stepId: "exceptions-section-2"
            question: "Defining exceptions"
            explanation: "Content for Defining exceptions"
            repetable: false
            text: "## Defining exceptions\n\nWe can also define our own exceptions. These\
        \ are regular classes declarations that extend the `Throwable` class. Every\
        \ such class can be thrown using `throw`.\n\n```kotlin\nclass MyException\
        \ : Throwable(\"Some message\")\n\nprivate fun functionThrowing() {\n    throw\
        \ MyException()\n    // or throw MyExceptionObject\n}\n\nfun main() {\n  \
        \  println(\"Before\")\n    functionThrowing()\n    println(\"After\")\n}\n\
        // Before\n// Exception in thread \"main\" MyException: Some message\n// \
        \ at PlaygroundKt.functionThrowing(Playground.kt:4)\n//  at PlaygroundKt.main(Playground.kt:9)\n\
        //  at PlaygroundKt.main(Playground.kt)\n```\n\n> Beware! Exceptions cannot\
        \ be defined as object declarations because each exception keeps mutable stack\
        \ trace information."
          - type: "text"
            stepId: "exceptions-section-3"
            question: "Catching exceptions"
            explanation: "Content for Catching exceptions"
            repetable: false
            text: "## Catching exceptions\n\nJust like exceptions can be thrown, they can\
        \ be caught using a try-catch structure that contains a try-block and a catch-block.\
        \ An exception thrown in a function immediately ends this functionâ€™s execution,\
        \ and the process repeats in the function that called the function in which\
        \ the exception was thrown. This changes when an exception is thrown inside\
        \ a try-block, because then its catch-blocks are checked. Each catch-block\
        \ can specify what type of exceptions it catches. The first catch-block that\
        \ accepts the exception that was thrown will catch it and then execute its\
        \ body. If an exception is caught, the execution of the program continues\
        \ after the try block.\n\n```kotlin\nclass MyException : Throwable(\"Some\
        \ message\")\n\nfun someFunction() {\n    throw MyException()\n    println(\"\
        Will not be printed\")\n}\n\nfun main() {\n    try {\n        someFunction()\n\
        \        println(\"Will not be printed\")\n    } catch (e: MyException) {\n\
        \        println(\"Caught $e\")\n        // Caught MyException: Some message\n\
        \    }\n}\n```\n\nLet's see try-catch with more catch-blocks in action. Remember\
        \ that the first block that accepts an exception is always chosen. A catch-block\
        \ accepts an exception if this exception is a subtype of the type specified\
        \ in the catch-block. Note that all exceptions must extend `Throwable`, so\
        \ catching this type means catching all possible exceptions.\n\n```kotlin\n\
        import java.lang.NumberFormatException\n\nclass MyException : Throwable(\"\
        Some message\")\n\nfun testTryCatch(exception: Throwable) {\n    try {\n \
        \       throw exception\n    } catch (e: ArithmeticException) {\n        println(\"\
        Got ArithmeticException\")\n    } catch (e: MyException) {\n        println(\"\
        Got MyException\")\n    } catch (e: Throwable) {\n        println(\"Got some\
        \ exception\")\n    }\n}\n\nfun main() {\n    testTryCatch(ArithmeticException())\n\
        \    // Got ArithmeticException\n    testTryCatch(MyException())\n    // Got\
        \ MyException\n    testTryCatch(NumberFormatException())\n    // Got some\
        \ exception\n}\n```"
          - type: "text"
            stepId: "exceptions-section-4"
            question: "A try-catch block used as an expression"
            explanation: "Content for A try-catch block used as an expression"
            repetable: false
            text: "## A try-catch block used as an expression\n\nThe try-catch structure\
        \ can be used as an expression. It returns the result of a try-block if no\
        \ exception occurred. If an exception occurs and is caught, then the try-catch\
        \ expression returns the result of the catch-block.\n\n```kotlin\nfun main()\
        \ {\n    val a = try {\n        1\n    } catch (e: Error) {\n        2\n \
        \   }\n    println(a) // 1\n\n    val b = try {\n        throw Error()\n \
        \       1\n    } catch (e: Error) {\n        2\n    }\n    println(b) // 2\n\
        }\n```\n\nA try-catch expression can be used to provide an alternative value\
        \ for a situation in which a problem occurs:\n\n```kotlin\nimport java.io.File\n\
        import java.io.FileNotFoundException\n\nfun main() {\n    val content = try\
        \ {\n        File(\"AAA\").readText()\n    } catch (e: FileNotFoundException)\
        \ {\n        \"\"\n    }\n    println(content) // (empty string)\n}\n```\n\
        \nA practical example might be reading a string containing an object in JSON\
        \ format. We use the Gson library, whose `fromJson` method throws `JsonSyntaxException`\
        \ when a string does not contain a proper JSON object. Instead, we would prefer\
        \ a function that returns `null` in such cases; we can implement this using\
        \ try-catch as an expression.\n\n```kotlin\nfun <T : Any> fromJsonOrNull(\n\
        \    json: String,\n    clazz: KClass<T>\n): T? = try {\n    gson.fromJson(json,\
        \ clazz.java)\n} catch (e: JsonSyntaxException) {\n    null\n}\n```"
          - type: "text"
            stepId: "exceptions-section-5"
            question: "The finally block"
            explanation: "Content for The finally block"
            repetable: false
            text: "## The finally block\n\nInside the try-structure, we can also use a finally-block,\
        \ which is used to specify what should always be invoked, even if an exception\
        \ occurs. This block does not catch any exceptions; it is used to guarantee\
        \ that some operations will be executed, no matter the exceptions.\n\nTake\
        \ a look at the code below. An exception is thrown inside `someFunction`.\
        \ This exception ends this functionâ€™s execution and skips the rest of the\
        \ try-block. Since we do not have a catch-block, this exception will not be\
        \ caught, thus ending the execution of the `main` function. However, there\
        \ is also the finally-block, whose body is invoked even if an exception occurs.\n\
        \n```kotlin\nfun someFunction() {\n    throw Throwable(\"Some error\")\n}\n\
        \nfun main() {\n    try {\n        someFunction()\n    } finally {\n     \
        \   println(\"Finally block was called\")\n    }\n    println(\"Will not be\
        \ printed\")\n}\n// Finally block was called\n```\n\nThe finally-block is\
        \ also invoked when the try-block finishes without an exception.\n\n```kotlin\n\
        fun someFunction() {\n    println(\"Function called\")\n}\n\nfun main() {\n\
        \    try {\n        someFunction()\n        println(\"After call\")\n    }\
        \ finally {\n        println(\"Finally block was called\")\n    }\n    println(\"\
        After try-finally\")\n}\n// Function called\n// After call\n// Finally block\
        \ was called\n// After try-finally\n```\n\nWe use the finally-block to do\
        \ operations that should always be done, no matter if an exception occurs\
        \ or not. It typically involves closing connections or cleaning up resources."
          - type: "text"
            stepId: "exceptions-section-6"
            question: "Important exceptions"
            explanation: "Content for Important exceptions"
            repetable: false
            text: "## Important exceptions\n\nA few kinds of exceptions are defined in Kotlin\
        \ that we use in certain situations. The most important ones are:\n- `IllegalArgumentException`\
        \ - we use this when an argument has an incorrect value. For example, when\
        \ you expect your argument value to be bigger than 0 but it is not.\n- `IllegalStateException`\
        \ - we use this when the state of our system is incorrect. This means the\
        \ values of properties are not accepted by a function call.\n\n```kotlin\n\
        fun findClusters(number: Int) {\n    if (number < 1) {\n        throw IllegalArgumentException(\"\
        ...\")\n    }\n    // ...\n}\n\nvar userName = \"\"\n\nfun printUserName()\
        \ {\n    if (userName == \"\") {\n        throw IllegalStateException(\"Name\
        \ must not be empty\")\n    }\n    // ...\n}\n```\n\nIn Kotlin, we use the\
        \ `require` and `check` functions to throw `IllegalArgumentException` and\
        \ `IllegalStateException` when their conditions are not satisfied[^e_1].\n\
        \n```kotlin\nfun pop(num: Int): List<T> {\n    require(num <= size)\n    //\
        \ throws IllegalArgumentException if num > size\n    check(isOpen)\n    //\
        \ throws IllegalStateException if is not open\n    val ret = collection.take(num)\n\
        \    collection = collection.drop(num)\n    return ret\n}\n```\n\nThere is\
        \ also an `error` function from Kotlin stdlib that throws `IllegalArgumentException`\
        \ with a message specified as an argument. It is often used as a body for\
        \ a branch in a when-condition, on the right side of the Elvis operator, or\
        \ in an if-else expression.\n\n```kotlin\nfun makeOperation(\n    operation:\
        \ String,\n    left: Int,\n    right: Int? = null\n): Int = when (operation)\
        \ {\n    \"add\" ->\n        left + (right ?: error(\"Two numbers required\"\
        ))\n    \"subtract\" ->\n        left - (right ?: error(\"Two numbers required\"\
        ))\n    \"opposite\" -> -left\n    else -> error(\"Unknown operation\")\n\
        }\n\nfun main() {\n    println(makeOperation(\"add\", 1, 2)) // 3\n    println(makeOperation(\"\
        subtract\", 1, 2)) // -1\n    println(makeOperation(\"opposite\", 10)) //\
        \ -10\n\n    makeOperation(\"add\", 1) // ERROR!\n    // IllegalStateException:\
        \ Two numbers required\n    makeOperation(\"subtract\", 1) // ERROR!\n   \
        \ // IllegalStateException: Two numbers required\n    makeOperation(\"other\"\
        , 1, 2) // ERROR!\n    // IllegalStateException: Unknown operation\n}\n```"
          - type: "text"
            stepId: "exceptions-section-7"
            question: "The hierarchy of exceptions"
            explanation: "Content for The hierarchy of exceptions"
            repetable: false
            text: "## The hierarchy of exceptions\n\nThe most important subtypes of `Throwable`\
        \ are `Error` and `Exception`. These represent two types of exceptions:\n\
        * `Error` type represents exceptions that are impossible to recover from and\
        \ consequently should not be caught, at least not without throwing them again\
        \ in catch-block. Exceptions that are impossible to recover from include `OutOfMemoryError`,\
        \ which is thrown when there is insufficient space in the JVM heap.\n* `Exception`\
        \ type represents exceptions we can recover from using a try-catch block.\
        \ This group includes `IllegalArgumentException`, `IllegalStateException`,\
        \ `ArithmeticException`, and `NumberFormatException`.\n\nIn most cases, when\
        \ we define custom exceptions, we should use the `Exception` superclass; when\
        \ we catch exceptions, we should only throw subtypes of `Exception`.\n\n![](exception_hierarchy.png)\n\
        \nIn Kotlin, we are not forced to catch any kinds of exceptions; so, unlike\
        \ in some other languages, there are no checked exceptions."
          - type: "text"
            stepId: "exceptions-section-8"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nIn this chapter weâ€™ve learned about exceptions, which are\
        \ an important part of Kotlin programming. Weâ€™ve learned how to throw, catch,\
        \ and define exceptions. Weâ€™ve also learned about the finally-block and the\
        \ exceptions hierarchy.\n\nContinuing with special kinds of classes, let's\
        \ talk about enum classes, which are used to represent a set of object instance\
        \ values.\n\n[^e_1]: This topic is better described in the Effective Kotlin\
        \ book, *Item 5: Specify your expectations for arguments and state*."
          - type: "single-answer"
            stepId: "exceptions-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "exceptions-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "exceptions-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "exceptions-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "exceptions-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "enum"
        name: "Enum classes"
        steps:
          - type: "text"
            stepId: "enum-introduction"
            question: "Enum classes"
            explanation: "Introduction to Enum classes"
            repetable: false
            text: "# Enum classes\r\n\r\nIn this chapter, we're going to introduce the concept\
        \ of enum classes. Let's start with an example. Suppose that youâ€™re implementing\
        \ a payment method that has to support three possible options: cash payment,\
        \ card payment, and bank transfer. The most basic way to represent a fixed\
        \ set of values in Kotlin is an enum class. Inside its body, we list all the\
        \ values, divided by a comma. We name values using UPPER_SNAKE_CASE notation\
        \ (e.g., `BANK_TRANSFER`). Enum class elements can be referenced by the enum\
        \ name, followed by a dot, and then the value name (e.g., `PaymentOption.CASH`).\
        \ All values are typed as the enum class type.\r\n\r\n```kotlin\r\nenum class\
        \ PaymentOption {\r\n    CASH,\r\n    CARD,\r\n    TRANSFER,\r\n}\r\n\r\n\
        fun printOption(option: PaymentOption) {\r\n    println(option)\r\n}\r\n\r\
        \nfun main() {\r\n    val option: PaymentOption = PaymentOption.CARD\r\n \
        \   println(option) // CARD\r\n    printOption(option) // CARD\r\n}\r\n```\r\
        \n\r\nEach enum class has the following companion object elements:\r\n* `entries`\
        \ property, which keeps a list of all the values of this enum class. It is\
        \ a modern replacement of the `values` function, that returns an array of\
        \ elements[^13_3].\r\n* `valueOf` function, which parses a string into a value\
        \ matching its name (this is case-sensitive) or throws an exception.\r\n\r\
        \n```kotlin\r\nenum class PaymentOption {\r\n    CASH,\r\n    CARD,\r\n  \
        \  TRANSFER,\r\n}\r\n\r\nfun main() {\r\n    val option: PaymentOption =\r\
        \n        PaymentOption.valueOf(\"TRANSFER\")\r\n    println(option)\r\n\r\
        \n    println(\"All options: \")\r\n    val paymentOptions: List<PaymentOption>\
        \ =\r\n        PaymentOption.entries\r\n    for (paymentOption in paymentOptions)\
        \ {\r\n        println(paymentOption)\r\n    }\r\n}\r\n// TRANSFER\r\n// All\
        \ options:\r\n// CASH\r\n// CARD\r\n// TRANSFER\r\n```\r\n\r\nInstead of these\
        \ methods, we can also use the top-level `enumValues` and `enumValueOf` functions.\r\
        \n\r\n```kotlin\r\nenum class PaymentOption {\r\n    CASH,\r\n    CARD,\r\n\
        \    TRANSFER,\r\n}\r\n\r\nfun main() {\r\n    val option = enumValueOf<PaymentOption>(\"\
        TRANSFER\")\r\n    println(option)\r\n\r\n    println(\"All options: \")\r\
        \n    val paymentOptions = enumValues<PaymentOption>()\r\n    for (paymentOption\
        \ in paymentOptions) {\r\n        println(paymentOption)\r\n    }\r\n}\r\n\
        // TRANSFER\r\n// All options:\r\n// CASH\r\n// CARD\r\n// TRANSFER\r\n```\r\
        \n\r\nAs you can see, enum elements keep their values in order. This order\
        \ is important. Each enum value has two properties:\r\n* `name` - the name\
        \ of this value,\r\n* `ordinal` - the position of this value (starting from\
        \ 0).\r\n\r\n```kotlin\r\nenum class PaymentOption {\r\n    CASH,\r\n    CARD,\r\
        \n    TRANSFER,\r\n}\r\n\r\nfun main() {\r\n    val option = PaymentOption.TRANSFER\r\
        \n    println(option.name) // TRANSFER\r\n    println(option.ordinal) // 2\r\
        \n}\r\n```\r\n\r\nEach enum class is a subclass of the abstract class `Enum`.\
        \ This superclass guarantees the `name` and `ordinal` properties. Enum classes\
        \ have properties that implement `toString`, `equals`, and `hashCode`, but,\
        \ unlike data classes, they also have `compareTo` (their natural order is\
        \ the order of the elements in the body).\r\n\r\nEnum values can be used inside\
        \ when-conditions. Moreover, there is no need to use the else-branch when\
        \ all possible enum values are covered.\r\n\r\n```kotlin\r\nfun transactionFee(paymentOption:\
        \ PaymentOption): Double =\r\n    when (paymentOption) {\r\n        PaymentOption.CASH\
        \ -> 0.0\r\n        PaymentOption.CARD, PaymentOption.TRANSFER -> 0.05\r\n\
        \    }\r\n```\r\n\r\nEnum classes are very convenient because they can be\
        \ easily parsed or stringified. They are a popular way to represent a finite\
        \ set of possible values."
          - type: "text"
            stepId: "enum-section-1"
            question: "Data in enum values"
            explanation: "Content for Data in enum values"
            repetable: false
            text: "## Data in enum values\n\nIn Kotlin, each enum value can hold a state.\
        \ It is possible to define a primary constructor for an enum class, and then\
        \ each value needs to specify its data next to its name. **It is the best\
        \ practice that enum values should always be immutable, so their state should\
        \ never change**.\r\n\r\n```kotlin\r\nimport java.math.BigDecimal\r\n\r\n\
        enum class PaymentOption(val commission: BigDecimal) {\r\n    CASH(BigDecimal.ONE),\r\
        \n    CARD(BigDecimal.TEN),\r\n    TRANSFER(BigDecimal.ZERO)\r\n}\r\n\r\n\
        fun main() {\r\n    println(PaymentOption.CARD.commission) // 10\r\n    println(PaymentOption.TRANSFER.commission)\
        \ // 0\r\n\r\n    val paymentOption: PaymentOption =\r\n        PaymentOption.entries.random()\r\
        \n    println(paymentOption.commission) // 0, 1 or 10\r\n}\r\n```"
          - type: "text"
            stepId: "enum-section-2"
            question: "Enum classes with custom methods"
            explanation: "Content for Enum classes with custom methods"
            repetable: false
            text: "## Enum classes with custom methods\n\nKotlin enums can have abstract\
        \ methods whose implementations are item-specific. When we define them, the\
        \ enum class itself needs to define an abstract method, and each item must\
        \ override it:\r\n\r\n```kotlin\r\nenum class PaymentOption {\r\n    CASH\
        \ {\r\n        override fun startPayment(\r\n            transaction: Transaction\r\
        \n        ) {\r\n            showCashPaymentInfo(transaction)\r\n        }\r\
        \n    },\r\n    CARD {\r\n        override fun startPayment(\r\n         \
        \   transaction: Transaction\r\n        ) {\r\n            moveToCardPaymentPage(transaction)\r\
        \n        }\r\n    },\r\n    TRANSFER {\r\n        override fun startPayment(\r\
        \n            transaction: Transaction\r\n        ) {\r\n            showMoneyTransferInfo()\r\
        \n            setupPaymentWatcher(transaction)\r\n        }\r\n    };\r\n\r\
        \n    abstract fun startPayment(transaction: Transaction)\r\n}\r\n```\r\n\r\
        \nThis option is not popular as we generally prefer using functional primary\
        \ constructor parameters[^13_1] or extension functions[^13_2]."
          - type: "text"
            stepId: "enum-section-3"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nEnum classes are a convenient way to represent a concrete\
        \ set of possible values. Each value has the properties `name` and `ordinal`\
        \ (position). We can get an array of all values using the `values` companion\
        \ object function or the `enumValues` top-level function. We can also parse\
        \ an enum value from `String` using the `valueOf` companion object function\
        \ or the `enumValueOf` top-level function.\r\n\r\nIn the next chapter, we\
        \ will talk about sealed classes, which are often treated as similar to enums\
        \ but represent completely different and even more powerful abstractions.\
        \ Sealed classes can form a closed hierarchy of classes, whereas enums represent\
        \ only a set of constant values.\r\n\r\n[^13_1]: Functional variables are\
        \ described in the book *Functional Kotlin*. An example of using an enum class\
        \ with functional primary constructor parameters is presented in *Effective\
        \ Kotlin*, *Item 41: Use enum to represent a list of values*.\r\n[^13_2]:\
        \ Extension functions are described later in this book.\r\n[^13_3]: `entries`\
        \ property was introduced in Kotlin 1.9, so in projects using older versions\
        \ of Kotlin you need to use `values` instead."
          - type: "single-answer"
            stepId: "enum-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "enum-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "enum-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "enum-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "enum-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "sealed"
        name: "Sealed classes and interfaces"
        steps:
          - type: "text"
            stepId: "sealed-introduction"
            question: "Sealed classes and interfaces"
            explanation: "Introduction to Sealed classes and interfaces"
            repetable: false
            text: "# Sealed classes and interfaces\n\nClasses and interfaces in Kotlin are\
        \ not only used to represent a set of operations or data; we can also use\
        \ classes and inheritance to represent hierarchies through polymorphism. For\
        \ instance, let's say that you send a network request; as a result, you either\
        \ successfully receive the requested data, or the request fails with some\
        \ information about what went wrong. These two outcomes can be represented\
        \ using two classes that implement an interface:\n\n```kotlin\ninterface Result\n\
        class Success(val data: String) : Result\nclass Failure(val exception: Throwable)\
        \ : Result\n```\n\nAlternatively, you could use an abstract class:\n\n```kotlin\n\
        abstract class Result\nclass Success(val data: String) : Result()\nclass Failure(val\
        \ exception: Throwable) : Result()\n```\n\nWith either of these, we know that\
        \ when a function returns `Result`, it can be `Success` or `Failure`.\n\n\
        ```kotlin\nval result: Result = getSomeData()\nwhen (result) {\n    is Success\
        \ -> handleSuccess(result.data)\n    is Failure -> handleFailure(result.exception)\n\
        }\n```\n\nThe problem is that when a regular interface or abstract class is\
        \ used, there is no guarantee that its defined subclasses are all possible\
        \ subtypes of this interface or abstract class. Someone might define another\
        \ class and make it implement `Result`. Someone might also implement an object\
        \ expression that implements `Result`.\n\n```kotlin\nclass FakeSuccess : Result\n\
        \nval res: Result = object : Result {}\n```\n\nA hierarchy whose subclasses\
        \ are not known in advance is known as a non-restricted hierarchy. For `Result`,\
        \ we prefer to define a restricted hierarchy, which we do by using a `sealed`\
        \ modifier before a class or an interface[^14_0].\n\n```kotlin\nsealed interface\
        \ Result\nclass Success(val data: String) : Result\nclass Failure(val exception:\
        \ Throwable) : Result\n\n// or\n\nsealed class Result\nclass Success(val data:\
        \ String) : Result()\nclass Failure(val exception: Throwable) : Result()\n\
        ```\n\n> When we use the `sealed` modifier before a class, it makes this class\
        \ abstract already, so we donâ€™t use the `abstract` modifier.\n\nThere are\
        \ a few requirements that all sealed class or interface children must meet:\n\
        * they need to be defined in the same package and module where the sealed\
        \ class or interface is,\n* they can't be local or defined using object expression.\n\
        \nThis means that when you use the `sealed` modifier, you control which subclasses\
        \ a class or interface has. The clients of your library or module cannot add\
        \ their own direct subclasses[^14_2]. No one can quietly add a local class\
        \ or object expression that extends a sealed class or interface. Kotlin has\
        \ made this impossible. The hierarchy of subclasses is restricted.\n\n> Sealed\
        \ interfaces were introduced in more recent versions of Kotlin to allow classes\
        \ to implement multiple sealed hierarchies. The relation between a sealed\
        \ class and a sealed interface is similar to the relation between an abstract\
        \ class and an interface. The power of classes is that they can keep a state\
        \ (non-abstract properties) and control their members' openness (can have\
        \ final methods and properties). The power of interfaces is that a class can\
        \ inherit from only one class but it can implement multiple interfaces."
          - type: "text"
            stepId: "sealed-section-1"
            question: "Sealed classes and `when` expressions"
            explanation: "Content for Sealed classes and `when` expressions"
            repetable: false
            text: "## Sealed classes and `when` expressions\n\nUsing `when` as an expression\
        \ must return some value, so it must be exhaustive. In most cases, the only\
        \ way to achieve this is to specify an `else` clause.\n\n```kotlin\nfun commentValue(value:\
        \ String) = when {\n    value.isEmpty() -> \"Should not be empty\"\n    value.length\
        \ < 5 -> \"Too short\"\n    else -> \"Correct\"\n}\n\nfun main() {\n    println(commentValue(\"\
        \")) // Should not be empty\n    println(commentValue(\"ABC\")) // Too short\n\
        \    println(commentValue(\"ABCDEF\")) // Correct\n}\n```\n\nHowever, there\
        \ are also cases in which Kotlin knows that we have specified all possible\
        \ values. For example, when we use a when-expression with an enum value and\
        \ we compare this value to all possible enum values.\n\n```kotlin\nenum class\
        \ PaymentType {\n    CASH,\n    CARD,\n    CHECK\n}\n\nfun commentDecision(type:\
        \ PaymentType) = when (type) {\n    PaymentType.CASH -> \"I will pay with\
        \ cash\"\n    PaymentType.CARD -> \"I will pay with card\"\n    PaymentType.CHECK\
        \ -> \"I will pay with check\"\n}\n```\n\nThe power of having a finite set\
        \ of types as an argument makes it possible to have an exhaustive `when` with\
        \ a branch for every possible value. In the case of sealed classes or interfaces,\
        \ this means having `is` checks for all possible subtypes.\n\n```kotlin\n\
        sealed class Response<out V>\nclass Success<V>(val value: V) : Response<V>()\n\
        class Failure(val error: Throwable) : Response<Nothing>()\n\nfun handle(response:\
        \ Response<String>) {\n    val text = when (response) {\n        is Success\
        \ -> \"Success with ${response.value}\"\n        is Failure -> \"Error\"\n\
        \        // else is not needed here\n    }\n    print(text)\n}\n```\n\nAlso,\
        \ IntelliJ automatically suggests adding the remaining branches. This makes\
        \ sealed classes very convenient when we need to cover all possible types.\n\
        \n![](remaining_branches.png)\n\nNote that when an `else` clause is not used\
        \ and we add another subclass of this sealed class, the usage needs to be\
        \ adjusted by including this new type. This is convenient in local code as\
        \ it forces us to handle this new class in exhaustive `when` expressions.\
        \ The inconvenient part is that when this sealed class is part of the public\
        \ API of a library or shared module, adding a subtype is a breaking change\
        \ because all modules that use exhaustive `when` need to cover one more possible\
        \ type."
          - type: "text"
            stepId: "sealed-section-2"
            question: "Sealed vs enum"
            explanation: "Content for Sealed vs enum"
            repetable: false
            text: "## Sealed vs enum\n\nEnum classes are used to represent a set of values.\
        \ Sealed classes or interfaces represent a set of subtypes that can be made\
        \ with classes or object declarations. This is a significant difference. A\
        \ class is more than a value. It can have many instances and can be a data\
        \ holder. Think of `Response`: if it were an enum class, it couldn't hold\
        \ `value` or `error`. Sealed subclasses can each store different data, whereas\
        \ an enum is just a set of values."
          - type: "text"
            stepId: "sealed-section-3"
            question: "Use cases"
            explanation: "Content for Use cases"
            repetable: false
            text: "## Use cases\n\nWe use sealed classes whenever we want to express that\
        \ there is a concrete number of subclasses of a class.\n\n```kotlin\nsealed\
        \ class MathOperation\nclass Plus(val left: Int, val right: Int) : MathOperation()\n\
        class Minus(val left: Int, val right: Int) : MathOperation()\nclass Times(val\
        \ left: Int, val right: Int) : MathOperation()\nclass Divide(val left: Int,\
        \ val right: Int) : MathOperation()\n\nsealed interface Tree\nclass Leaf(val\
        \ value: Any?) : Tree\nclass Node(val left: Tree, val right: Tree) : Tree\n\
        \nsealed interface Either<out L, out R>\nclass Left<out L>(val value: L) :\
        \ Either<L, Nothing>\nclass Right<out R>(val value: R) : Either<Nothing, R>\n\
        \nsealed interface AdView\nobject FacebookAd : AdView\nobject GoogleAd : AdView\n\
        class OwnAd(val text: String, val imgUrl: String) : AdView\n```\n\nThe key\
        \ benefit is that when-expression can easily cover all possible types in a\
        \ hierarchy using is-checks. A when-condition with a sealed element as a value\
        \ ensures the compiler performs exhaustive type checking, and our program\
        \ can only represent valid states.\n\n```kotlin\nfun BinaryTree.height():\
        \ Int = when (this) {\n    is Leaf -> 1\n    is Node -> maxOf(this.left.height(),\
        \ this.right.height())\n}\n```\n\nHowever, expressing that a hierarchy is\
        \ restricted improves readability. Finally, when we use the `sealed` modifier,\
        \ we can use reflection to find all the subclasses[^14_1]:\n\n```kotlin\n\
        sealed interface Parent\nclass A : Parent\nclass B : Parent\nclass C : Parent\n\
        \nfun main() {\n    println(Parent::class.sealedSubclasses)\n    // [class\
        \ A, class B, class C]\n}\n```"
          - type: "text"
            stepId: "sealed-section-4"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nSealed classes and interfaces should be used to represent\
        \ restricted hierarchies. The when-statement makes it easier to handle each\
        \ possible sealed subtype and, as a result, to add new methods to sealed elements\
        \ using extension functions. Abstract classes leave space for new classes\
        \ to join this hierarchy. If we want to control what the subclasses of a class\
        \ are, we should use the `sealed` modifier.\n\nNext, we will talk about the\
        \ last special kind of class that is used to add extra information about our\
        \ code elements: annotations.\n\n[^14_0]: Restricted hierarchies are used\
        \ to represent values that could take on several different but fixed types.\
        \ In other languages, restricted hierarchies might be represented by sum types,\
        \ coproducts, or tagged unions.\n[^14_1]: This requires the `kotlin-reflect`\
        \ dependency. More about reflection in *Advanced Kotlin*.\n[^14_2]: You could\
        \ still declare an abstract class or an interface as a part of a sealed hierarchy\
        \ that the client would be able to inherit from another module."
          - type: "single-answer"
            stepId: "sealed-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "sealed-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "sealed-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "sealed-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "sealed-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "annotations"
        name: "Annotation classes"
        steps:
          - type: "text"
            stepId: "annotations-introduction"
            question: "Annotation classes"
            explanation: "Introduction to Annotation classes"
            repetable: false
            text: "# Annotation classes\n\nAnother special kind of class in Kotlin is annotations,\
        \ which we use to provide additional information about an element. Here is\
        \ an example class that uses the `JvmField`, `JvmStatic`, and `Throws` annotations[^15_2].\n\
        \n```kotlin\nimport java.math.BigDecimal\nimport java.math.MathContext\n\n\
        class Money(\n    val amount: BigDecimal,\n    val currency: String,\n) {\n\
        \    @Throws(IllegalArgumentException::class)\n    operator fun plus(other:\
        \ Money): Money {\n        require(currency == other.currency)\n        return\
        \ Money(amount + other.amount, currency)\n    }\n\n    companion object {\n\
        \        @JvmField\n        val MATH = MathContext(2)\n\n        @JvmStatic\n\
        \        fun eur(amount: Double) =\n            Money(amount.toBigDecimal(MATH),\
        \ \"EUR\")\n\n        @JvmStatic\n        fun usd(amount: Double) =\n    \
        \        Money(amount.toBigDecimal(MATH), \"USD\")\n\n        @JvmStatic\n\
        \        fun pln(amount: Double) =\n            Money(amount.toBigDecimal(MATH),\
        \ \"PLN\")\n    }\n}\n```\n\nYou can also define your own annotations. This\
        \ is an example of annotation declaration and usage:\n\n```kotlin\nannotation\
        \ class Factory\nannotation class FactoryFunction(val name: String)\n\n@Factory\n\
        class CarFactory {\n\n    @FactoryFunction(name = \"toyota\")\n    fun makeToyota():\
        \ Car = Toyota()\n\n    @FactoryFunction(name = \"skoda\")\n    fun makeSkoda():\
        \ Car = Skoda()\n}\n\nabstract class Car\nclass Toyota : Car()\nclass Skoda\
        \ : Car()\n```\n\nYou might be asking yourself what these annotations do.\
        \ The answer is surprisingly simple: absolutely nothing. Annotations, by themselves,\
        \ are not active and do not change how our code works. They only hold information.\
        \ However, many libraries depend on annotations and behave according to what\
        \ we specify with them.\n\nMany important libraries use a mechanism called\
        \ *annotation processing*. How it works is simple: there are classes called\
        \ *annotation processors* that are running when we build our code. They analyze\
        \ our code and generate extra code. They generally strongly depend on annotations.\
        \ This new code is not part of our project sources, but we can access it once\
        \ it has been generated. This fact is used by libraries that use annotation\
        \ processing. So, take a look at this class, which uses the Java `Mockito`\
        \ library with an annotation processor:\n\n```kotlin\nclass DoctorServiceTest\
        \ {\n\n    @Mock\n    lateinit var doctorRepository: DoctorRepository\n\n\
        \    lateinit var doctorService: DoctorService\n\n    @Before\n    fun init()\
        \ {\n        MockitoAnnotations.initMocks(this)\n        doctorService = DoctorService(doctorRepository)\n\
        \    }\n\n    // ...\n}\n```\n\nThe `doctorRepository` property is annotated\
        \ as `Mock`, which is interpreted by the Mock processor so that this variable\
        \ can get a mock value. This processor generates a class that creates and\
        \ sets a value for the `doctorRepository` property in `DoctorServiceTest`.\
        \ Of course, this generated class will not work by itself as it needs to be\
        \ started. This is what `MockitoAnnotations.initMocks(this)` is for: it uses\
        \ reflection to call this generated class.\n\nAnnotation processing is better\
        \ described in *Advanced Kotlin*, in the *Annotation Processing* chapter."
          - type: "text"
            stepId: "annotations-section-1"
            question: "Meta-annotations"
            explanation: "Content for Meta-annotations"
            repetable: false
            text: "## Meta-annotations\n\nAnnotations that are used to annotate other annotations\
        \ are known as meta-annotations. There are four key meta-annotations from\
        \ Kotlin stdlib:\n* `Target` indicates the kinds of code elements that are\
        \ possible targets of an annotation. As arguments, it accepts `AnnotationTarget`\
        \ enum values, which include values like `CLASS`, `PROPERTY`, `FUNCTION`,\
        \ etc.\n* `Retention` determines whether an annotation is stored in the binary\
        \ output of compilation and is visible for reflection. By default, both are\
        \ true.\n* `Repeatable` determines that an annotation is applicable twice\
        \ or more in a single code element.\n* `MustBeDocumented` determines that\
        \ an annotation is part of a public API and should therefore be included in\
        \ the generated documentation for the element to which the annotation is applied.\n\
        \nHere are example usages of some of these annotations:\n\n```kotlin\n@MustBeDocumented\n\
        @Target(AnnotationTarget.CLASS)\nannotation class Factory\n\n@Repeatable\n\
        @Target(AnnotationTarget.FUNCTION)\nannotation class FactoryFunction(val name:\
        \ String)\n```"
          - type: "text"
            stepId: "annotations-section-2"
            question: "Annotating the primary constructor"
            explanation: "Content for Annotating the primary constructor"
            repetable: false
            text: "## Annotating the primary constructor\n\nTo annotate the primary constructor,\
        \ it is necessary to use the `constructor` keyword as part of its definition,\
        \ before the parentheses.\n\n```kotlin\n// JvmOverloads annotates primary\
        \ constructor\nclass User @JvmOverloads constructor(\n    val name: String,\n\
        \    val surname: String,\n    val age: Int = -1,\n)\n```"
          - type: "text"
            stepId: "annotations-section-3"
            question: "List literals"
            explanation: "Content for List literals"
            repetable: false
            text: "## List literals\n\nWhen we specify an annotation with an array value,\
        \ we can use a special syntax called \"array literal\". This means that instead\
        \ of using `arrayOf`, we can declare an array using square brackets.\n\n```kotlin\n\
        annotation class AnnotationWithList(\n    val elements: Array<String>\n)\n\
        \n@AnnotationWithList([\"A\", \"B\", \"C\"])\nval str1 = \"ABC\"\n\n@AnnotationWithList(elements\
        \ = [\"D\", \"E\"])\nval str2 = \"ABC\"\n\n@AnnotationWithList(arrayOf(\"\
        F\", \"G\"))\nval str3 = \"ABC\"\n```\n\nThis notation is only allowed for\
        \ annotations and does not work for defining arrays in any other context in\
        \ our code."
          - type: "text"
            stepId: "annotations-section-4"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nAnnotations are used to describe our code. They might be\
        \ interpreted by annotation processors or by classes using runtime reflection.\
        \ Tools and libraries use this to automate some actions for us. Annotations\
        \ by themselves are a simple feature, but the possibilities offered by them\
        \ are amazing[^15_3].\n\nLet's now move on to a famous Kotlin feature that\
        \ gives us the ability to extend any type with methods or properties: extensions.\n\
        \n[^15_2]: The `JvmField`, `JvmStatic`, and `Throws` annotations are described\
        \ in the book *Advanced Kotlin* and are used to customize how Kotlin elements\
        \ can be used in Java code.\n[^15_3]: In the book *Advanced Kotlin*, we will\
        \ see how annotation processors can be implemented and what we can do with\
        \ them."
          - type: "single-answer"
            stepId: "annotations-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "annotations-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "annotations-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "annotations-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "annotations-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "extensions"
        name: "Extensions"
        steps:
          - type: "text"
            stepId: "extensions-introduction"
            question: "Extensions"
            explanation: "Introduction to Extensions"
            repetable: false
            text: "# Extensions\n\nThe most intuitive way to define methods and properties\
        \ is inside classes. Such elements are called **class members** or, more concretely,\
        \ **member functions** and **member properties**.\n\n```kotlin\nclass Telephone(\n\
        \    // member property\n    val number: String\n) {\n    // member function\n\
        \    fun call() {\n        print(\"Calling $number\")\n    }\n}\n\nfun main()\
        \ {\n    // Usage\n    val telephone = Telephone(\"123456789\")\n    println(telephone.number)\
        \ // 123456789\n    telephone.call() // Calling 123456789\n}\n```\n\nOn the\
        \ other hand, Kotlin allows another way to define functions and properties\
        \ that are called on an instance: extensions. **Extension functions** are\
        \ defined like regular functions, but they additionally have an extra type\
        \ (and dot) before the function name. In the example below, the `call` function\
        \ is defined as an extension function on `Telephone`, so it needs to be called\
        \ on an instance of this type.\n\n```kotlin\nclass Telephone(\n    val number:\
        \ String\n)\n\nfun Telephone.call() {\n    print(\"Calling $number\")\n}\n\
        \nfun main() {\n    // Usage\n    val telephone = Telephone(\"123456789\"\
        )\n    telephone.call() // Calling 123456789\n}\n```\n\n> Both member functions\
        \ and extension functions are referred to as methods.\n\nExtension functions\
        \ can be defined on types we donâ€™t control, for instance `String`. This gives\
        \ us the power to extend external APIs with our own functions.\n\n```kotlin\n\
        fun String.remove(value: String) = this.replace(value, \"\")\n\nfun main()\
        \ {\n    println(\"Who Framed Roger Rabbit?\".remove(\" \"))\n    // WhoFramedRogerRabbit?\n\
        }\n```\n\nTake a look at the example above. We defined the extension function\
        \ `remove` on `String`, so we need to call this function on an object of type\
        \ `String`. Inside the function, we reference this object using the `this`\
        \ keyword, just like inside member functions. The `this` keyword can also\
        \ be used implicitly.\n\n```kotlin\n// explicit this\nfun String.remove(value:\
        \ String) = this.replace(value, \"\")\n\n// implicit this\nfun String.remove(value:\
        \ String) = replace(value, \"\")\n```\n\nThe `this` keyword is known as the\
        \ **receiver**. Inside extension functions, we call it an **extension receiver**.\
        \ Inside member functions, we call it a **dispatch receiver**. The type we\
        \ extend with the extension function is called the **receiver type**.\n\n\
        ![](207_receiver_type.png)\n\nExtension functions behave a lot like member\
        \ functions. When developers learn this, they are often concerned about objects'\
        \ safety, but this isnâ€™t a problem as extensions do not have any special access\
        \ to class elements. The only difference between top-level extension functions\
        \ and other top-level functions is that they are called on an instance instead\
        \ of receiving this instance as a regular argument. To see this more clearly,\
        \ let's take a look under the hood of extension functions."
          - type: "text"
            stepId: "extensions-section-1"
            question: "Extension functions under the hood"
            explanation: "Content for Extension functions under the hood"
            repetable: false
            text: "## Extension functions under the hood\n\nTo understand extension functions,\
        \ let's again use \"Tools > Kotlin > Show Kotlin bytecode\" and \"Decompile\"\
        \ (as explained in chapter *Your first program in Kotlin* in section *What\
        \ is under the hood on JVM?*). We will compile and decompile to Java our `remove`\
        \ function definition and its call:\n\n```kotlin\nfun String.remove(value:\
        \ String) = this.replace(value, \"\")\n\nfun main() {\n    println(\"A B C\"\
        .remove(\" \")) // ABC\n}\n```\n\nAs a result, you should see the following\
        \ code:\n\n```java\npublic final class PlaygroundKt {\n    @NotNull\n    public\
        \ static final String remove(\n            @NotNull String $this$remove,\n\
        \            @NotNull String value\n    ) {\n        // parameters not-null\
        \ checks\n        return StringsKt.replace$default(\n                $this$remove,\n\
        \                value,\n                \"\"\n                // plus default\
        \ values\n        );\n    }\n\n    public static final void main(@NotNull\
        \ String[] args) {\n        // parameter not-null check\n        String var1\
        \ = remove(\"A B C\", \" \");\n        System.out.println(var1);\n    }\n\
        }\n```\n\nNotice what happened to the receiver type: it became a parameter.\
        \ You can also see that, under the hood, `remove` is not called on an object.\
        \ It is just a regular static function.\n\nWhen you define an extension function,\
        \ you do not really add anything to a class. It is just syntactic sugar. Let's\
        \ compare the two following implementations of `remove`.\n\n```kotlin\nfun\
        \ remove(text: String, value: String) = text.replace(value, \"\")\n\nfun String.remove(value:\
        \ String) = this.replace(value, \"\")\n```\n\nUnder the hood, they are nearly\
        \ identical. The difference is in how Kotlin expects them to be called. Regular\
        \ functions receive all their arguments in regular argument positions. Extension\
        \ functions are called \"on\" a value."
          - type: "text"
            stepId: "extensions-section-2"
            question: "Extension properties"
            explanation: "Content for Extension properties"
            repetable: false
            text: "## Extension properties\n\nAn extension cannot hold a state, so it cannot\
        \ have fields. Although properties do not need fields, they can be defined\
        \ by their getters and setters. This is why we can define extension properties\
        \ if they do not need a backing field and are defined by accessors.\n\n```kotlin\n\
        val <T> List<T>.lastIndex: Int\n    get() = size - 1\n```\n\nExtension properties\
        \ are very popular on Android, where accessing different services is complex\
        \ and repetitive. Defining extension properties lets us do this much more\
        \ easily.\n\n```kotlin\nval Context.inflater: LayoutInflater\n    get() =\
        \ getSystemService(Context.LAYOUT_INFLATER_SERVICE)\n        as LayoutInflater\n\
        \nval Context.notificationManager: NotificationManager\n    get() = getSystemService(Context.NOTIFICATION_SERVICE)\n\
        \        as NotificationManager\n\nval Context.alarmManager: AlarmManager\n\
        \    get() = getSystemService(Context.ALARM_SERVICE)\n        as AlarmManager\n\
        ```\n\nExtension properties can define both a getter and a setter. Here is\
        \ an extension property that provides a different representation of a user\
        \ birthdate:\n\n```kotlin\nclass User {\n    // ...\n    var birthdateMillis:\
        \ Long? = null\n}\n\nvar User.birthdate: Date?\n    get() {\n        val millis\
        \ = birthdateMillis\n        return if (millis == null) null else Date(millis)\n\
        \    }\n    set(value) {\n        birthdateMillis = value?.time\n    }\n```"
          - type: "text"
            stepId: "extensions-section-3"
            question: "Extensions vs members"
            explanation: "Content for Extensions vs members"
            repetable: false
            text: "## Extensions vs members\n\nThe biggest difference between members and\
        \ extensions in terms of use is that **extensions need to be imported separately**.\
        \ For this reason, they can be located in a different package. This fact is\
        \ used when we cannot add a member ourselves. It is also used in projects\
        \ designed to separate data and behavior. Properties with fields need to be\
        \ located in a class, but methods can be located separately as long as they\
        \ only access the public API of the class.\n\nThanks to the fact that extensions\
        \ need to be imported, we can have many extensions with the same name for\
        \ the same type. This is good because different libraries can provide extra\
        \ methods without causing a conflict. On the other hand, it would be dangerous\
        \ to have two extensions with the same name but different behaviors. If you\
        \ have such a situation, it is a code smell and is a clue that someone has\
        \ abused the extension function capability.\n\nAnother significant difference\
        \ is that **extensions are not virtual**, meaning that they cannot be redefined\
        \ in derived classes. This is why if you have an extension defined on both\
        \ a supertype and a subtype, the compiler decides which function is chosen\
        \ based on how the variable is typed, not what its actual class is.\n\n```kotlin\n\
        open class View\nclass Button : View()\n\nfun View.printMe() {\n    println(\"\
        I'm a View\")\n}\n\nfun Button.printMe() {\n    println(\"I'm a Button\")\n\
        }\n\nfun main() {\n    val button: Button = Button()\n    button.printMe()\
        \ // I'm a Button\n    val view: View = button\n    view.printMe() // I'm\
        \ a View\n}\n```\n\nThe behavior of extension functions is different from\
        \ member functions. Member functions are *virtual*, so up-casting the type\
        \ of an object does not influence which member function is chosen.\n\n```kotlin\n\
        open class View {\n   open fun printMe() {\n       println(\"I'm a View\"\
        )\n   }\n}\nclass Button: View() {\n   override fun printMe() {\n       println(\"\
        I'm a Button\")\n   }\n}\n\nfun main() {\n   val button: Button = Button()\n\
        \   button.printMe() // I'm a Button\n   val view: View = button\n   view.printMe()\
        \ // I'm a Button\n}\n```\n\nThis behavior is the result of the fact that\
        \ extension functions are compiled under the hood into normal functions in\
        \ which the extensionâ€™s receiver is placed as the first argument:\n\n```kotlin\n\
        open class View\nclass Button : View()\n\nfun printMe(view: View) {\n    println(\"\
        I'm a View\")\n}\n\nfun printMe(button: Button) {\n    println(\"I'm a Button\"\
        )\n}\n\nfun main() {\n    val button: Button = Button()\n    printMe(button)\
        \ // I'm a Button\n    val view: View = button\n    printMe(view) // I'm a\
        \ View\n}\n```\n\nAnother consequence of what extensions are under the hood\
        \ is that **we define extensions on types, not on classes**. This gives us\
        \ more freedom. For instance, we can define an extension on a nullable or\
        \ generic type:\n\n```kotlin\ninline fun CharSequence?.isNullOrBlank(): Boolean\
        \ {\n    // (skipped contract definition)\n    return this == null || this.isBlank()\n\
        }\n\nfun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element\
        \ in this) {\n        sum += element\n    }\n    return sum\n}\n```\n\nThe\
        \ last important difference is that **extensions are not listed as members\
        \ in the class reference**. This is why they are not considered by annotation\
        \ processors; it is also why, when we process a class using annotation processing,\
        \ we cannot extract elements that should be processed into extensions. On\
        \ the other hand, if we extract non-essential elements into extensions, we\
        \ donâ€™t need to worry about them being seen by those processors. We donâ€™t\
        \ need to hide them because they are not in the class they extend anyway."
          - type: "text"
            stepId: "extensions-section-4"
            question: "Extension functions on object declarations"
            explanation: "Content for Extension functions on object declarations"
            repetable: false
            text: "## Extension functions on object declarations\n\nWe can define extensions\
        \ on object declarations.\n\n```kotlin\nobject A\n\nfun A.foo() {}\n\nfun\
        \ main() {\n    A.foo()\n\n    val a: A = A\n    a.foo()\n}\n```\n\nTo define\
        \ an extension function on a companion object, we need to use the companion\
        \ object's real name. If this name is not set explicitly, the default one\
        \ is \"Companion\". To define an extension function on a companion object,\
        \ this companion object must exist. This is why some classes define companion\
        \ objects without bodies.\n\n```kotlin\nclass A {\n    companion object\n\
        }\n\nfun A.Companion.foo() {}\n\nfun main() {\n    A.foo()\n\n    val a: A.Companion\
        \ = A\n    a.foo()\n}\n```"
          - type: "text"
            stepId: "extensions-section-5"
            question: "Member extension functions"
            explanation: "Content for Member extension functions"
            repetable: false
            text: "## Member extension functions\n\nIt is possible to define extension functions\
        \ inside classes. Such functions are known as **member extension functions**.\n\
        \n```kotlin\nclass Telephone {\n    fun String.call() { \n        // ...\n\
        \    }\n}\n```\n\nMember extension functions are considered a code smell,\
        \ and we should avoid using them if we donâ€™t have a good reason. For a deeper\
        \ explanation, see *Effective Kotlin*, *Item 46: Avoid member extensions*."
          - type: "text"
            stepId: "extensions-section-6"
            question: "Use cases"
            explanation: "Content for Use cases"
            repetable: false
            text: "## Use cases\n\nThe most important use-case for extensions is adding\
        \ methods and properties to APIs that we don't control. A good example is\
        \ displaying a toast or hiding a view on Android. Both these operations are\
        \ unnecessarily complicated, so we like to define extensions to simplify them.\n\
        \n```kotlin\nfun Context.toast(message: String) {\n    Toast.makeText(this,\
        \ message, Toast.LENGTH_LONG).show()\n}\n\nfun View.hide() {\n    this.visibility\
        \ = View.GONE\n}\n```\n\nHowever, there are also cases where we prefer to\
        \ use extensions instead of members. Consider the `Iterable` interface, which\
        \ has only one member function, `iterator`; however, it has many methods,\
        \ which are defined in the standard library as extensions[^16_1], like `onEach`\
        \ or `joinToString`. The fact that these are defined as extensions allows\
        \ for smaller and more concise interfaces.\n\n```kotlin\ninterface Iterable<out\
        \ T> {\n    operator fun iterator(): Iterator<T>\n}\n```\n\n![](iterable_methods.png)\n\
        \nExtension functions are also more elastic than regular functions. This is\
        \ mainly because they are defined on types, so we can define extensions on\
        \ types like `Iterable<Int>` or `Iterable<T>`.\n\n```kotlin\nfun <T : Comparable<T>>\
        \ Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n       \
        \ if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\"\
        )\n        return (toTypedArray<Comparable<T>>() as Array<T>)\n          \
        \  .apply { sort() }\n            .asList()\n    }\n    return toMutableList().apply\
        \ { sort() }\n}\n\nfun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n\
        \    for (element in this) {\n        sum += element\n    }\n    return sum\n\
        }\n```\n\nIn bigger projects, we often have similar classes for different\
        \ parts of our application. Let's say that you implement a backend for an\
        \ online shop, and you have a class `Product` to represent all the products.\n\
        \n```kotlin\nimport java.math.BigDecimal\n\nclass Product(\n    val id: String,\n\
        \    val title: String,\n    val imgSrc: String,\n    val description: String,\n\
        \    val price: BigDecimal,\n    val type: ProductType,\n    // ...\n)\n```\n\
        \nYou also have a similar (but not identical) class called `ProductJson`,\
        \ which is used to represent the objects you use in your application API responses\
        \ or that you read from API requests.\n\n```kotlin\nclass ProductJson(\n \
        \   val id: String,\n    val title: String,\n    val img: String,\n    val\
        \ desc: String,\n    val price: String,\n    val type: String,\n    // ...\n\
        )\n```\n\nInstances of `Product` are used in your application, and instances\
        \ of `ProductJson` are used in the API. These objects need to be separated\
        \ because, for instance, you donâ€™t want to change your API response when you\
        \ change a property name in an internal class. Yet, we often need to transform\
        \ between `Product` and `ProductJson`. For this, we could define a member\
        \ function `toProduct`.\n\n```kotlin\nclass ProductJson(\n    val id: String,\n\
        \    val title: String,\n    val img: String,\n    val desc: String,\n   \
        \ val price: String,\n    val type: String,\n    // ...\n) {\n    fun toProduct()\
        \ = Product(\n        id = this.id,\n        title = this.title,\n       \
        \ imgSrc = this.img,\n        description = this.desc,\n        price = BigDecimal(price),\n\
        \        type = enumValueOf<ProductType>(this.type)\n    )\n}\n```\n\nNot\
        \ everyone likes this solution as it makes `ProductJson` bigger and more complicated.\
        \ It is also not useful in transforming from `Product` to `ProductJson` because\
        \ in most modern architectures we donâ€™t want domain classes (like `Product`)\
        \ to be aware of details such as their API representation. A better solution\
        \ is to define both `toProduct` and `toProductJson` as extension functions,\
        \ then locate them together next to the `ProductJson` class. It is good to\
        \ locate those transformation functions next to each other, because they have\
        \ a lot in common.\n\n```kotlin\nclass ProductJson(\n    val id: String,\n\
        \    val title: String,\n    val img: String,\n    val desc: String,\n   \
        \ val price: String,\n    val type: String,\n    // ...\n)\n\nfun ProductJson.toProduct()\
        \ = Product(\n    id = this.id,\n    title = this.title,\n    imgSrc = this.img,\n\
        \    description = this.desc,\n    price = BigDecimal(this.price),\n    type\
        \ = enumValueOf<ProductType>(this.type)\n)\n\nfun Product.toProductJson()\
        \ = ProductJson(\n    id = this.id,\n    title = this.title,\n    img = this.imgSrc,\n\
        \    desc = this.description,\n    price = this.price.toString(),\n    type\
        \ = this.type.name\n)\n```\n\nThis seems to be a popular pattern, both on\
        \ the backend and in Android applications."
          - type: "text"
            stepId: "extensions-section-7"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nIn this chapter, we've learned about extensions - a powerful\
        \ Kotlin feature that is often used to create convenient and meaningful utils\
        \ and to control our code better. However, with great power comes great responsibility.\
        \ We should not be worried about using extensions, but we should use them\
        \ consciously and only where they make sense.\n\nIn the next chapter, we will\
        \ finally introduce collections so that we can talk about lists, sets, maps,\
        \ and arrays. Thereâ€™s a lot ahead, so get ready.\n\n[^16_1]: Roman Elizarov\
        \ (Project Lead for the Kotlin Programming Language) refers to this as an\
        \ extension-oriented design in the standard library. Source: elizarov.medium.com/extension-oriented-design-13f4f27deaee"
          - type: "single-answer"
            stepId: "extensions-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "extensions-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "extensions-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "extensions-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "extensions-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "collections"
        name: "Collections"
        steps:
          - type: "text"
            stepId: "collections-introduction"
            question: "Collections"
            explanation: "Introduction to Collections"
            repetable: false
            text: "# Collections\n\nCollections are one of the most important concepts in\
        \ programming. They are types that represent groups of elements. In Kotlin,\
        \ the most important collection types are:\n\n* `List`, which represents an\
        \ ordered collection of elements. The same elements can occur multiple times.\
        \ A listâ€™s elements can be accessed by indices (zero-based integer numbers\
        \ that reflect elementsâ€™ positions). An example might be a list of songs in\
        \ a queue: the order of the songs is important, and each song can appear in\
        \ multiple places.\n\n* `Set`, which represents a collection of unique elements.\
        \ It reflects the mathematical abstraction of a set: a group of objects without\
        \ repetitions. Sets might not respect element order (however, the default\
        \ set used by Kotlin does respect element order). An example might be a set\
        \ of winning numbers in a lottery: they must be unique, but their order does\
        \ not matter.\n\n* `Map` (known as a dictionary in some other languages),\
        \ which represents a set of key-value pairs. Keys must be unique, and each\
        \ of them points to exactly one value. Multiple keys can be associated with\
        \ the same values. Maps are useful for expressing logical connections between\
        \ elements.\n\nThere are also arrays, which are typically considered a low-level\
        \ primitive used by other collections under the hood.\n\nIn this chapter,\
        \ we will cover the most important topics regarding collections, starting\
        \ from how they are organized, how they are created, special kinds of collections,\
        \ and how all these kinds of collections are used in practice. This is a long\
        \ chapter, so let's get started."
          - type: "text"
            stepId: "collections-section-1"
            question: "The hierarchy of interfaces"
            explanation: "Content for The hierarchy of interfaces"
            repetable: false
            text: "## The hierarchy of interfaces\n\nIn Kotlin, a whole hierarchy of interfaces\
        \ is used to represent different kinds of collections. Take a look at the\
        \ diagram below.\n\n![Relations between interfaces representing collections.\
        \ Blue elements are read-only. Orange elements are mutable. Classes like `ArrayList`\
        \ or `HashSet` implement mutable variants but can be up-casted to read-only.](collections_interfaces.png)\n\
        \nAt the top of the hierarchy, there is `Iterable`, which represents a sequence\
        \ of elements that can be iterated over. We can iterate over `Iterable` objects\
        \ using a for-loop thanks to its `iterator` method.\n\n```kotlin\ninterface\
        \ Iterable<out T> {\n    operator fun iterator(): Iterator<T>\n}\n```\n\n\
        The next type is `Collection`, which represents a collection of elements.\
        \ Its methods are read-only (no methods for manipulating the elements are\
        \ available), so this interface does not allow any modifications.\n\n```kotlin\n\
        interface Collection<out E> : Iterable<E> {\n    val size: Int\n    fun isEmpty():\
        \ Boolean\n    operator fun contains(element: E): Boolean\n    override fun\
        \ iterator(): Iterator<E>\n    fun containsAll(elements: Collection<E>): Boolean\n\
        }\n```\n\nNotice that only `List` and `Set` are subtypes of `Collection` and\
        \ `Iterable`. `Map` and arrays are not part of this hierarchy; however, we\
        \ can also iterate over them using a for-loop.\n\nAll the interfaces described\
        \ so far are read-only, so they have methods that allow what is inside to\
        \ be read (like `get`, `contains`, `size`) but not modified. `MutableIterable`,\
        \ `MutableCollection` and `MutableList` are sub-interfaces of, respectively,\
        \ `Iterable`, `Collection` and `List`, which add methods for modifying elements\
        \ (like `remove`, `clear`, `add`).\n\nThe actual classes used when we operate\
        \ on collections are platform-specific. For instance, if you create a list\
        \ using the `listOf(\"A\", \"B\")` function on Kotlin/JVM version 1.7.20,\
        \ the actual class is `Arrays.ArrayList` from the Java Standard Library; however,\
        \ if you use Kotlin/JS version 1.7.20, the actual class is a JavaScript array.\
        \ The point is to expect not a concrete class but an object that represents\
        \ a list (and therefore implements a `List` interface). This is an application\
        \ of a general idea: use abstractions to make it easier to change the underlying\
        \ representations (e.g., for performance reasons) without pushing breaking\
        \ changes[^17_0]."
          - type: "text"
            stepId: "collections-section-2"
            question: "Mutable vs read-only types"
            explanation: "Content for Mutable vs read-only types"
            repetable: false
            text: "## Mutable vs read-only types\n\nThe distinction between mutable and\
        \ read-only interfaces is very important. For instance, the `listOf` function\
        \ returns `List`, which represents a read-only collection. `List` does not\
        \ have any functions that would allow its modification (functions like `add`\
        \ or `remove`). This means a collection object cannot mutate, but this doesnâ€™\
        t mean we cannot update a variable that contains a collection.\n\nItâ€™s a similar\
        \ story with `Int` or `String`. Both are immutable, so they cannot change\
        \ internally; however, we update their values with operators like plus.\n\n\
        \  ```kotlin\nfun main() {\n    var a = 100\n    a = a + 10\n    a += 1\n\
        \    println(a) // 111\n\n    var str = \"A\"\n    str = str + \"B\"\n   \
        \ str += \"C\"\n    println(str) // ABC\n}\n```\n\nThe same goes for read-only\
        \ collections: we can use operators to create a new collection with an updated\
        \ value.\n\n```kotlin\nfun main() {\n    var list = listOf(\"A\", \"B\")\n\
        \    list = list + \"C\"\n    println(list) // [A, B, C]\n    list = list\
        \ + listOf(\"D\", \"E\")\n    println(list) // [A, B, C, D, E]\n    list =\
        \ listOf(\"Z\") + list\n    println(list)  // [Z, A, B, C, D, E]\n}\n```\n\
        \nIn contrast to read-only lists, mutable lists can be modified internally.\
        \ So, if you create a collection using the `mutableListOf` function, the result\
        \ object is `MutableList`, which supports operations like `add`, `clear` or\
        \ `remove`.\n\n```kotlin\nfun main() {\n    val mutable = mutableListOf(\"\
        A\", \"B\")\n    mutable.add(\"C\")\n    mutable.remove(\"A\")\n    println(mutable)\
        \ // [B, C]\n}\n```\n\nYou can easily transform between a mutable and a read-only\
        \ list with `toList` and `toMutableList`. However, you often do not need to\
        \ explicitly transform from a `MutableList` to a `List`. `MutableList` is\
        \ a subtype of `List`, so a `MutableList` can be used as a `List`.\n\nIn the\
        \ upcoming sections, we will see the most important operators for modifying\
        \ read-only collections, and methods that can be used to modify mutable collections."
          - type: "text"
            stepId: "collections-section-3"
            question: "Creating collections"
            explanation: "Content for Creating collections"
            repetable: false
            text: "## Creating collections\n\nMost languages have support for a feature\
        \ called a \"collection literal\", which is special syntax for creating a\
        \ certain collection type based on the provided list of elements.\n\n```\n\
        // JavaScript\nconst arr = [\"A\", \"B\"] // an array of strings\n// Python\n\
        numbers = [1, 2, 3] // a list of numbers\nnames = {\"Alex\", \"Barbara\"}\
        \ // a set of strings\n```\n\nIn Kotlin, this role is performed by top-level\
        \ functions. By convention, their names start with the name of the type they\
        \ produce (starting from lower case) and the `Of` suffix. Here are a few examples.\n\
        \n```kotlin\nfun main() {\n    // We create `List` using `listOf` function.\n\
        \    val list: List<String> = listOf(\"A\", \"B\", \"C\")\n    // We create\
        \ `MutableList` using `mutableListOf` function.\n    val mutableList: MutableList<Int>\
        \ = mutableListOf(1, 2, 3)\n\n    // We create `Set` using `setOf` function.\n\
        \    val set: Set<Double> = setOf(3.14, 7.11)\n    // We create `MutableSet`\
        \ using `mutableSetOf` function.\n    val mutableSet: MutableSet<Char> = mutableSetOf('A',\
        \ 'B')\n\n    // We create `Map` using `mapOf` function.\n    val map: Map<Char,\
        \ String> =\n        mapOf('A' to \"Alex\", 'B' to \"Ben\")\n    // We create\
        \ `MutableMap` using `mutableMapOf` function.\n    val mutableMap: MutableMap<Int,\
        \ Char> =\n        mutableMapOf(1 to 'A', 2 to 'B')\n\n    // We create `Array`\
        \ using `arrayOf` function.\n    val array: Array<String> = arrayOf(\"Dukaj\"\
        , \"Sapkowski\")\n    // We create `IntArray` using `intArrayOf` function.\n\
        \    val intArray: IntArray = intArrayOf(9, 8, 7)\n\n    // We create `ArrayList`\
        \ using `arrayListOf` function.\n    val arrayList: ArrayList<String> = arrayListOf(\"\
        M\", \"N\")\n}\n```\n\nTo all these classes, we provide initial elements as\
        \ arguments. The only exception is map, which is a set of key-value pairs,\
        \ so we specify the initial pairs using `Pair`, which we typically create\
        \ using the `to` function (as explained in the chapter *Data classes*).\n\n\
        We can also transform one collection into another. This can often be done\
        \ using a method whose name is the type we want to achieve, preceded by the\
        \ `to` prefix.\n\n```kotlin\nfun main() {\n    val list: List<Char> = listOf('A',\
        \ 'B', 'C')\n    val mutableList: MutableList<Char> = list.toMutableList()\n\
        \    val set: Set<Char> = mutableList.toSet()\n    val mutableSet: MutableList<Char>\
        \ = set.toMutableList()\n    val array: Array<Char> = mutableSet.toTypedArray()\n\
        \    val charArray: CharArray = array.toCharArray()\n    val list2: List<Char>\
        \ = charArray.toList()\n}\n```"
          - type: "text"
            stepId: "collections-section-4"
            question: "Lists"
            explanation: "Content for Lists"
            repetable: false
            text: "## Lists\n\n**List** is the most basic type of collection. You can treat\
        \ it as the default collection type. It represents an ordered list of elements.\n\
        \n```kotlin\nfun main() {\n    val list = listOf(\"A\", \"B\", \"C\")\n  \
        \  println(list) // [A, B, C]\n}\n```\n\n`List` is a generic class. The result\
        \ type of `listOf` is `List<T>`, where `T` is the type of the elements in\
        \ this list. Since we have a list with string values in the code above, the\
        \ type is `List<String>`. More about generic classes in the chapter *Generics*.\n\
        \n```kotlin\nfun main() {\n    val list: List<String> = listOf(\"A\", \"B\"\
        , \"C\")\n    println(list) // [A, B, C]\n    val ints: List<Int> = listOf(1,\
        \ 2, 3)\n    println(ints) // [1, 2, 3]\n}\n```\n\n### Modifying lists\n\n\
        When you need to modify the elements of a list, you have two options:\n1.\
        \ Use a read-only list in a `var` variable, and modify it using operators\
        \ like plus or minus.\n2. Use a mutable list in a `val` variable, and modify\
        \ it using `MutableList` methods like `add`, `addAll` or `remove`.\n\n```kotlin\n\
        fun main() {\n    var list = listOf(\"A\", \"B\")\n    list = list + \"C\"\
        \n    println(list) // [A, B, C]\n    list = list + listOf(\"D\", \"E\")\n\
        \    println(list) // [A, B, C, D, E]\n    list = listOf(\"Z\") + list\n \
        \   println(list) // [Z, A, B, C, D, E]\n    list = list - \"A\"\n    println(list)\
        \ // [Z, B, C, D, E]\n\n    val mutable = mutableListOf(\"A\", \"B\")\n  \
        \  mutable.add(\"C\")\n    println(mutable) // [A, B, C]\n    mutable.addAll(listOf(\"\
        D\", \"E\"))\n    println(mutable) // [A, B, C, D, E]\n    mutable.add(0,\
        \ \"Z\") // The first number is index\n    println(mutable) // [Z, A, B, C,\
        \ D, E]\n    mutable.remove(\"A\")\n    println(mutable) // [Z, B, C, D, E]\n\
        }\n```\n\nSince the beginning of Kotlin, there have been discussions about\
        \ which of these two approaches should be preferred. The first gives more\
        \ freedom[^17_2], but the second is considered more efficient[^17_3].\n\n\
        You can also use the `+=` operator to add an element or a collection to a\
        \ `var` variable that points to a read-only list, or to a `val` variable that\
        \ points to a mutable list.\n\n```kotlin\nfun main() {\n    var list = listOf(\"\
        A\", \"B\")\n    list += \"C\"\n    println(list) // [A, B, C]\n\n    val\
        \ mutable = mutableListOf(\"A\", \"B\")\n    mutable += \"C\"\n    println(mutable)\
        \ // [A, B, C]\n}\n```\n\nHowever, using `+=` for read-only lists results\
        \ in a warning that a new collection has been created under the hood, which\
        \ can lead to performance issues when we are dealing with large lists.\n\n\
        ![](plusAssign.png)\n\n### Checking a listâ€™s size or if it is empty\n\nYou\
        \ can get the number of elements in a list using the `size` property.\n\n\
        ```kotlin\nfun main() {\n    val list = listOf(\"A\", \"B\", \"C\")\n    println(list.size)\
        \ // 3\n}\n```\n\nA list is considered empty when its size is `0`. You can\
        \ also check this using the `isEmpty` method.\n\n```kotlin\nfun main() {\n\
        \    val list = listOf(\"A\", \"B\", \"C\")\n    println(list.size == 0) //\
        \ false\n    println(list.isEmpty()) // false\n\n    val empty: Set<Int> =\
        \ setOf()\n    println(empty.size == 0) // true\n    println(empty.isEmpty())\
        \ // true\n}\n```\n\n### Lists and indices\n\nLists allow elements to be retrieved\
        \ by their index, which is a number that represents the elementâ€™s position.\
        \ The index of the first element is always 0, and each next element in the\
        \ list has the next index. You can imagine a list to be like an infinite shelf\
        \ for items, where there is a label with a number below each item.\n\n![](shelf.png)\n\
        \nTo get an element by an index, we use the box bracket. This is a synonym\
        \ of the `get` method. Both these methods throw an `IndexOutOfBoundsException`\
        \ when you try to get an element at an index that does not exist.\n\n```kotlin\n\
        fun main() {\n    val list = listOf(\"A\", \"B\")\n    println(list[1]) //\
        \ B\n    println(list.get(1)) // B\n    println(list[3]) // Runtime error\n\
        }\n```\n\nIf you are not sure if an index is correct, it is safer to use either\
        \ `getOrNull`, which returns `null` in the case of an incorrect index, or\
        \ `getOrElse`, which specifies the default value[^17_1].\n\n```kotlin\nfun\
        \ main() {\n    val list = listOf(\"A\", \"B\")\n    println(list.getOrNull(1))\
        \ // B\n    println(list.getOrElse(1) { \"X\" }) // B\n\n    println(list.getOrNull(3))\
        \ // null\n    println(list.getOrElse(3) { \"X\" }) // X\n}\n```\n\nThere\
        \ is also a useful function `getOrPut`, that can only be called on `MutableMap`,\
        \ that tries to find an element by key, and if it is not there, it is creating\
        \ it, adding it to the map and returning it. This operation is useful when\
        \ we use a map to cache some values, so to keep values in local memory so\
        \ that we do not need to fetch or calculate them again.\n\n```kotlin\nfun\
        \ main() {\n    val map = mutableMapOf(\"A\" to 1, \"B\" to 2)\n    println(map.getOrPut(\"\
        A\") { 3 }) // 1\n    println(map.getOrPut(\"C\") { 3 }) // 3\n    println(map)\
        \ // {A=1, B=2, C=3}\n}\n```\n\nYou can find the index of an element using\
        \ the `indexOf` method. It returns `-1` when there is no matching element\
        \ in the list.\n\n```kotlin\nfun main() {\n    val list = listOf(\"A\", \"\
        B\")\n    println(list.indexOf(\"A\")) // 0\n    println(list.indexOf(\"B\"\
        )) // 1\n    println(list.indexOf(\"Z\")) // -1\n}\n```\n\nIn a mutable list,\
        \ you can modify an element at a certain index using the box bracket in an\
        \ assignment, or using the `set` method.\n\n```kotlin\nfun main() {\n    val\
        \ mutable = mutableListOf(\"A\", \"B\", \"C\")\n    mutable[1] = \"X\"\n \
        \   println(mutable) // [A, X, C]\n    mutable.set(1, \"Y\")\n    println(mutable)\
        \ // [A, Y, C]\n}\n```\n\n### Checking if a list contains an element\n\nYou\
        \ can check if a list contains an element using the `contains` method or the\
        \ `in` operator.\n\n```kotlin\nfun main() {\n    val letters = listOf(\"A\"\
        , \"B\", \"C\")\n    println(letters.contains(\"A\")) // true\n    println(letters.contains(\"\
        Z\")) // false\n    println(\"A\" in letters) // true\n    println(\"Z\" in\
        \ letters) // false\n}\n```\n\nYou can also check whether a collection does\
        \ not contain an element using the `!in` operator.\n\n```kotlin\nfun main()\
        \ {\n    val letters = listOf(\"A\", \"B\", \"C\")\n    println(\"A\" !in\
        \ letters) // false\n    println(\"Z\" !in letters) // true\n}\n```\n\n###\
        \ Iterating over a list\n\nYou can iterate over a list using a for-loop. Just\
        \ place the list on the right side of `in`.\n\n```kotlin\nfun main() {\n \
        \   val letters = listOf(\"A\", \"B\", \"C\")\n    for (letter in letters)\
        \ {\n        print(letter)\n    }\n}\n```\n\nSince `MutableList` implements\
        \ `List`, all these operations can also be used on mutable lists.\n\nThese\
        \ are the most basic operations on lists. We will cover more of them in the\
        \ next book: *Functional Kotlin*."
          - type: "text"
            stepId: "collections-section-5"
            question: "Sets"
            explanation: "Content for Sets"
            repetable: false
            text: "## Sets\n\nWe use **sets** instead of lists when:\n1. we want to ensure\
        \ that elements in our collection are unique (sets keep only unique elements),\n\
        2. we frequently look for an element in a collection (finding elements in\
        \ a set is much more efficient than doing so in a list[^17_6]).\n\nSets are\
        \ quite similar to lists, which is why similar methods are used to operate\
        \ on them. However, sets do not treat order as seriously as lists, and some\
        \ kinds of sets do not respect order at all. This is why we cannot get elements\
        \ by index.\n\nWe create a set using the `setOf` function; then we specify\
        \ its values using arguments.\n\n```kotlin\nfun main() {\n    val set = setOf('A',\
        \ 'B', 'C')\n    println(set) // [A, B, C]\n}\n```\n\n`Set` is a generic class.\
        \ The result type of `setOf` is `Set<T>`, where `T` is the type of elements\
        \ in this set. Since we have a set with char values in the code above, the\
        \ type is `Set<Char>`.\n\n```kotlin\nfun main() {\n    val set: Set<Char>\
        \ = setOf('A', 'B', 'C')\n    println(set) // [A, B, C]\n    val ints: Set<Long>\
        \ = setOf(1L, 2L, 3L)\n    println(ints) // [1, 2, 3]\n}\n```\n\n### Modifying\
        \ sets\n\nYou can add elements to a read-only set in the same way as to a\
        \ read-only list: using plus or minus.\n\n```kotlin\nfun main() {\n    var\
        \ set = setOf(\"A\", \"B\")\n    set = set + \"C\"\n    println(set) // [A,\
        \ B, C]\n    set = set + setOf(\"D\", \"E\")\n    println(set) // [A, B, C,\
        \ D, E]\n    set = setOf(\"Z\") + set\n    println(set) // [Z, A, B, C, D,\
        \ E]\n    set = set - \"A\"\n    println(set) // [Z, B, C, D, E]\n}\n```\n\
        \nYou can also use a mutable set and its `add`, `addAll` or `remove` methods.\n\
        \n```kotlin\nfun main() {\n    val mutable = mutableSetOf(\"A\", \"B\")\n\
        \    mutable.add(\"C\")\n    println(mutable) // [A, B, C]\n    mutable.addAll(listOf(\"\
        D\", \"E\"))\n    println(mutable) // [A, B, C, D, E]\n    mutable.remove(\"\
        B\")\n    println(mutable) // [A, C, D, E]\n}\n```\n\n### Elements in a set\
        \ are unique\n\nSets accept only unique elements. If elements repeat during\
        \ set creation, only the first occurrence will be present in the set.\n\n\
        ```kotlin\nfun main() {\n    val set = setOf(\"A\", \"B\", \"C\", \"B\")\n\
        \    println(set) // [A, B, C]\n}\n```\n\nAdding an element that is equal\
        \ to an element already present in a set is ignored.\n\n```kotlin\nfun main()\
        \ {\n    val set = setOf(\"A\", \"B\", \"C\")\n    println(set + \"D\") //\
        \ [A, B, C, D]\n    println(set + \"B\") // [A, B, C]\n\n    val mutable =\
        \ mutableSetOf(\"A\", \"B\", \"C\")\n    mutable.add(\"D\")\n    mutable.add(\"\
        B\")\n    println(mutable) // [A, B, C, D]\n}\n```\n\nTwo elements are considered\
        \ different when comparing them using the double equality sign returns `false`.\n\
        \n```kotlin\n// by default, each object from a regular class is unique\nclass\
        \ Cat(val name: String)\n\n// if the data modifier is used,\n// two instances\
        \ with the same properties are equal\ndata class Dog(val name: String)\n\n\
        fun main() {\n    val cat1 = Cat(\"Garfield\")\n    val cat2 = Cat(\"Garfield\"\
        )\n    println(cat1 == cat2) // false\n    println(setOf(cat1, cat2)) // [Cat@4eec7777,\
        \ Cat@3b07d329]\n\n    val dog1 = Dog(\"Rex\")\n    val dog2 = Dog(\"Rex\"\
        )\n    println(dog1 == dog2) // true\n    println(setOf(dog1, dog2)) // [Dog(name=Rex)]\n\
        }\n```\n\nThe most efficient way to remove duplicates from a list is by transforming\
        \ it into a set.\n\n```kotlin\nfun main() {\n    val names = listOf(\"Jake\"\
        , \"John\", \"Jake\", \"James\", \"Jan\")\n    println(names) // [Jake, John,\
        \ Jake, James, Jan]\n    val unique = names.toSet()\n    println(unique) //\
        \ [Jake, John, James, Jan]\n}\n```\n\n### Checking a setâ€™s size or if it is\
        \ empty\n\nYou can always check the number of elements in a set using the\
        \ `size` property.\n\n```kotlin\nfun main() {\n    val set = setOf('A', 'B',\
        \ 'C')\n    println(set.size) // 3\n}\n```\n\nTo check if a set is empty,\
        \ you can compare its size to `0`, or you can use the `isEmpty` method.\n\n\
        ```kotlin\nfun main() {\n    val set = setOf('A', 'B', 'C')\n    println(set.size\
        \ == 0) // false\n    println(set.isEmpty()) // false\n\n    val empty: Set<Int>\
        \ = setOf()\n    println(empty.size == 0) // true\n    println(empty.isEmpty())\
        \ // true\n}\n```\n\n### Checking if a set contains an element\n\nYou can\
        \ check if a set contains a certain element by using the `contains` method\
        \ or the `in` operator. Both these options return `true` if there is an element\
        \ equal to the element you are looking for in the set; otherwise, it returns\
        \ `false`.\n\n```kotlin\nfun main() {\n    val letters = setOf('A', 'B', 'C')\n\
        \    println(letters.contains('A')) // true\n    println(letters.contains('Z'))\
        \ // false\n    println('A' in letters) // true\n    println('Z' in letters)\
        \ // false\n}\n```\n\nYou can also check whether a set does not contain an\
        \ element using the `!in` operator.\n\n```kotlin\nfun main() {\n    val letters\
        \ = setOf(\"A\", \"B\", \"C\")\n    println(\"A\" !in letters) // false\n\
        \    println(\"Z\" !in letters) // true\n}\n```\n\n### Iterating over sets\n\
        \nYou can iterate over a set using a for-loop. Just place the set on the right\
        \ side of `in`.\n\n```kotlin\nfun main() {\n    val letters = setOf('A', 'B',\
        \ 'C')\n    for (letter in letters) {\n        print(letter)\n    }\n}\n```"
          - type: "text"
            stepId: "collections-section-6"
            question: "Maps"
            explanation: "Content for Maps"
            repetable: false
            text: "## Maps\n\nWe use maps to keep associations from keys to their values.\
        \ For instance:\n* From user id to an object representing this user.\n* From\
        \ a website to its IP address.\n* From a configuration name to data stored\
        \ in this configuration.\n\n```kotlin\nclass CachedApiArticleRepository(\n\
        \    val articleApi: ArticleApi\n) {\n    val articleCache: MutableMap<String,\
        \ String> =\n        mutableMapOf()\n\n    fun getContent(key: String) =\n\
        \        articleCache.getOrPut(key) {\n            articleApi.fetchContent(key)\n\
        \        }\n}\n\nclass DeliveryMethodsConfiguration(\n    val deliveryMethods:\
        \ Map<String, DeliveryMethod>\n)\n\nclass TokenRepository {\n    private var\
        \ tokenToUser: Map<String, User> = mapOf()\n\n    fun getUser(token: String)\
        \ = tokenToUser[token]\n\n    fun addToken(token: String, user: User) {\n\
        \        tokenToUser[token] = user\n    }\n}\n```\n\nYou can create a map\
        \ using the `mapOf` function and then use key-value pairs as arguments to\
        \ specify key-value associations. For instance, I might define a map that\
        \ associates countries with their capitals. Pairs can be defined using a constructor\
        \ or the `to` function.\n\n```kotlin\nfun main() {\n    val capitals = mapOf(\n\
        \        \"USA\" to \"Washington DC\",\n        \"Poland\" to \"Warsaw\",\n\
        \    )\n//    val capitals = mapOf(\n//        Pair(\"USA\", \"Washington\
        \ DC\"),\n//        Pair(\"Poland\", \"Warsaw\"),\n//    )\n    println(capitals)\
        \ // {USA=Washington DC, Poland=Warsaw}\n}\n```\n\n`Map` is a generic class.\
        \ The result type is `Map<K, V>`, where `K` is the key type, and `V` is the\
        \ value type. In the case of the map from the `capitals` variable above, both\
        \ the keys and the values are of type `String`, so the map type is `Map<String,\
        \ String>`. However,a key does not need to be the same type as its value.\
        \ Consider a map with associations between letters and their positions in\
        \ the English alphabet, as in the example below. Its type is `Map<Char, Int>`\
        \ because its keys are characters and its values are integers.\n\n```kotlin\n\
        fun main() {\n    val capitals: Map<String, String> = mapOf(\n        \"USA\"\
        \ to \"Washington DC\",\n        \"Poland\" to \"Warsaw\",\n    )\n    println(capitals)\
        \ // {USA=Washington DC, Poland=Warsaw}\n\n    val alphabet: Map<Char, Int>\
        \ =\n        mapOf('A' to 1, 'B' to 2, 'C' to 3)\n    println(alphabet) //\
        \ {A=1, B=2, C=3}\n}\n```\n\n### Finding a value by a key\n\nTo find a value\
        \ by a key, you can use the `get` function or box brackets with the key. For\
        \ instance, to find the value for the key `'A'` in the `alphabet` map, use\
        \ `alphabet.get('A')` or `alphabet['A']`. The result has a nullable value\
        \ type, which is `Int?` in this case. Why nullable? If the key you asked for\
        \ is not in the map, then `null` will be returned.\n\n```kotlin\nfun main()\
        \ {\n    val alphabet: Map<Char, Int> =\n        mapOf('A' to 1, 'B' to 2,\
        \ 'C' to 3)\n    val number: Int? = alphabet['A']\n    println(number) //\
        \ 1\n    println(alphabet['B']) // 2\n    println(alphabet['&']) // null\n\
        }\n```\n\nAll the basic maps are optimized to make finding a value by a key\
        \ a very fast operation[^17_7].\n\n### Adding elements to a map\n\nJust like\
        \ a regular list or a regular set, a regular map is read-only, so it does\
        \ not have methods that would allow elements to be added or removed. However,\
        \ you can use the plus sign to create a new map with new entries. If you add\
        \ a pair to a map, the result is a map with the new entry. If you add two\
        \ maps together, the result is a merge of these two maps.\n\n```kotlin\nfun\
        \ main() {\n    val map1 = mapOf('A' to \"Alex\", 'B' to \"Bob\")\n    val\
        \ map2 = map1 + ('C' to \"Celina\")\n    println(map1) // {A=Alex, B=Bob}\n\
        \    println(map2) // {A=Alex, B=Bob, C=Celina}\n    val map3 = mapOf('D'\
        \ to \"Daniel\", 'E' to \"Ellen\")\n    val map4 = map2 + map3\n    println(map3)\
        \ // {D=Daniel, E=Ellen}\n    println(map4)\n    // {A=Alex, B=Bob, C=Celina,\
        \ D=Daniel, E=Ellen}\n}\n```\n\nBeware that duplicate keys are not allowed;\
        \ so, when you add a new value with an existing key, it replaces the old value.\n\
        \n```kotlin\nfun main() {\n    val map1 = mapOf('A' to \"Alex\", 'B' to \"\
        Bob\")\n    val map2 = map1 + ('B' to \"Barbara\")\n    println(map1) // {A=Alex,\
        \ B=Bob}\n    println(map2) // {A=Alex, B=Barbara}\n}\n```\n\nYou can also\
        \ remove a key from a map using the minus sign.\n\n```kotlin\nfun main() {\n\
        \    val map1 = mapOf('A' to \"Alex\", 'B' to \"Bob\")\n    val map2 = map1\
        \ - 'B'\n    println(map1) // {A=Alex, B=Bob}\n    println(map2) // {A=Alex}\n\
        }\n```\n\n### Checking if a map contains a key\n\nYou can check if your map\
        \ contains a key using the `in` keyword or the `containsKey` method.\n\n```kotlin\n\
        fun main() {\n    val map = mapOf('A' to \"Alex\", 'B' to \"Bob\")\n    println('A'\
        \ in map) // true\n    println(map.containsKey('A')) // true\n    println('Z'\
        \ in map) // false\n    println(map.containsKey('Z')) // false\n}\n```\n\n\
        ### Checking map size\n\nYou can check how many entries you have in a map\
        \ using the `size` property.\n\n```kotlin\nfun main() {\n    val map = mapOf('A'\
        \ to \"Alex\", 'B' to \"Bob\")\n    println(map.size) // 2\n}\n```\n\n###\
        \ Iterating over maps\n\nYou can iterate over a map using a for-loop. You\
        \ iterate over entries that contain `key` and `value` properties.\n\n```kotlin\n\
        fun main() {\n    val map = mapOf('A' to \"Alex\", 'B' to \"Bob\")\n    for\
        \ (entry in map) {\n        println(\"${entry.key} is for ${entry.value}\"\
        )\n    }\n}\n// A is for Alex\n// B is for Bob\n```\n\nYou can also destructure\
        \ each entry into two variables. Kotlin supports destructuring in a for-loop.\
        \ Take a look at the example below.\n\n```kotlin\nfun main() {\n    val map\
        \ = mapOf('A' to \"Alex\", 'B' to \"Bob\")\n    for ((letter, name) in map)\
        \ {\n        println(\"$letter is for $name\")\n    }\n}\n// A is for Alex\n\
        // B is for Bob\n```\n\n### Mutable maps\n\nYou can create a mutable map using\
        \ `mutableMapOf`. The result type is `MutableMap`, which supports methods\
        \ that modify this object. Using it we can:\n* add new entries to the map\
        \ using the `put` method, or box brackets and assignment,\n* remove an entry\
        \ by key using the `remove` method.\n\n```kotlin\nfun main() {\n    val map:\
        \ MutableMap<Char, String> =\n        mutableMapOf('A' to \"Alex\", 'B' to\
        \ \"Bob\")\n    map.put('C', \"Celina\")\n    map['D'] = \"Daria\"\n    println(map)\
        \ // {A=Alex, B=Bob, D=Daria, C=Celina}\n    map.remove('B')\n    println(map)\
        \ // {A=Alex, D=Daria, C=Celina}\n}\n```"
          - type: "text"
            stepId: "collections-section-7"
            question: "Using arrays in practice"
            explanation: "Content for Using arrays in practice"
            repetable: false
            text: "## Using arrays in practice\n\n**Array** is a very basic data structure\
        \ that strongly relates to how memory is organized. Our computer's memory\
        \ is like a big parking lot, where each place has a sequential number. An\
        \ array is like a reservation for a number of adherent spaces. With such a\
        \ reservation, it is really easy to iterate over the cars you own. It is also\
        \ easy to find a car with a specific index.\n\nLet's say that an array starts\
        \ at position 1024 in your memory, and you need to find the element at index\
        \ 100 in the array. You also know that each element takes 4 positions (an\
        \ array reserves constant space for its elements, which in most cases is the\
        \ size of the memory reference). This is an easy problem: our element starts\
        \ at the position 1024 + 100 * 4 = 1424. Accessing an element at a certain\
        \ position is a very simple and efficient operation, which is a big advantage\
        \ of using arrays.\n\nUsing arrays directly is harder than using other kinds\
        \ of collections. They have a constant size, a limited number of operations,\
        \ they do not implement any interface, and they do not override the `toString`,\
        \ `equals` or `hashCode` methods. However, arrays are used by many other data\
        \ structures under the hood. For instance, when you use `mutableListOf` on\
        \ Kotlin/JVM, the result object is `ArrayList`, which keeps elements in an\
        \ array. This is why finding an element at an index in the default list is\
        \ so efficient. So, `ArrayList` has the advantages of arrays, but it offers\
        \ much more. Arrays have a constant size, so you cannot add more elements\
        \ than their size allows. When you add an element to an `ArrayList` and its\
        \ internal array is full already, it creates a bigger one and fills it with\
        \ the previous values. We consider lists a preferred option to arrays, and\
        \ we restrict the usage of arrays to performance-critical parts of our applications[^17_4].\n\
        \nArrays are also used by the default `Set` and `Map` that we use in Kotlin.\
        \ Both are based on a hash table algorithm that needs to use an array to work\
        \ efficiently.\n\nNevertheless, let's see how arrays can be used directly.\
        \ We create an array using the `arrayOf` function. This creates an instance\
        \ of class `Array` and of type `Array<T>`, where `T` is the type of the elements.\
        \ To get an element at a certain index, we can use box brackets or the `get`\
        \ method. To modify an element at a certain position, you can use box brackets\
        \ or the `set` method. You can also get an arrayâ€™s size using the `size` property\
        \ or by iterating over the array using a for-loop.\n\n```kotlin\nfun main()\
        \ {\n    val arr: Array<String> = arrayOf(\"A\", \"B\", \"C\")\n    println(arr[0])\
        \ // A\n    println(arr.get(0)) // A\n    println(arr[1]) // B\n    arr[1]\
        \ = \"D\"\n    println(arr[1]) // D\n    arr.set(2, \"E\")\n    println(arr[2])\
        \ // E\n    println(arr.size) // 3\n    for (e in arr) {\n        print(e)\n\
        \    }\n    // ADE\n}\n```\n\nAll the above operations are the same as for\
        \ `MutableList`, but this is where the list of basic array operations ends.\
        \ Arrays do not support equality, so two arrays with the same elements are\
        \ not considered equal. Another problem with arrays is that their `toString`\
        \ method, which is used to transform an object into a `String`, does not print\
        \ elements. It only prints the array type and the hash of its memory reference.\n\
        \n```kotlin\nfun main() {\n    val arr1 = arrayOf(\"A\", \"B\", \"C\")\n \
        \   val arr2 = arrayOf(\"A\", \"B\", \"C\")\n    println(arr1 == arr2) //\
        \ false\n    println(arr1) // [Ljava.lang.String;@4f023edb\n    println(arr2)\
        \ // [Ljava.lang.String;@3a71f4dd\n}\n```\n\nTo cheer up those who like using\
        \ arrays, the Kotlin standard library offers a number of extension functions\
        \ that allow many kinds of array transformations.\n\n![](array_operations.png)\n\
        \nNotice that there is a `plus` method that allows a new element to be added\
        \ to an array. Just like the `plus` method on a list, it does not modify the\
        \ array but creates a new one with a larger size.\n\n```kotlin\n// JVM implementation\n\
        operator fun <T> Array<T>.plus(element: T): Array<T> {\n    val index = size\n\
        \    val result = java.util.Arrays.copyOf(this, index + 1)\n    result[index]\
        \ = element\n    return result\n}\n\nfun main() {\n    val arr = arrayOf(\"\
        A\", \"B\", \"C\")\n    println(arr.size) // 3\n    val arr2 = arr + \"D\"\
        \n    println(arr.size) // 3\n    println(arr2.size) // 4\n}\n```\n\nYou can\
        \ transform an array to a list or a set using the `toList` and `toSet` methods.\
        \ To transfer the other way around, use `toTypedArray`.\n\n```kotlin\nfun\
        \ main() {\n    val arr1: Array<String> = arrayOf(\"A\", \"B\", \"C\")\n \
        \   val list: List<String> = arr1.toList()\n    val arr2: Array<String> =\
        \ list.toTypedArray()\n    val set: Set<String> = arr2.toSet()\n    val arr3:\
        \ Array<String> = set.toTypedArray()\n}\n```\n\n### Arrays of primitives\n\
        \nSome kinds of Kotlin value types, like `Int` or `Char`, can be represented\
        \ in a more basic way than a regular object. This form is known as a primitive\
        \ and is a Kotlin optimization that does not affect the usage of values; however,\
        \ it makes primitive values take less memory and their use more efficient.\
        \ The problem is that primitives cannot be kept in regular collections, but\
        \ we can store them in special arrays. For each value that has a primitive\
        \ form, there is a dedicated array type. These are:\n* `IntArray`, which represents\
        \ an array of primitive `Int` values.\n* `LongArray`, which represents an\
        \ array of primitive `Long` values.\n* `DoubleArray`, which represents an\
        \ array of primitive `Double` values.\n* `FloatArray`, which represents an\
        \ array of primitive `Float` values.\n* `CharArray`, which represents an array\
        \ of primitive `Char` values.\n* `BooleanArray`, which represents an array\
        \ of primitive `Boolean` values.\n* `ShortArray`, which represents an array\
        \ of primitive `Short` values.\n* `ByteArray`, which represents an array of\
        \ primitive `Byte` values.\n\nEach of these arrays can be created in two ways:\n\
        * Using the `xxxOf` function and initial elements as arguments, where `xxx`\
        \ is the decapitalized name of the array. For example, to create `DoubleArray`,\
        \ you can use the `doubleArrayOf` function with arguments of type `Double`.\n\
        * By transforming another kind of collection into an array of primitives using\
        \ the `toXXX` method, where `XXX` is the name of the array. For instance,\
        \ you can transform `List<Boolean>` into `BooleanArray` using the `toBooleanArray`\
        \ method.\n\n```kotlin\nfun main() {\n    val doubles: DoubleArray = doubleArrayOf(2.71,\
        \ 3.14, 9.8)\n    val chars: CharArray = charArrayOf('X', 'Y', 'Z')\n\n  \
        \  val accepts: List<Boolean> = listOf(true, false, true)\n    val acceptsArr:\
        \ BooleanArray = accepts.toBooleanArray()\n\n    val ints: Set<Int> = setOf(2,\
        \ 4, 8, 10)\n    val intsArr: IntArray = ints.toIntArray()\n}\n```\n\nArrays\
        \ of primitives are not used often in most real-life projects. They are generally\
        \ treated as low-level performance or memory use optimizations[^17_5].\n\n\
        ### Vararg parameters and array functions\n\nAs mentioned in the chapter *Functions*,\
        \ we can use the `vararg` modifier for a parameter to make it accept any number\
        \ of arguments. This modifier turns a parameter into an array. Consider the\
        \ `markdownList` function from the example below. Its `lines` parameter has\
        \ `String` type specified, but since it has the modifier `vararg`, the actual\
        \ type of `lines` is `Array<String>`. This is why we can iterate over it using\
        \ a for loop.\n\n```kotlin\nfun markdownList(vararg lines: String): String\
        \ {\n    // the type of lines is Array<String>\n    var str = \"\"\n    for\
        \ ((i, line) in lines.withIndex()) {\n        str += \" * $line\"\n      \
        \  if (i != lines.size) {\n            str += \"\\n\"\n        }\n    }\n\
        \    return str\n}\n\nfun main() {\n    print(markdownList(\"A\", \"B\", \"\
        C\"))\n    // * A\n    // * B\n    // * C\n}\n```\n\nThe basic functions used\
        \ to create collections, like `listOf` or `setOf`, can have any number of\
        \ arguments because they use the `vararg` modifier.\n\n```kotlin\nfun <T>\
        \ listOf(vararg elements: T): List<T> =\n    if (elements.size > 0) elements.asList()\
        \ else emptyList()\n\nfun <T> setOf(vararg elements: T): Set<T> =\n    if\
        \ (elements.size > 0) elements.toSet() else emptySet()\n```\n\nYou can also\
        \ spread an array into vararg arguments using the `*` symbol.\n\n```kotlin\n\
        fun main() {\n    val arr = arrayOf(\"B\", \"C\")\n    print(markdownList(\"\
        A\", *arr, \"D\"))\n    // * A\n    // * B\n    // * C\n    // * D\n}\n```"
          - type: "text"
            stepId: "collections-section-8"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nIn this chapter we've seen the most important kinds of\
        \ Kotlin collections and their typical use-cases:\n\n* `List` represents an\
        \ ordered collection of elements. It is the most basic way to keep a collection\
        \ of elements.\n* `Set` represents a collection of unique elements. We use\
        \ it when we want to make sure that elements in our collection are unique,\
        \ or when we often need to look for a certain element.\n* `Map` is a set of\
        \ key-value pairs. We use it to keep associations from keys to values.\n\n\
        Arrays are rarely used directly in Kotlin as we prefer to use other kinds\
        \ of collections.\n\n[^17_0]: This topic is covered in *Effective Kotlin*,\
        \ especially in *Item 26: Use abstraction to protect code against changes*.\n\
        [^17_1]: The default value is calculated by a functional argument, such as\
        \ a lambda expression; we will describe this in the next book *Functional\
        \ Kotlin*\n[^17_2]: As presented in *Effective Kotlin*, *Item 1: Limit mutability*.\n\
        [^17_3]: As presented in *Effective Kotlin*, *Item 59: Consider using mutable\
        \ collections*.\n[^17_4]: See *Effective Kotlin*, *Item 58: Consider Arrays\
        \ with primitives for performance-critical processing*.\n[^17_5]: See *Effective\
        \ Kotlin*, *Item 58: Consider Arrays with primitives for performance-critical\
        \ processing*.\n[^17_6]: The default set is based on a hash table algorithm,\
        \ which makes finding an element with a properly implemented `hashCode` really\
        \ fast. This operation time does not depend on the number of elements in the\
        \ set (so has O(1) complexity). For details about how this hash table algorithm\
        \ works, see Effective Kotlin *Item 43: Respect the contract of hashCode*.\n\
        [^17_7]: The default map is based on a hash table algorithm, which makes finding\
        \ an element by key really fast (when this key has a properly implemented\
        \ `hashCode` method). This operation time does not depend on the number of\
        \ entries in the map (so has O(1) complexity). For details about how this\
        \ hash table algorithm works, see Effective Kotlin *Item 43: Respect the contract\
        \ of hashCode*."
          - type: "single-answer"
            stepId: "collections-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "collections-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "collections-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "collections-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "collections-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "operators"
        name: "Operator overloading"
        steps:
          - type: "text"
            stepId: "operators-introduction"
            question: "Operator overloading"
            explanation: "Introduction to Operator overloading"
            repetable: false
            text: "# Operator overloading\n\nIn Kotlin, we can add an element to a list\
        \ using the `+` operator. In the same way, we can add two strings together.\
        \ We can check if a collection contains an element using the `in` operator.\
        \ We can also add, subtract or multiply elements of type `BigDecimal`, which\
        \ is a JVM class that is used to represent possibly big numbers with unlimited\
        \ precision.\n\n```kotlin\nimport java.math.BigDecimal\n\nfun main() {\n \
        \   val list: List<String> = listOf(\"A\", \"B\")\n    val newList: List<String>\
        \ = list + \"C\"\n    println(newList) // [A, B, C]\n\n    val str1: String\
        \ = \"AB\"\n    val str2: String = \"CD\"\n    val str3: String = str1 + str2\n\
        \    println(str3) // ABCD\n\n    println(\"A\" in list) // true\n    println(\"\
        C\" in list) // false\n\n    val money1: BigDecimal = BigDecimal(\"12.50\"\
        )\n    val money2: BigDecimal = BigDecimal(\"3.50\")\n    val money3: BigDecimal\
        \ = money1 * money2\n    println(money3) // 43.7500\n}\n```\n\nUsing operators\
        \ between objects is possible thanks to the Kotlin feature called *operator\
        \ overloading*, which allows special kinds of methods to be defined that can\
        \ be used as operators. Let's see this in a custom class example."
          - type: "text"
            stepId: "operators-section-1"
            question: "An example of operator overloading"
            explanation: "Content for An example of operator overloading"
            repetable: false
            text: "## An example of operator overloading\n\nLet's say that you need to represent\
        \ complex numbers in your application. These are special kinds of numbers\
        \ in mathematics that are represented by two parts: real and imaginary. Complex\
        \ numbers are useful for a variety of kinds of calculations in physics and\
        \ engineering.\n\n```kotlin\ndata class Complex(val real: Double, val imaginary:\
        \ Double)\n```\n\nIn mathematics, there is a range of operations that we can\
        \ do on complex numbers. For instance, you can add two complex numbers or\
        \ subtract a complex number from another complex number. This is done using\
        \ the `+` and `-` operators. Therefore, it is reasonable that we should support\
        \ these operators for our `Complex` class. To support the `+` operator, we\
        \ need to define a method that has an `operator` modifier that is called `plus`\
        \ and a single parameter. To support the `-` operator, we need to define a\
        \ method that has an `operator` modifier called `minus` and a single parameter.\n\
        \n```kotlin\ndata class Complex(val real: Double, val imaginary: Double) {\n\
        \n    operator fun plus(another: Complex) = Complex(\n        real + another.real,\n\
        \        imaginary + another.imaginary\n    )\n\n    operator fun minus(another:\
        \ Complex) = Complex(\n        real = real - another.real,\n        imaginary\
        \ = imaginary - another.imaginary\n    )\n}\n\n// example usage\nfun main()\
        \ {\n    val c1 = Complex(1.0, 2.0)\n    val c2 = Complex(2.0, 3.0)\n    println(c1\
        \ + c2) // Complex(real=3.0, imaginary=5.0)\n    println(c2 - c1) // Complex(real=1.0,\
        \ imaginary=1.0)\n}\n```\n\nUsing the `+` and `-` operators is equivalent\
        \ to calling the `plus` and `minus` functions. These two can be used interchangeably.\n\
        \n```kotlin\nc1 + c2 // under the hood is c1.plus(c2)\nc1 - c2 // under the\
        \ hood is c1.minus(c2)\n```\n\nKotlin defines a concrete set of operators,\
        \ for each of which there is a specific name and a number of supported arguments.\
        \ Additionally, all operators need to be a method (so, either a member function\
        \ or an extension function), and these methods need the `operator` modifier.\n\
        \nWell-used operators can help us improve our code readability as much as\
        \ poorly used operators can harm it[^18_1]. Let's discuss all the Kotlin operators."
          - type: "text"
            stepId: "operators-section-2"
            question: "Arithmetic operators"
            explanation: "Content for Arithmetic operators"
            repetable: false
            text: "## Arithmetic operators\n\nLet's start with arithmetic operators, like\
        \ plus or times. These are easiest for the Kotlin compiler because it just\
        \ needs to transform the left column to the right.\n\n| Expression | Translates\
        \ to     |\n|------------|-------------------|\n| `a + b`    | `a.plus(b)`\
        \       |\n| `a - b`    | `a.minus(b)`      |\n| `a * b`    | `a.times(b)`\
        \      |\n| `a / b`    | `a.div(b)`        |\n| `a % b`    | `a.rem(b)`  \
        \      |\n| `a..b `    | `a.rangeTo(b)`    |\n| `a..<b `   | `a.rangeUntil(b)`\
        \ |\n\nNotice that `%` translates to `rem`, which is a short form of \"remainder\"\
        . This operator returns the remainder left over when one operand is divided\
        \ by a second operand, so it is similar to the modulo operation[^18_0].\n\n\
        ```kotlin\nfun main() {\n    println(13 % 4) // 1\n    println(7 % 4)  //\
        \ 3\n    println(1 % 4)  // 1\n    println(0 % 4)  // 0\n    println(-1 %\
        \ 4) // -1\n    println(-5 % 4) // -1\n    println(-7 % 4) // -3\n}\n```\n\
        \nIt is also worth mentioning `..` and `..<` operators, that are used to create\
        \ ranges. We can use them between integers to create `IntRange`, over which\
        \ we can iterate in for-loop. We can also use those operators between any\
        \ values that implement `Comparable` interface, to define a range by extremes\
        \ of this range.\n\n```kotlin\nfun main() {\n    val intRange: IntRange =\
        \ 1..10\n    val comparableRange: ClosedRange<String> = \"A\"..\"Z\"\n   \
        \ val openEndRange: OpenEndRange<Double> = 1.0..<2.0\n}\n```"
          - type: "text"
            stepId: "operators-section-3"
            question: "The `in` operator"
            explanation: "Content for The `in` operator"
            repetable: false
            text: "## The `in` operator\n\nOne of my favorite operators is `in`. The expression\
        \ `a in b` translates to `b.contains(a)`. There is also `!in`, which translates\
        \ to negation.\n\n| Expression | Translates to    |\n|------------|------------------|\n\
        | `a in b`   | `b.contains(a)`  |\n| `a !in b`  | `!b.contains(a)` |\n\nThere\
        \ are a few ways to use this operator. Firstly, for collections, instead of\
        \ checking if a list contains an element, you can check if the element is\
        \ in the list.\n\n```kotlin\nfun main() {\n    val letters = setOf(\"A\",\
        \ \"B\", \"C\")\n    println(\"A\" in letters) // true\n    println(\"D\"\
        \ in letters) // false\n    println(letters.contains(\"A\")) // true\n   \
        \ println(letters.contains(\"D\")) // false\n}\n```\n\nWhy would you do that?\
        \ Primarily for readability. Would you ask \"Does the fridge contain a beer?\"\
        \ or \"Is there a beer in the fridge?\"? Using the `in` operator gives us\
        \ the possibility to choose.\n\nWe also often use the `in` operator together\
        \ with ranges. The expression `1..10` produces an object of type `IntRange`,\
        \ which has a `contains` method. This is why you can use `in` and a range\
        \ to check if a number is in this range.\n\n```kotlin\nfun main() {\n    println(5\
        \ in 1..10) // true\n    println(11 in 1..10) // false\n}\n```\n\nYou can\
        \ make a range from any objects that are comparable, and the result `ClosedRange`\
        \ also has a `contains` method. This is why you can use a range check for\
        \ any objects that are comparable, such as big numbers or objects representing\
        \ time.\n\n```kotlin\nimport java.math.BigDecimal\nimport java.time.LocalDateTime\n\
        \nfun main() {\n    val amount = BigDecimal(\"42.80\")\n    val minPrice =\
        \ BigDecimal(\"5.00\")\n    val maxPrice = BigDecimal(\"100.00\")\n    val\
        \ correctPrice = amount in minPrice..maxPrice\n    println(correctPrice) //\
        \ true\n\n    val now = LocalDateTime.now()\n    val actionStarts = LocalDateTime.of(1410,\
        \ 7, 15, 0, 0)\n    val actionEnds = actionStarts.plusDays(1)\n    println(now\
        \ in actionStarts..actionEnds) // false\n}\n```"
          - type: "text"
            stepId: "operators-section-4"
            question: "The iterator operator"
            explanation: "Content for The iterator operator"
            repetable: false
            text: "## The iterator operator\n\nYou can use for-loop to iterate over any\
        \ object that has an `iterator` operator method. Every object that implements\
        \ an `Iterable` interface must support the `iterator` method. \n\n```kotlin\n\
        public interface Iterable<out T> {\n    /**\n     * Returns an iterator over\
        \ the elements of this object.\n     */\n    public operator fun iterator():\
        \ Iterator<T>\n}\n```\n\nYou can define objects that can be iterated over,\
        \ but do not implement `Iterable` interface. `Map` is a great example. It\
        \ does not implement the `Iterable` interface, yet you can iterate over it\
        \ using a for-loop. How so? It is thanks to the `iterator` operator, which\
        \ is defined as an extension function in Kotlin stdlib.\n\n```kotlin\n// Part\
        \ of Kotlin standard library\ninline operator fun <K, V>\nMap<out K, V>.iterator():\
        \ Iterator<Map.Entry<K, V>> =\n    entries.iterator()\n\nfun main() {\n  \
        \  val map = mapOf('a' to \"Alex\", 'b' to \"Bob\")\n    for ((letter, name)\
        \ in map) {\n        println(\"$letter like in $name\")\n    }\n}\n// a like\
        \ in Alex\n// b like in Bob\n```\n\nTo better understand how a for-loop works,\
        \ consider the code below.\n\n```kotlin\nfun main() {\n    for (e in Tree())\
        \ {\n        // body\n    }\n}\n\nclass Tree {\n    operator fun iterator():\
        \ Iterator<String> = ...\n}\n```\n\nUnder the hood, a for-loop is compiled\
        \ into bytecode that uses a while-loop to iterate over the object's iterator,\
        \ as presented in the snippet below.\n\n```kotlin\nfun main() {\n    val iterator\
        \ = Tree().iterator()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n\
        \        // body\n    }\n}\n```"
          - type: "text"
            stepId: "operators-section-5"
            question: "The equality and inequality operators"
            explanation: "Content for The equality and inequality operators"
            repetable: false
            text: "## The equality and inequality operators\n\nIn Kotlin, there are two\
        \ types of equality:\n\n* Structural equality - checked with the `equals`\
        \ method or the `==` operator (and its negated counterpart `!=`). `a == b`\
        \ translates to `a.equals(b)` when `a` is not nullable, otherwise it translates\
        \ to `a?.equals(b) ?: (b === null)`. Structural equality is generally preferred\
        \ over referential equality. The `equals` method can be overridden in custom\
        \ class.\n\n* Referential equality - checked with the `===` operator (and\
        \ its negated counterpart `!==`); returns `true` when both sides point to\
        \ the same object. `===` and `!==` (identity checks) are not overloadable.\n\
        \nSince `equals` is implemented in `Any`, which is the superclass of every\
        \ class, we can check the equality of any two objects.\n\n| Expression | Translates\
        \ to                     |\n|------------|-----------------------------------|\n\
        | `a == b`   | `a?.equals(b) ?: (b === null)`    |\n| `a != b`   | `!(a?.equals(b)\
        \ ?: (b === null))` |"
          - type: "text"
            stepId: "operators-section-6"
            question: "Comparison operators"
            explanation: "Content for Comparison operators"
            repetable: false
            text: "## Comparison operators\n\nSome classes have natural order, which is\
        \ the order that is used by default when we compare two instances of a given\
        \ class. Numbers are a good example: 10 is a smaller number than 100. There\
        \ is a popular Java convention that classes with natural order should implement\
        \ a `Comparable` interface, which requires the `compareTo` method, which is\
        \ used to compare two objects.\n\n```kotlin\npublic interface Comparable<in\
        \ T> {\n    /**\n     * Compares this object with the specified object for\n\
        \     * order. Returns zero if this object is equal to the\n     * specified\
        \ [other] object, a negative number if it's\n     * less than [other], or\
        \ a positive number if it's\n     * greater than [other].\n     */\n    public\
        \ operator fun compareTo(other: T): Int\n}\n```\n\nAs a result, there is a\
        \ convention that we should compare two objects using the `compareTo` method.\
        \ However, using the `compareTo` method directly is not very intuitive. Let's\
        \ say that you see `a.compareTo(b) > 0` in code. What does it mean? Kotlin\
        \ simplifies this by making `compareTo` an operator that can be replaced with\
        \ intuitive mathematical comparison operators: `>`, `<`, `>=`, and `<=`.\n\
        \n| Expression | Translates to         |\n|------------|-----------------------|\n\
        | `a > b`    | `a.compareTo(b) > 0`  |\n| `a < b`    | `a.compareTo(b) < 0`\
        \  |\n| `a >= b`   | `a.compareTo(b) >= 0` |\n| `a <= b`   | `a.compareTo(b)\
        \ <= 0` |\n\nI often use comparison operators to compare amounts kept in objects\
        \ of type `BigDecimal` or `BigInteger`.\n\n```kotlin\nimport java.math.BigDecimal\n\
        \nfun main() {\n    val amount1 = BigDecimal(\"42.80\")\n    val amount2 =\
        \ BigDecimal(\"5.00\")\n    println(amount1 > amount2) // true\n    println(amount1\
        \ >= amount2) // true\n    println(amount1 < amount2) // false\n    println(amount1\
        \ <= amount2) // false\n    println(amount1 > amount1) // false\n    println(amount1\
        \ >= amount1) // true\n    println(amount1 < amount2) // false\n    println(amount1\
        \ <= amount2) // false\n}\n```\n\nI also like to compare time references the\
        \ same way.\n\n```kotlin\nimport java.time.LocalDateTime\n\nfun main() {\n\
        \    val now = LocalDateTime.now()\n    val actionStarts = LocalDateTime.of(2010,\
        \ 10, 20, 0, 0)\n    val actionEnds = actionStarts.plusDays(1)\n    println(now\
        \ > actionStarts) // true\n    println(now <= actionStarts) // false\n   \
        \ println(now < actionEnds) // false\n    println(now >= actionEnds) // true\n\
        }\n```"
          - type: "text"
            stepId: "operators-section-7"
            question: "The indexed access operator"
            explanation: "Content for The indexed access operator"
            repetable: false
            text: "## The indexed access operator\n\nIn programming, there are two popular\
        \ conventions for getting or setting elements in collections. The first uses\
        \ box brackets, while the second uses the `get` and `set` methods. In Java,\
        \ we use the first convention for arrays and the second one for other kinds\
        \ of collections. In Kotlin, both conventions can be used interchangeably\
        \ because the `get` and `set` methods are operators that can be used with\
        \ box brackets.\n\n| Expression             | Translates to             |\n\
        |------------------------|---------------------------|\n| `a[i]`         \
        \        | `a.get(i)`                |\n| `a[i, j]`              | `a.get(i,\
        \ j)`             |\n| `a[i_1, ..., i_n]`     | `a.get(i_1, ..., i_n)`   \
        \ |\n| `a[i] = b`             | `a.set(i, b)`             |\n| `a[i, j] =\
        \ b`          | `a.set(i, j, b)`          |\n| `a[i_1, ..., i_n] = b` | `a.set(i_1,\
        \ ..., i_n, b)` |\n\n```kotlin\nfun main() {\n    val mutableList = mutableListOf(\"\
        A\", \"B\", \"C\")\n    println(mutableList[1]) // B\n    mutableList[2] =\
        \ \"D\"\n    println(mutableList) // [A, B, D]\n\n    val animalFood = mutableMapOf(\n\
        \        \"Dog\" to \"Meat\",\n        \"Goat\" to \"Grass\"\n    )\n    println(animalFood[\"\
        Dog\"]) // Meat\n    animalFood[\"Cat\"] = \"Meat\"\n    println(animalFood[\"\
        Cat\"]) // Meat\n}\n```\n\nSquare brackets are translated to `get` and `set`\
        \ calls with appropriate numbers of arguments. Variants of `get` and `set`\
        \ functions with more arguments might be used by data processing libraries.\
        \ For instance, you could have an object that represents a table and use box\
        \ brackets with two arguments: `x` and `y` coordinates."
          - type: "text"
            stepId: "operators-section-8"
            question: "Augmented assignments"
            explanation: "Content for Augmented assignments"
            repetable: false
            text: "## Augmented assignments\n\nWhen we set a new value for a variable, this\
        \ new value is often based on its previous value. For instance, we might want\
        \ to add a value to the previous one. For this, augmented assignments were\
        \ introduced[^18_3]. For example, `a += b` is a shorter notation of `a = a\
        \ + b`. There are similar notations for other arithmetic operations.\n\n|\
        \ Expression | Translates to |\n|------------|---------------|\n| `a += b`\
        \   | `a = a + b`   |\n| `a -= b`   | `a = a - b`   |\n| `a *= b`   | `a =\
        \ a * b`   |\n| `a /= b`   | `a = a / b`   |\n| `a %= b`   | `a = a % b` \
        \  |\n\nNotice that augmented assignments can be used for all types that support\
        \ the appropriate arithmetic operation, including lists or strings. Such augmented\
        \ assignments need a variable to be read-write, namely `var`, and the result\
        \ of the mathematical operation must have a proper type (to translate `a +=\
        \ b` to `a = a + b`, the variable `a` needs to be `var`, and `a + b` needs\
        \ to be a subtype of type `a`).\n\n```kotlin\nfun main() {\n    var str =\
        \ \"ABC\"\n    str += \"D\" // translates to str = str + \"D\"\n    println(str)\
        \ // ABCD\n\n    var l = listOf(\"A\", \"B\", \"C\")\n    l += \"D\" // translates\
        \ to l = l + \"D\"\n    println(l) // [A, B, C, D]\n}\n```\n\nAugmented assignments\
        \ can be used in another way: to modify a mutable object. For instance, we\
        \ can use `+=` to add an element to a mutable list. In such a case, `a +=\
        \ b` translates to `a.plusAssign(b)`.\n\n| Expression | Translates to    \
        \  |\n|------------|--------------------|\n| `a += b`   | `a.plusAssign(b)`\
        \  |\n| `a -= b`   | `a.minusAssign(b)` |\n| `a *= b`   | `a.timesAssign(b)`\
        \ |\n| `a /= b`   | `a.divAssign(b)`   |\n| `a %= b`   | `a.remAssign(b)`\
        \   |\n\n```kotlin\nfun main() {\n    val names = mutableListOf(\"Jake\",\
        \ \"Ben\")\n    names += \"Jon\"\n    names -= \"Ben\"\n    println(names)\
        \ // [Jake, Jon]\n\n    val tools = mutableMapOf(\n        \"Grass\" to \"\
        Lawnmower\",\n        \"Nail\" to \"Hammer\"\n    )\n    tools += \"Screw\"\
        \ to \"Screwdriver\"\n    tools -= \"Grass\"\n    println(tools) // {Nail=Hammer,\
        \ Screw=Screwdriver}\n}\n```\n\nIf both kinds of augmented assignment can\
        \ be applied, Kotlin chooses to modify a mutable object by default."
          - type: "text"
            stepId: "operators-section-9"
            question: "Unary prefix operators"
            explanation: "Content for Unary prefix operators"
            repetable: false
            text: "## Unary prefix operators\n\nA plus, minus, or negation in front of a\
        \ single value is also an operator. Operators that are used with only a single\
        \ value are called **unary operators**[^18_4]. Kotlin supports operator overloading\
        \ for the following unary operators:\n\n| Expression | Translates to    |\n\
        |------------|------------------|\n| `+a`       | `a.unaryPlus()`  |\n| `-a`\
        \       | `a.unaryMinus()` |\n| `!a`       | `a.not()`        |\n\nHere is\
        \ an example of overloading the `unaryMinus` operator.\n\n```kotlin\ndata\
        \ class Point(val x: Int, val y: Int)\n\noperator fun Point.unaryMinus() =\
        \ Point(-x, -y)\n\nfun main() {\n    val point = Point(10, 20)\n    println(-point)\
        \  // Point(x=-10, y=-20)\n}\n```\n\nThe `unaryPlus` operator is often used\
        \ as part of Kotlin DSLs, which are described in detail in the next book of\
        \ this series, *Functional Kotlin*."
          - type: "text"
            stepId: "operators-section-10"
            question: "Increment and decrement"
            explanation: "Content for Increment and decrement"
            repetable: false
            text: "## Increment and decrement\n\nAs part of many algorithms used in older\
        \ languages, we often needed to add or subtract the value `1` from a variable,\
        \ which is why increment and decrement were invented. The `++` operator is\
        \ used to add `1` to a variable; so, if `a` is an integer, then `a++` translates\
        \ to `a = a + 1`. The `--` operator is used to subtract `1` from a variable;\
        \ so, if `a` is an integer, then `a--` translates to `a = a - 1`.\n\nBoth\
        \ increment and decrement can be used before or after a variable, and this\
        \ determines the value returned by this operation.\n* If you use `++` **before**\
        \ a variable, it is called **pre-increment**; it increments the variable and\
        \ then returns the result of this operation.\n* If you use `++` **after**\
        \ a variable, it is called **post-increment**; it increments the variable\
        \ but then returns the value before the operation.\n* If you use `--` **before**\
        \ a variable, it is called **pre-decrement**; it decrements the variable and\
        \ then returns the result of this operation.\n* If you use `--` **after**\
        \ a variable, it is called **post-decrement**; it decrements the variable\
        \ but then returns the value before the operation.\n\n```kotlin\nfun main()\
        \ {\n    var i = 10\n    println(i++) // 10\n    println(i) // 11\n    println(++i)\
        \ // 12\n    println(i) // 12\n\n    i = 10\n    println(i--) // 10\n    println(i)\
        \ // 9\n    println(--i) // 8\n    println(i) // 8\n}\n```\n\nBased on the\
        \ `inc` and `dec` methods, Kotlin supports increment and decrement overloading,\
        \ which should increment or decrement a custom object. I have never seen this\
        \ capability used in practice, so I think it is enough to know that it exists.\n\
        \n| Expression | Translates to (simplified)      |\n|------------|---------------------------------|\n\
        | `++a`      | `a = a.inc(); a`                |\n| `a++`      | `val tmp\
        \ = a; a = a.inc(); tmp` |\n| `--a`      | `a = a.dec(); a`              \
        \  |\n| `a--`      | `val tmp = a; a = a.dec(); tmp` |"
          - type: "text"
            stepId: "operators-section-11"
            question: "The invoke operator"
            explanation: "Content for The invoke operator"
            repetable: false
            text: "## The invoke operator\n\nObjects with the `invoke` operator can be called\
        \ like functions, so with parentheses straight after the variable representing\
        \ this object. Calling an object translates to the `invoke` method call with\
        \ the same arguments.\n\n| Expression         | Translates to            \
        \ |\n|--------------------|---------------------------|\n| `a()`         \
        \     | `a.invoke()`              |\n| `a(i)`             | `a.invoke(i)`\
        \             |\n| `a(i, j)`          | `a.invoke(i, j)`          |\n| `a(i_1,\
        \ ..., i_n)` | `a.invoke(i_1, ..., i_n)` |\n\nThe `invoke` operator is used\
        \ for objects that represent functions, such as lambda expressions[^18_2]\
        \ or UseCases objects from Clean Architecture.\n\n```kotlin\nclass CheerUseCase\
        \ {\n    operator fun invoke(who: String) {\n        println(\"Hello, $who\"\
        )\n    }\n}\n\nfun main() {\n    val hello = {\n        println(\"Hello\"\
        )\n    }\n    hello() // Hello\n\n    val cheerUseCase = CheerUseCase()\n\
        \    cheerUseCase(\"Reader\") // Hello, Reader\n}\n```"
          - type: "text"
            stepId: "operators-section-12"
            question: "Precedence"
            explanation: "Content for Precedence"
            repetable: false
            text: "## Precedence\n\nWhat is the result of the expression `1 + 2 * 3`? The\
        \ answer is `7`, not `9`, because in mathematics we multiply before adding.\
        \ We say that multiplication has higher precedence than addition.\n\nPrecedence\
        \ is also extremely important in programming because when the compiler evaluates\
        \ an expression such as `1 + 2 == 3`, it needs to know if it should first\
        \ add `1` to `2`, or compare `2` and `3`. The following table compares the\
        \ precedence of all the operators, including those that can be overloaded\
        \ and those that cannot.\n\n| Precedence | Title           | Symbols     \
        \                             |\n|------------|-----------------|------------------------------------------|\n\
        | Highest    | Postfix         | ++, --, . (regular call), ?. (safe call)\
        \ |\n|            | Prefix          | -, +, ++, --, !                    \
        \      |\n|            | Type casting    | as, as?                       \
        \           |\n|            | Multiplicative  | *, /, %                  \
        \                |\n|            | Additive        | +, -                \
        \                     |\n|            | Range           | ..             \
        \                          |\n|            | Infix function  | simpleIdentifier\
        \                         |\n|            | Elvis           | ?:         \
        \                              |\n|            | Named checks    | in, !in,\
        \ is, !is                         |\n|            | Comparison      | <, >,\
        \ <=, >=                             |\n|            | Equality        | ==,\
        \ !=, ===, !==                         |\n|            | Conjunction     |\
        \ &&                                       |\n|            | Disjunction \
        \    | \\                                        |\\|                  |\n\
        |            | Spread operator | *                                       \
        \ |\n| Lowest     | Assignment      | =, +=, -=, *=, /=, %=              \
        \      |\n\nOn the basis of this table, can you predict what the following\
        \ code will print?\n\n```kotlin\nfun main() {\n    println(-1.plus(1))\n}\n\
        ```\n\nThis is a popular Kotlin puzzle. The answer is `-2`, not `0`, because\
        \ a single minus in front of a function is an operator whose precedence is\
        \ lower than an explicit `plus` method call. So, we first call the method\
        \ and then call `unaryMinus` on the result, therefore we change from `2` to\
        \ `-2`. To use `-1` literally, wrap it with parentheses.\n\n```kotlin\nfun\
        \ main() {\n    println((-1).plus(1)) // 0\n}\n```"
          - type: "text"
            stepId: "operators-section-13"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nWe use a lot of operators in Kotlin, many of which can\
        \ be overloaded. This can be used to improve our codeâ€™s readability. From\
        \ the cognitive standpoint, using an intuitive operator can be a huge improvement\
        \ over using methods everywhere. Therefore, iitâ€™s good to know what options\
        \ are available and to be open to using operators defined by Kotlin stdlib,\
        \ but itâ€™s also good to be able to define our own operators.\n\n[^18_0]: This\
        \ operator was previously called `mod`, which comes from \"modulo\", but this\
        \ name is now deprecated. In mathematics, both the remainder and the modulo\
        \ operations act the same for positive numbers, but the difference lies in\
        \ negative numbers. The result of -5 remainder 4 is -1, because -5 = 4 * (-1)\
        \ + (-1). The result of -5 modulo 4 is 3, because -5 = 4 * (-2) + 3. Kotlinâ€™\
        s `%` operator implements the behavior of remainder, which is why its name\
        \ needed to be changed from `mod` to `rem`.\n[^18_1]: You can find more about\
        \ this in *Effective Kotlin*, *Item 11: An operatorâ€™s meaning should be consistent\
        \ with its function name* and *Item 12: Use operators to increase readability*.\n\
        [^18_2]: There will be more about lambda expressions in the next book of the\
        \ series, *Functional Kotlin*.\n[^18_3]: I am not sure which language introduced\
        \ augmented assignments first, but they are even supported by languages as\
        \ old as C.\n[^18_4]: Unary operators are used with only a single value (operand).\
        \ Operators used with two values are known as binary operators; however, since\
        \ most operators are binary, this type is often treated as the default. Operators\
        \ used with three values are known as ternary operators. Since there is only\
        \ one ternary operator in mainstream programming languages, namely the **conditional\
        \ operator**, it is often referred as **the** ternary operator.\n[^18_5]:\
        \ Experimental support for `..<` operator was first introduced in Kotlin 1.7.20,\
        \ but this feature needed to wait until version 1.9 before it became stable."
          - type: "single-answer"
            stepId: "operators-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "operators-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "operators-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "operators-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "operators-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "type-system"
        name: "The beauty of Kotlinâ€™s type system"
        steps:
          - type: "text"
            stepId: "type-system-introduction"
            question: "The beauty of Kotlinâ€™s type system"
            explanation: "Introduction to The beauty of Kotlinâ€™s type system"
            repetable: false
            text: "{sample: true}\n# The beauty of Kotlinâ€™s type system\n\nThe Kotlin type\
        \ system is amazingly designed. Many features that look like special cases\
        \ are just a natural consequence of how the type system is designed. For instance,\
        \ thanks to the type system, in the example below the type of `surname` is\
        \ `String`, the type of `age` is `Int`, and we can use `return` and `throw`\
        \ on the right side of the Elvis operator.\n\n```kotlin\nfun processPerson(person:\
        \ Person?) {\n    val name = person?.name ?: \"unknown\"\n\n    val surname\
        \ = person?.surname ?: return\n\n    val age = person?.age ?: throw Error(\"\
        Person must have age\")\n\n    // ...\n}\n```\n\nThe typing system also gives\
        \ us very convenient nullability support, smart type inference, and much more.\
        \ In this chapter, we will reveal a lot of Kotlin magic. I always love talking\
        \ about this in my workshops because I see the stunning beauty of how Kotlinâ€™\
        s type system is so well designed that all these pieces fit perfectly together\
        \ and give us a great programming experience. I find this topic fascinating,\
        \ but I will also try to add some useful hints that show where this knowledge\
        \ can be useful in practice. I hope you will enjoy discovering it as much\
        \ as I did."
          - type: "text"
            stepId: "type-system-section-1"
            question: "What is a type?"
            explanation: "Content for What is a type?"
            repetable: false
            text: "## What is a type?\n\nBefore we start talking about the type system,\
        \ we should first explain what a type is. Do you know the answer? Think about\
        \ it for a moment.\n\nTypes are commonly confused with classes, but these\
        \ two terms represent totally different concepts. Take a look at the example\
        \ below. You can see `User` used four times. Can you tell me which usages\
        \ are classes, which are types, and which are something else?\n\n![](typing_system_type_vs_class_question.png)\n\
        \nAfter the `class` keyword, you define a class name. A class is a template\
        \ for objects that defines a set of properties and methods. When we call a\
        \ constructor, we create an object. Types are used here to specify what kind\
        \ of objects we expect to have in the variables[^20_1].\n\n![](typing_system_type_vs_class.png)"
          - type: "text"
            stepId: "type-system-section-2"
            question: "Why do we have types?"
            explanation: "Content for Why do we have types?"
            repetable: false
            text: "## Why do we have types?\n\nLet's do a thought experiment for a moment.\
        \ Kotlin is a statically typed language, so all variables and functions must\
        \ be typed. If we do not specify their types explicitly, they will be inferred.\
        \ But let's take a step back and imagine that you are a language designer\
        \ who is deciding what Kotlin should look like. It is possible to drop all\
        \ these requirements and eliminate all types completely. The compiler does\
        \ not really need them[^20_2]. It has classes that define how objects should\
        \ be created, and it has objects that are used during execution. What do we\
        \ lose if we get rid of types? Mostly safety and developers' convenience.\n\
        \n![](typing_system_type_vs_class_crossed.png)\n\nIt is worth mentioning that\
        \ many languages do support classes and objects but not types. Among them,\
        \ there is JavaScript[^20_6] and (not long ago) Python - two of the most popular\
        \ languages in the world[^20_3]. However, types do offer us value, which is\
        \ why in the JavaScript community more and more people use TypeScript (which\
        \ is basically JavaScript plus types), and Python has introduced support for\
        \ types.\n\nSo why do we have types? They are mainly for us, developers. A\
        \ type tells us what methods or properties we can use on an object. A type\
        \ tells us what kind of value can be used as an argument. Types prevent the\
        \ use of incorrect objects, methods, or properties. They give us safety, and\
        \ suggestions are provided by the IDE. The compiler also benefits from types\
        \ as they are used to better optimize our code or to decide which function\
        \ should be chosen when its name is overloaded. Still, it is developers who\
        \ are the most important beneficent of types.\n\nSo what is a type? **It can\
        \ be considered as a set of things we can do with an object**. Typically,\
        \ it is a set of methods and properties."
          - type: "text"
            stepId: "type-system-section-3"
            question: "The relation between classes and types"
            explanation: "Content for The relation between classes and types"
            repetable: false
            text: "## The relation between classes and types\n\nWe say that classes generate\
        \ types. Think of the class `User`. It generates two types. Can you name them\
        \ both? One is `User`, but the second is not `Any` (`Any` is already in the\
        \ type hierarchy). The second new type generated by the class `User` is `User?`.\
        \ Yes, the nullable variant is a separate type.\n\nThere are classes that\
        \ generate many more types: generic classes. The `Box<T>` class theoretically\
        \ generates an infinite number of types.\n\n![](typing_system_type_class_relation.png)"
          - type: "text"
            stepId: "type-system-section-4"
            question: "Class vs type in practice"
            explanation: "Content for Class vs type in practice"
            repetable: false
            text: "## Class vs type in practice\n\nThis discussion might sound very theoretical,\
        \ but it already has some practical implications. Note that classes cannot\
        \ be nullable, but types can. Consider the initial example, where I asked\
        \ you to point out where `User` is a type. Only in positions that represent\
        \ types can you use `User?` instead of `User`.\n\n![](typing_system_type_vs_class_nullable.png)\n\
        \nMember functions are defined on classes, so their receiver cannot be nullable\
        \ or have type arguments[^20_4]. Extension functions are defined on types,\
        \ so they can be nullable or defined on a concrete generic type. Consider\
        \ the `sum` function,, which is an extension of `Iterable<Int>`, or the `isNullOrBlank`\
        \ function, which is an extension of `String?`.\n\n```kotlin\nfun Iterable<Int>.sum():\
        \ Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum +=\
        \ element\n    }\n    return sum\n}\n\n@OptIn(ExperimentalContracts::class)\n\
        inline fun CharSequence?.isNullOrBlank(): Boolean {\n    // (skipped contract\
        \ definition)\n    return this == null || this.isBlank()\n}\n```"
          - type: "text"
            stepId: "type-system-section-5"
            question: "The relationship between types"
            explanation: "Content for The relationship between types"
            repetable: false
            text: "## The relationship between types\n\nLet's say that we have a class `Dog`\
        \ and its superclass `Animal`.\n\n```kotlin\nopen class Animal\nclass Dog\
        \ : Animal()\n```\n\nWherever an `Animal` type is expected, you can use a\
        \ `Dog`, but not the other way around.\n\n```kotlin\nfun petAnimal(animal:\
        \ Animal) {}\nfun petDog(dog: Dog) {}\n\nfun main() {\n    val dog: Dog =\
        \ Dog()\n    val dogAnimal: Animal = dog // works\n    petAnimal(dog) // works\n\
        \    val animal: Animal = Animal()\n    val animalDog: Dog = animal // compilation\
        \ error\n    petDog(animal) // compilation error\n}\n```\n\nWhy? Because there\
        \ is a concrete relationship between these types: `Dog` is a subtype of `Animal`.\
        \ By rule, when A is a subtype of B, we can use A where B is expected. We\
        \ might also say that `Animal` is a supertype of `Dog`, and a subtype can\
        \ be used where a supertype is expected.\n\n{width: 25%, align: middle}\n\
        ![](typing_system_A_B.png)\n\nThere is also a relationship between nullable\
        \ and non-nullable types. A non-nullable can be used wherever a nullable is\
        \ expected.\n\n```kotlin\nfun petDogIfPresent(dog: Dog?) {}\nfun petDog(dog:\
        \ Dog) {}\n\nfun main() {\n    val dog: Dog = Dog()\n    val dogNullable:\
        \ Dog? = dog\n    petDogIfPresent(dog) // works\n    petDogIfPresent(dogNullable)\
        \ // works\n    petDog(dog) // works\n    petDog(dogNullable) // compilation\
        \ error\n}\n```\n\nThis is because the non-nullable variant of each type is\
        \ a subtype of the nullable variant.\n\n{width: 50%, align: middle}\n![](typing_system_A_B_nullability.png)\n\
        \nThe superclass of all the classes in Kotlin is `Any`, which is similar to\
        \ `Object` in Java. The supertype of all the types is not `Any`, it is `Any?`.\
        \ `Any` is a supertype of all non-nullable types. We also have something that\
        \ is not present in Java and most other mainstream languages: the subtype\
        \ of all the types, which is called `Nothing`. We will talk about it soon.\n\
        \n{width: 50%, align: middle}\n![](typing_system_A_B_nullability_Any_Nothing.png)\n\
        \n`Any` is only a supertype of non-nullable types. So, wherever `Any` is expected,\
        \ nullable types will not be accepted. This fact is also used to set a type\
        \ parameterâ€™s upper boundary to accept only non-nullable types[^20_5].\n\n\
        ```kotlin\nfun <T : Any> String.parseJson(): T = ...\n```\n\n`Unit` does not\
        \ have any special place in the type hierarchy. It is just an object declaration\
        \ that is used when a function does not specify a result type.\n\n```kotlin\n\
        object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n```\n\nLet's\
        \ talk about a concept that has a very special place in the typing hierarchy:\
        \ let's talk about `Nothing`."
          - type: "text"
            stepId: "type-system-section-6"
            question: "The subtype of all the types: Nothing"
            explanation: "Content for The subtype of all the types: Nothing"
            repetable: false
            text: "## The subtype of all the types: Nothing\n\n`Nothing` is a subtype of\
        \ all the types in Kotlin. If we had an instance of this type, it could be\
        \ used instead of everything else (like a Joker in the card game Rummy). Itâ€™\
        s no wonder that such an instance does not exist. `Nothing` is an empty type\
        \ (also known as a bottom type, zero type, uninhabited type, or never type),\
        \ which means it has no values. It is literally impossible to make an instance\
        \ of type `Nothing`, but this type is still really useful. I will tell you\
        \ more: some functions declare `Nothing` as their result type. You've likely\
        \ used such functions many times already. What functions are those? They declare\
        \ `Nothing` as a result type, but they cannot return it because this type\
        \ has no instances. But what can these functions do? Three things: they either\
        \ need to run forever, end the program, or throw an exception. In all cases,\
        \ they never return, so the `Nothing` type is not only valid but also really\
        \ useful.\n\n```kotlin\nfun runForever(): Nothing {\n    while (true) {\n\
        \        // no-op\n    }\n}\n\nfun endProgram(): Nothing {\n    exitProcess(0)\n\
        }\n\nfun fail(): Nothing {\n    throw Error(\"Some error\")\n}\n```\n\nI have\
        \ never found a good use case for a function that runs forever, and ending\
        \ a program is not very common, but we often use functions that throw exceptions.\
        \ Who hasn't ever used `TODO()`? This function throws a `NotImplementedError`\
        \ exception. There is also the `error` function from the standard library,\
        \ which throws an `IllegalStateException`.\n\n```kotlin\ninline fun TODO():\
        \ Nothing = throw NotImplementedError()\n\ninline fun error(message: Any):\
        \ Nothing =\n    throw IllegalStateException(message.toString())\n```\n\n\
        `TODO` is used as a placeholder in a place where we plan to implement some\
        \ code.\n\n```kotlin\nfun fib(n: Int): Int = TODO()\n```\n\n`error` is used\
        \ to signal an illegal situation:\n\n```kotlin\nfun get(): T = when {\n  \
        \  left != null -> left\n    right != null -> right\n    else -> error(\"\
        Must have either left or right\")\n}\n```\n\nThis result type is significant.\
        \ Letâ€™s say that you have an if-condition that returns either `Int` or `Nothing`.\
        \ What should the inferred type be? The closest supertype of both `Int` and\
        \ `Nothing` is `Int`. This is why the inferred type will be `Int`.\n\n```kotlin\n\
        // the inferred type of answer is Int\nval answer = if (timeHasPassed) 42\
        \ else TODO()\n```\n\nThe same rule applies when we use the Elvis operator,\
        \ a when-expression, etc. In the example below, the type of both `name` and\
        \ `fullName` is `String` because both `fail` and `error` declare `Nothing`\
        \ as their result type. This is a huge convenience.\n\n```kotlin\nfun processPerson(person:\
        \ Person?) {\n    // the inferred type of name is String\n    val name = person?.name\
        \ ?: fail()\n    // the inferred type of fullName is String\n    val fullName\
        \ = when {\n        !person.middleName.isNullOrBlank() ->\n            \"\
        $name ${person.middleName} ${person.surname}\"\n        !person.surname.isNullOrBlank()\
        \ ->\n            \"$name ${person.surname}\"\n        else ->\n         \
        \   error(\"Person must have a surname\")\n    }\n    // ...\n}\n```"
          - type: "text"
            stepId: "type-system-section-7"
            question: "The result type from return and throw"
            explanation: "Content for The result type from return and throw"
            repetable: false
            text: "## The result type from return and throw\n\nI will start this subchapter\
        \ with something strange: did you know that you can place `return` or `throw`\
        \ on the right side of a variable assignment?\n\n```kotlin\nfun main() {\n\
        \    val a = return\n    val b = throw Error()\n}\n```\n\nThis doesnâ€™t make\
        \ any sense as both `return` and `throw` end the function, so we will never\
        \ assign anything to such variables (like `a` and `b` in the example above).\
        \ This assignment is an unreachable piece of code. In Kotlin, it just causes\
        \ a warning.\n\n![](typing_system_return_return_type.png)\n\nThe code above\
        \ is correct from the language point of view because both `return` and `throw`\
        \ are expressions, which means they declare a result type. This type is `Nothing`.\n\
        \n```kotlin\nfun main() {\n    val a: Nothing = return\n    val b: Nothing\
        \ = throw Error()\n}\n```\n\nThis explains why we can place `return` or `throw`\
        \ on the right side of the Elvis operator or in a when-expression.\n\n```kotlin\n\
        fun processPerson(person: Person?) {\n    val name = person?.name ?: return\n\
        \    val fullName = when {\n        !person.middleName.isNullOrBlank() ->\n\
        \            \"$name ${person.middleName} ${person.surname}\"\n        !person.surname.isNullOrBlank()\
        \ ->\n            \"$name ${person.surname}\"\n        else -> return\n  \
        \  }\n    // ...\n}\n```\n\n```kotlin\nfun processPerson(person: Person?)\
        \ {\n    val name = person?.name ?: throw Error(\"Name is required\")\n  \
        \  val fullName = when {\n        !person.middleName.isNullOrBlank() ->\n\
        \            \"$name ${person.middleName} ${person.surname}\"\n        !person.surname.isNullOrBlank()\
        \ ->\n            \"$name ${person.surname}\"\n        else -> throw Error(\"\
        Surname is required\")\n    }\n    // ...\n}\n```\n\nBoth `return` and `throw`\
        \ declare `Nothing` as their result type. As a consequence, Kotlin will infer\
        \ `String` as the type of both `name` and `fullName` because `String` is the\
        \ closest supertype of both `String` and `Nothing`.\n\nSo, now you can say\
        \ that you know `Nothing`. Just like John Snow.\n\n![](Nothing_John_Snow.png)"
          - type: "text"
            stepId: "type-system-section-8"
            question: "When is some code not reachable?"
            explanation: "Content for When is some code not reachable?"
            repetable: false
            text: "## When is some code not reachable?\n\nWhen an element declares `Nothing`\
        \ as a return type, it means that everything after its call is not reachable.\
        \ This is reasonable: there are no instances of `Nothing`, so it cannot be\
        \ returned. This means a statement that declares `Nothing` as its result type\
        \ will never complete in a normal way, so the next statements are not reachable.\
        \ This is why everything after either `fail` or `throw` will be unreachable.\n\
        \n{width: 60%}\n![](typing_system_fail_throw.png)\n\nItâ€™s the same with `return`,\
        \ `TODO`, `error`, etc. If a non-optional expression declares `Nothing` as\
        \ its result type, everything after that is unreachable. This is a simple\
        \ rule, but itâ€™s useful for the compiler. Itâ€™s also useful for us since it\
        \ gives us more possibilities. Thanks to this rule, we can use `TODO()` in\
        \ a function instead of returning a value. Anything that declares `Nothing`\
        \ as a result type ends the function (or runs forever), so this function will\
        \ not end without returning or throwing first.\n\n```kotlin\nfun fizzBuzz():\
        \ String {\n    TODO()\n}\n```\n\nI would like to end this topic with a more\
        \ advanced example that comes from the Kotlin Coroutines library. There is\
        \ a `MutableStateFlow` class, which represents a mutable value whose state\
        \ changes can be observed using the `collect` method. The thing is that `collect`\
        \ suspends the current coroutine until whatever it observes is closed, but\
        \ a StateFlow cannot be closed. This is why this `collect` function declares\
        \ `Nothing` as its result type.\n\n```kotlin\npublic interface SharedFlow<out\
        \ T> : Flow<T> {\n    public val replayCache: List<T>\n    override suspend\
        \ fun collect(\n        collector: FlowCollector<T>\n    ): Nothing\n}\n```\n\
        \nThat is very useful for developers who are not aware of how `collect` works.\
        \ Thanks to the result type, IntelliJ informs them that the code they place\
        \ after `collect` is unreachable.\n\n![SharedFlow cannot be closed, so its\
        \ `collect` function will never return, therefore it declares `Nothing` as\
        \ its result type.](stateflow_unreachable.png)"
          - type: "text"
            stepId: "type-system-section-9"
            question: "The type of null"
            explanation: "Content for The type of null"
            repetable: false
            text: "## The type of null\n\nLet's see another peculiar thing. Did you know\
        \ that you can assign `null` to a variable without setting an explicit type?\
        \ Whatâ€™s more, such a variable can be used wherever `null` is accepted.\n\n\
        ```kotlin\nfun main() {\n    val n = null\n    val i: Int? = n\n    val d:\
        \ Double? = n\n    val str: String? = n\n}\n```\n\nThis means that `null`\
        \ has its type, which is a subtype of all nullable types. Take a look at the\
        \ type hierarchy and guess what type this is.\n\n{width: 50%, align: middle}\n\
        ![](typing_system_A_B_nullability_Any_Nothing.png)\n\nI hope you guessed that\
        \ the type of `null` is `Nothing?`. Now think about the inferred type of `a`\
        \ and `b` in the example below.\n\n```kotlin\nval a = if (predicate) \"A\"\
        \ else null\n\nval b = when {\n    predicate2 -> \"B\"\n    predicate3 ->\
        \ \"C\"\n    else -> null\n}\n```\n\nIn the if-expression, we search for the\
        \ closest supertype of the types from both branches. The closest supertype\
        \ of `String` and `Nothing?` is `String?`. The same is true about the when-expression:\
        \ the closest supertype of `String`, `String`, and `Nothing?` is `String?`.\
        \ Everything makes sense.\n\nFor the same reason, whenever we require `String?`,\
        \ we can pass either `String` or `null`, whose type is `Nothing?`. This is\
        \ clear when you take a look at the type hierarchy. `String` and `Nothing?`\
        \ are the only non-empty subtypes of `String?`.\n\n![](Socrates.png)"
          - type: "text"
            stepId: "type-system-section-10"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nIn this chapter, we've learned the following:\n* A class\
        \ is a template for creating objects. A type defines expectations and functionalities.\n\
        * Every class generates a nullable and a non-nullable type.\n* A nullable\
        \ type is a supertype of the non-nullable variant of this type.\n* The supertype\
        \ of all types is `Any?`.\n* The supertype of non-nullable types is `Any`.\n\
        * The subtype of all types is `Nothing`.\n* When a function declares `Nothing`\
        \ as a return type, this means that it will throw an error or run infinitely.\n\
        * Both `throw` and `return` declare `Nothing` as their result type.\n* The\
        \ Kotlin compiler understands that when an expression declares `Nothing` as\
        \ a result type, everything after that is unreachable.\n* The type of `null`\
        \ is `Nothing?`, which is the subtype of all nullable types.\n\nIn the next\
        \ chapter, we are going to discuss generics, and weâ€™ll see how they are important\
        \ for our type system.\n\n[^20_1]: Parameters are also variables.\n[^20_2]:\
        \ Except when figuring out which function to choose in the case of overloading.\n\
        [^20_3]: It all depends on what we measure, but Python, Java, and JavaScript\
        \ take the first three positions in most rankings. In some, they are beaten\
        \ by C, which is widely used for very low-level development, like developing\
        \ processors for cars or refrigerators.\n[^20_4]: Type arguments and type\
        \ parameters will be better explained in the chapter *Generics*.\n[^20_5]:\
        \ I will explain type parameters' upper boundaries in the chapter *Generics*.\n\
        [^20_6]: Formally, JavaScript supports weak typing, but in this chapter we\
        \ discuss static typing, which is not supported by JavaScript."
          - type: "single-answer"
            stepId: "type-system-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "type-system-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "type-system-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "type-system-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "type-system-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
      - lessonId: "generics"
        name: "Generics"
        steps:
          - type: "text"
            stepId: "generics-introduction"
            question: "Generics"
            explanation: "Introduction to Generics"
            repetable: false
            text: "# Generics\n\nIn the early days of Java, it was designed such that all\
        \ lists had the same type `List`, instead of specific lists with specific\
        \ parameter types, like `List<String>` or `List<Int>`. The `List` type in\
        \ Java accepts all kinds of values; when you ask for a value at a certain\
        \ position, the result type is `Object` (which, in Java, is the supertype\
        \ of all the types).\n\n```\n// Java\nList names = new ArrayList();\nnames.add(\"\
        Alex\");\nnames.add(\"Ben\");\nnames.add(123); // this is incorrect, but compiles\n\
        for(int i = 0; i < names.size(); i++){\n   String name= (String) names.get(i);\
        \ // exception at i==2\n   System.out.println(name.toUpperCase());\n}\n```\n\
        \nSuch lists are hard to use. We much prefer to have a list with specified\
        \ types of elements. Only then can we be sure that our list contains elements\
        \ of the correct type, and only then do we not need to explicitly cast these\
        \ elements when we get them from a list. This was one of the main reasons\
        \ Java introduced generics in version 5. In Kotlin, we do not have this problem\
        \ because it was designed with generics support from the beginning, and all\
        \ lists are generic, so they must specify what kinds of elements they accept.\
        \ Generics are an important feature of most modern programming languages;\
        \ so, in this chapter, we will discuss what they are and how we use them in\
        \ Kotlin.\n\nIn Kotlin, we have three kinds of generic elements:\n* generic\
        \ functions,\n* generic classes,\n* generic interfaces.\n\nLet's discuss them\
        \ one by one."
          - type: "text"
            stepId: "generics-section-1"
            question: "Generic functions"
            explanation: "Content for Generic functions"
            repetable: false
            text: "## Generic functions\n\nJust as we can pass an argument value to a parameter,\
        \ we can pass a type as a **type argument**. For this, a function needs to\
        \ define one or more type parameters inside angle brackets immediately after\
        \ the `fun` keyword. By convention, type parameter names are capitalized.\
        \ When a function defines a type parameter, we have to specify the type arguments\
        \ when calling this function. The type parameter is a placeholder for a concrete\
        \ type; the type argument is the actual type that is used when a function\
        \ is called. To specify type arguments explicitly, we also use angle brackets.\n\
        \n```kotlin\nfun <T> a() {} // T is type parameter\na<Int>() // Int is used\
        \ here as a type argument\na<String>() // String is used here as a type argument\n\
        ```\n\nThere is a popular practice that a single type argument is called `T`\
        \ (from \"type\"); if there are multiple type arguments, they are called `T`\
        \ with consecutive numbers. However, this practice is not a fixed rule, and\
        \ there are many other conventions for naming type parameters.\n\n```kotlin\n\
        fun <T> a() {}\nfun <T1, T2> b() {}\n```\n\nWhen we call a generic function,\
        \ all its type arguments must be clear for the Kotlin compiler. We can either\
        \ specify them explicitly, or their values can be inferred from the compiler.\n\
        \n```kotlin\nfun <T> a() {}\nfun <T1, T2> b() {}\nfun <T> c(t: T) {}\nfun\
        \ <T1, T2> d(a: T1, b: T2) {}\nfun <T> e(): T = TODO()\n\nfun main() {\n \
        \   // Type arguments specified explicitly\n    a<Int>()\n    a<String>()\n\
        \    b<Double, Char>()\n    b<Float, Long>()\n\n    // Inferred type arguments\n\
        \    c(10) // The inferred type of T is Int\n    d(\"AAA\", 10.0)\n    //\
        \ The inferred type of T1 is String, and of T2 is Double\n    val e: Boolean\
        \ = e() // The inferred type of T is Boolean\n}\n```\n\nSo, how are these\
        \ type parameters useful? We use them primarily to specify the relationship\
        \ between the arguments and the result type. For instance, we can express\
        \ that the result type is the same as an argument type or that we expect two\
        \ arguments of the same type.\n\n```kotlin\nimport kotlin.random.Random\n\n\
        // The result type is the same as the argument type\nfun <T> id(value: T):\
        \ T = value\n\n// The result type is the closest supertype of arguments\n\
        fun <T> randomOf(a: T, b: T): T =\n    if (Random.nextBoolean()) a else b\n\
        \nfun main() {\n    val a = id(10) // Inferred a type is Int\n    val b =\
        \ id(\"AAA\") // Inferred b type is String\n    val c = randomOf(\"A\", \"\
        B\") // Inferred c type is String\n    val d = randomOf(1, 1.5) // Inferred\
        \ d type is Number\n}\n```\n\nType parameters for functions are useful for\
        \ the compiler since they allow it to check and correctly infer types; this\
        \ makes our programs safer and makes programming more pleasurable for developers.\
        \ Better parameter types and type suggestions protect us from using illegal\
        \ operations and let our IDE give us better suggestions.\n\nIn the next book,\
        \ *Functional Kotlin*, you will see plenty of generic function examples, especially\
        \ for collection processing. Such functions are really important and useful.\
        \ But, for now, let's get back to the initial motivation for introducing generics:\
        \ let's talk about generic classes."
          - type: "text"
            stepId: "generics-section-2"
            question: "Generic classes"
            explanation: "Content for Generic classes"
            repetable: false
            text: "## Generic classes\n\nWe can make classes generic by adding a type parameter\
        \ after the class name. Such a type parameter can be used all over the class\
        \ body, especially to specify properties, parameters, and result types. A\
        \ type parameter is specified when we define an instance, after which it remains\
        \ unchanged. Thanks to that, when you declare `ValueWithHistory<String>` and\
        \ then call `setValue` in the example below, you must use an object of type\
        \ `String`; when you call `currentValue`, the result object will be typed\
        \ as `String`; and when you call `history`, its result is of type `List<String>`.\
        \ Itâ€™s the same for all other possible type arguments.\n\n```kotlin\nclass\
        \ ValueWithHistory<T>(\n    private var value: T\n) {\n    private var history:\
        \ List<T> = listOf(value)\n\n    fun setValue(value: T) {\n        this.value\
        \ = value\n        this.history += value\n    }\n\n    fun currentValue():\
        \ T = value\n\n    fun history(): List<T> = history\n}\n\nfun main() {\n \
        \   val letter = ValueWithHistory<String>(\"A\")\n    // The type of letter\
        \ is ValueWithHistory<String>\n    letter.setValue(\"B\")\n    // letter.setValue(123)\
        \ <- this would not compile\n    val l = letter.currentValue() // the type\
        \ of l is String\n    println(l) // B\n    val h = letter.history() // the\
        \ type of h is List<String>\n    println(h) // [A, B]\n}\n```\n\nThe constructor\
        \ type argument can be inferred. In the above example, we specified it explicitly,\
        \ but we did not need to. This type can be inferred from the argument type.\n\
        \n```kotlin\nval letter = ValueWithHistory(\"A\")\n// The type of letter is\
        \ ValueWithHistory<String>\n```\n\nType arguments can also be inferred from\
        \ variable types. Let's say that we want to use `Any` as a type argument.\
        \ We can specify this by specifying the type of variable `letter` as `ValueWithHistory<Any>`.\n\
        \n```kotlin\nval letter: ValueWithHistory<Any> = ValueWithHistory(\"A\")\n\
        // The type of letter is ValueWithHistory<Any>\n```\n\nAs I mentioned in the\
        \ introduction to this chapter, the most important motivation for introducing\
        \ generics was to make collections with certain types of elements. Consider\
        \ the `ArrayList` class from the Standard Library (stdlib). It is generic,\
        \ so when we create an instance from this class we need to specify the types\
        \ of elements. Thanks to that, Kotlin protects us by expecting only values\
        \ with accepted types to be added to the list, and Kotlin uses this type when\
        \ we operate on the elements in the list.\n\n```kotlin\nfun main() {\n   \
        \ val letters = ArrayList<String>()\n    letters.add(\"A\") // the argument\
        \ must be of type String\n    letters.add(\"B\") // the argument must be of\
        \ type String\n    // The type of letters is List<String>\n    val a = letters[0]\
        \ // the type of a is String\n    println(a) // A\n    for (l in letters)\
        \ { // the type of l is String\n        println(l) // first A, then B\n  \
        \  }\n}\n```"
          - type: "text"
            stepId: "generics-section-3"
            question: "Generic classes and nullability"
            explanation: "Content for Generic classes and nullability"
            repetable: false
            text: "## Generic classes and nullability\n\nNotice that type arguments can\
        \ be nullable, so we could create `ValueWithHistory<String?>`. In such a case,\
        \ the `null` value is a perfectly valid option.\n\n```kotlin\nfun main() {\n\
        \    val letter = ValueWithHistory<String?>(null)\n    letter.setValue(\"\
        A\")\n    letter.setValue(null)\n    val l = letter.currentValue() // the\
        \ type of l is String?\n    println(l) // null\n    val h = letter.history()\
        \ // the type of h is List<String?>\n    println(h) // [null, A, null]\n\n\
        \    val letters = ArrayList<String?>()\n    letters.add(\"A\")\n    letters.add(null)\n\
        \    println(letters) // [A, null]\n    val l2 = letters[1] // the type of\
        \ l2 is String?\n    println(l2) // null\n}\n```\n\nAnother thing is that\
        \ when you use generic parameters inside classes or functions, you can make\
        \ them nullable by adding a question mark. See the example below. The type\
        \ `T` might or might not be nullable, depending on the type argument, but\
        \ the type `T?` is always nullable. We can assign `null` to variables of the\
        \ type `T?`. Nullable generic type parameter `T?` must be unpacked before\
        \ using it as `T`.\n\n```kotlin\nclass Box<T> {\n    var value: T? = null\n\
        \n    fun getOrThrow(): T = value!!\n}\n```\n\nThe opposite can also be expressed.\
        \ Since a generic type parameter might represent a nullable type (you can\
        \ have `List<Int?>`), we might specify a definitely non-nullable variant of\
        \ this type by adding `& Any` after the type parameter. In the example below,\
        \ the method `orThrow` can be invoked on any value, but it unpacks nullable\
        \ types into non-nullable ones.\n\n```kotlin\nfun <T> T.orThrow(): T & Any\
        \ = this ?: throw Error()\n\nfun main() {\n    val a: Int? = if (Random.nextBoolean())\
        \ 42 else null\n    val b: Int = a.orThrow()\n    val c: Int = b.orThrow()\n\
        \    println(b)\n}\n```"
          - type: "text"
            stepId: "generics-section-4"
            question: "Generic interfaces"
            explanation: "Content for Generic interfaces"
            repetable: false
            text: "## Generic interfaces\n\nInterfaces can also be generic, which has similar\
        \ consequences as for classes: the specified type parameters can be used inside\
        \ the interface body as types for properties, parameters, and result types.\
        \ A good example is the `List` interface.\n\n```kotlin\ninterface List<out\
        \ E> : Collection<E> {\n    override val size: Int\n    override fun isEmpty():\
        \ Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n\
        \    override fun iterator(): Iterator<E>\n    override fun containsAll(\n\
        \        elements: Collection<@UnsafeVariance E>\n    ): Boolean\n    operator\
        \ fun get(index: Int): E\n    fun indexOf(element: @UnsafeVariance E): Int\n\
        \    fun lastIndexOf(element: @UnsafeVariance E): Int\n    fun listIterator():\
        \ ListIterator<E>\n    fun listIterator(index: Int): ListIterator<E>\n   \
        \ fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n```\n\n> The `out`\
        \ modifier and the `UnsafeVariance` annotation will be explained in the book\
        \ *Advanced Kotlin*.\n\n![For `List<String>` type, methods like `contains`\
        \ expect an argument of type `String`, and methods like `get` declare `String`\
        \ as the result type.](list_str_suggestions.png)\n\n![For `List<String>`,\
        \ methods like `filter` can infer `String` as a lambda parameter.](list_suggestions.png)\n\
        \nGeneric interfaces are inherited by classes. Let's say that we have a class\
        \ `Dog` that inherits from `Consumer<DogFood>`, as shown in the snippet below.\
        \ The interface `Consumer` expects a method `consume` with the type parameter\
        \ `T`. This means our `Dog` must override the `consume` method with an argument\
        \ of type `DogFood`. It must be `DogFood` because we implement the `Consumer<DogFood>`\
        \ type, and the parameter type in the interface `Consumer` must match the\
        \ type argument `DogFood`. Now, when you have an instance of `Dog`, you can\
        \ up-cast it to `Consumer<DogFood>`.\n\n```kotlin\ninterface Consumer<T> {\n\
        \    fun consume(value: T)\n}\nclass DogFood\n\nclass Dog : Consumer<DogFood>\
        \ {\n    override fun consume(value: DogFood) {\n        println(\"Mlask mlask\"\
        )\n    }\n}\n\nfun main() {\n    val dog: Dog = Dog()\n    val consumer: Consumer<DogFood>\
        \ = dog\n}\n```"
          - type: "text"
            stepId: "generics-section-5"
            question: "Type parameters and inheritance"
            explanation: "Content for Type parameters and inheritance"
            repetable: false
            text: "## Type parameters and inheritance\n\nClasses can inherit from open generic\
        \ classes or implement generic interfaces; however, in both cases they must\
        \ explicitly specify the type argument. Consider the snippet below. Class\
        \ `A` inherits from `C<Int>` and implements `I<String>`.\n\n```kotlin\nopen\
        \ class C<T>\ninterface I<T>\nclass A : C<Int>(), I<String>\n\nfun main()\
        \ {\n    val a = A()\n    val c: C<Int> = a\n    val i: I<String> = a\n}\n\
        ```\n\nIt is actually quite common that a non-generic class inherits from\
        \ a generic one. Consider `MessageListAdapter` presented below, which inherits\
        \ from `ArrayAdapter<String>`.\n\n```kotlin\nclass MessageListAdapter(\n \
        \   context: Context,\n    val values: List<ClaimMessage>\n) : ArrayAdapter<String>(\n\
        \    context,\n    R.layout.row_messages,\n    values.map { it.title }.toTypedArray()\n\
        ) {\n    fun getView(\n        position: Int,\n        convertView: View?,\n\
        \        parent: ViewGroup?\n    ): View {\n        // ...\n    }\n}\n```\n\
        \nAn even more common case is when one generic class or interface inherits\
        \ from another generic class or interface and uses its type parameter as a\
        \ type argument of the class it inherits from. In the snippet below, the class\
        \ `A` is generic and uses its type parameter `T` as an argument for both `C`\
        \ and `I`. This means that if you create `A<Int>`, you will be able to up-cast\
        \ it to `C<Int>` or `I<Int>`. However, if you create `A<String>`, you will\
        \ be able to up-cast it to `C<String>` or to `I<String>`.\n\n```kotlin\nopen\
        \ class C<T>\ninterface I<T>\nclass A<T> : C<T>(), I<T>\n\nfun main() {\n\
        \    val a: A<Int> = A<Int>()\n    val c1: C<Int> = a\n    val i1: I<Int>\
        \ = a\n\n    val a1: A<String> = A<String>()\n    val c2: C<String> = a1\n\
        \    val i2: I<String> = a1\n}\n```\n\nA good example is the collection hierarchy.\
        \ An object of type `MutableList<Int>` implements `List<Int>`, which implements\
        \ `Collection<Int>`, which implements `Iterable<Int>`.\n\n```kotlin\ninterface\
        \ Iterable<out T> {\n    // ...\n}\ninterface MutableIterable<out T> : Iterable<T>\
        \ {\n    // ...\n}\ninterface Collection<out E> : Iterable<E> {\n    /// ...\n\
        }\ninterface MutableCollection<E> : Collection<E>,MutableIterable<E>{\n  \
        \  // ...\n}\ninterface List<out E> : Collection<E> {\n    // ...\n}\ninterface\
        \ MutableList<E> : List<E>, MutableCollection<E> {\n    // ...\n}\n```\n\n\
        However, a class does not need to use its type parameter when inheriting from\
        \ a generic class or implementing a generic interface. Type parameters of\
        \ parent and child classes are independent of one another and should not be\
        \ confused, even if they have the same name.\n\n```kotlin\nopen class C<T>\n\
        interface I<T>\nclass A<T> : C<Int>(), I<String>\n\nfun main() {\n    val\
        \ a1: A<Double> = A<Double>()\n    val c1: C<Int> = a1\n    val i1: I<String>\
        \ = a1\n}\n```"
          - type: "text"
            stepId: "generics-section-6"
            question: "Type erasure"
            explanation: "Content for Type erasure"
            repetable: false
            text: "## Type erasure\n\nGeneric types were added to Java for developers' convenience,\
        \ but they were never built into the JVM platform. All type arguments are\
        \ lost when we compile Kotlin to JVM bytecode[^21_1]. Under the hood, this\
        \ means that `List<String>`  becomes `List`, and `emptyList<Double>` becomes\
        \ `emptyList`. The process of losing type arguments is known as **type erasure**.\
        \ Due to this process, type parameters have some limitations compared to regular\
        \ types. You cannot use them for `is` checks; you cannot reference them[^21_2];\
        \ and you cannot use them as reified type arguments[^21_3].\n\n```kotlin\n\
        import kotlin.reflect.typeOf\n\nfun <T> example(a: Any) {\n    val check =\
        \ a is T // ERROR\n    val ref = T::class // ERROR\n    val type = typeOf<T>()\
        \ // ERROR\n}\n```\n\nHowever, Kotlin can overcome these limitations thanks\
        \ to the use of inline functions with reified type arguments. This topic is\
        \ covered in depth in the chapter *Inline functions* in the book *Functional\
        \ Kotlin*.\n\n```kotlin\nimport kotlin.reflect.typeOf\n\ninline fun <reified\
        \ T> example(a: Any) {\n    val check = a is T\n    val ref = T::class\n \
        \   val type = typeOf<T>()\n}\n```"
          - type: "text"
            stepId: "generics-section-7"
            question: "Generic constraints"
            explanation: "Content for Generic constraints"
            repetable: false
            text: "## Generic constraints\n\nAn important feature of type parameters is\
        \ that they can be constrained to be a subtype of a concrete type. We set\
        \ a constraint by placing a supertype after a colon. For instance, let's say\
        \ that you implement the `maxOf` function, which returns the biggest of its\
        \ arguments. To find the biggest one, the arguments need to be comparable.\
        \ So, next to the type parameter, we can specify that we accept only types\
        \ that are a subtype of `Comparable<T>`.\n\n```kotlin\nimport java.math.BigDecimal\n\
        \nfun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a\
        \ else b\n}\n\nfun main() {\n    val m = maxOf(BigDecimal(\"10.00\"), BigDecimal(\"\
        11.00\"))\n    println(m) // 11.00\n\n    class A\n    maxOf(A(), A()) //\
        \ Compilation error, \n    // A is not Comparable<A>\n}\n```\n\nType parameter\
        \ constraints are also used for generic classes. Consider the `ListAdapter`\
        \ class below, which expects a type argument that is a subtype of `ItemAdapter`.\n\
        \n```kotlin\nclass ListAdapter<T : ItemAdapter>(/*...*/) { /*...*/ }\n```\n\
        \nAn important result of having a constraint is that instances of this type\
        \ can use all the methods offered by this type. In this way, when `T` is constrained\
        \ as a subtype of `Iterable<Int>`, we know that we can iterate over an instance\
        \ of type `T`, and that elements returned by the iterator will be of type\
        \ `Int`. When we are constrained to `Comparable<T>`, we know that this type\
        \ can be compared with another instance of the same type. Another popular\
        \ choice for a constraint is `Any`, which means that a type can be any non-nullable\
        \ type.\n\nIn rare cases in which we might need to set more than one upper\
        \ bound, we can use `where` to set more constraints. We add it after the class\
        \ or function name, and we use it to specify more than one generic constraint\
        \ for a single type.\n\n```kotlin\ninterface Animal {\n    fun feed()\n}\n\
        interface GoodTempered {\n    fun pet()\n}\n\nfun <T> pet(animal: T) where\
        \ T : Animal, T : GoodTempered {\n    animal.pet()\n    animal.feed()\n}\n\
        \nclass Cookie : Animal, GoodTempered {\n    override fun pet() {\n      \
        \  // ...\n    }\n    override fun feed() {\n        // ...\n    }\n}\nclass\
        \ Cujo : Animal {\n    override fun feed() {\n        // ...\n    }\n}\n\n\
        fun main() {\n    pet(Cookie()) // OK\n    pet(Cujo()) //COMPILATION ERROR,\
        \ Cujo is not GoodTempered\n}\n```"
          - type: "text"
            stepId: "generics-section-8"
            question: "Star projection"
            explanation: "Content for Star projection"
            repetable: false
            text: "## Star projection\n\nIn some cases, we donâ€™t want to specify a concrete\
        \ type argument for a type. In these scenarios, we can use a star projection\
        \ `*`, which accepts any type. There are two situations where this is useful.\
        \ The first is when you check if a variable is a list. In this case, you should\
        \ use the `is List<*>` check. Star projection should be used in such a case\
        \ because of type erasure. If you used `List<Int>`, it would be compiled to\
        \ `List` under the hood anyway. This means a list of strings would pass the\
        \ `is List<Int>` check. Such a check would be confusing and is illegal in\
        \ Kotlin. You must use `is List<*>` instead.\n\n```kotlin\nfun main() {\n\
        \    val list = listOf(\"A\", \"B\")\n    println(list is List<*>) // true\n\
        \    println(list is List<Int>) // Compilation error\n}\n```\n\nStar projection\
        \ can also be used for properties or parameters. You can use `List<*>` when\
        \ you want to express that you want a list, no matter what the type of its\
        \ elements. When you get elements from such a list, they are of type `Any?`,\
        \ which is the supertype of all the types.\n\n```kotlin\nfun printSize(list:\
        \ List<*>) {\n    println(list.size)\n}\n\nfun printList(list: List<*>) {\n\
        \    for (e in list) { // the type of e is Any?\n        println(e)\n    }\n\
        }\n```\n\nStar projection should not be confused with the `Any?` type argument.\
        \ To see this, let's compare `MutableList<Any?>` and `MutableList<*>`. Both\
        \ of these types declare `Any?` as generic result types. However, when elements\
        \ are added, `MutableList<Any?>` accepts anything (`Any?`), but `MutableList<*>`\
        \ accepts `Nothing`, so it does not accept any values.\n\n```kotlin\nfun main()\
        \ {\n    val l1: MutableList<Any?> = mutableListOf(\"A\")\n    val r1 = l1.first()\
        \ // the type of r1 is Any?\n    l1.add(\"B\") // the expected argument type\
        \ is Any?\n\n    val l2: MutableList<*> = mutableListOf(\"A\")\n    val r2\
        \ = l2.first() // the type of r2 is Any?\n    l2.add(\"B\") // ERROR,\n  \
        \  // the expected argument type is Nothing,\n    // so there is no value\
        \ that might be used as an argument\n}\n```\n\nWhen a star projection is used\
        \ as an argument, it will be treated as `Any?` in all the out-positions (result\
        \ types), and it will be treated as `Nothing` in all the in-positions (parameter\
        \ types)."
          - type: "text"
            stepId: "generics-section-9"
            question: "Underscore operator for type arguments"
            explanation: "Content for Underscore operator for type arguments"
            repetable: false
            text: "## Underscore operator for type arguments\n\nType arguments can be either\
        \ specified explicitly or inferred from the context. However, sometimes we\
        \ want to specify one type argument and let the compiler infer the other.\
        \ In such a case, we can use the underscore operator `_` as a type argument.\
        \ This operator specifies that we want to infer a type argument.\n\n```kotlin\n\
        inline fun <K, reified V> Map<K, *>\n        .filterValueIsInstance(): Map<K,\
        \ V> =\n    filter { it.value is V } as Map<K, V>\n\nfun main() {\n    val\
        \ props = mapOf(\n        \"name\" to \"Alex\",\n        \"age\" to 25,\n\
        \        \"city\" to \"New York\"\n    )\n    // One type argument inferred\
        \ with _, one specified\n    val strProps = props.filterValueIsInstance<_,\
        \ String>()\n    println(strProps) // {name=Alex, city=New York}\n}\n```"
          - type: "text"
            stepId: "generics-section-10"
            question: "Summary"
            explanation: "Content for Summary"
            repetable: false
            text: "## Summary\n\nFor many developers, generics seem so hard and scary, but\
        \ they are actually quite simple and intuitive. We can make an element generic\
        \ by specifying its type parameter (or parameters). Such a type parameter\
        \ can be used inside this element. This mechanism lets us generalize algorithms\
        \ and classes so that they can be used with different types. It is good to\
        \ understand how generics work, which is why this chapter has presented nearly\
        \ all aspects of this mechanism. However, there are a few more, and we will\
        \ get back to this topic in the book *Advanced Kotlin*, where we still need\
        \ to discuss variance modifiers (`out` and `in`).\n\n[^21_1]: I use JVM as\
        \ a reference because it is the most popular target for Kotlin, but also because\
        \ it was the first one, so many Kotlin mechanisms were designed for it. However,\
        \ regarding a lack of support for type arguments, other platforms are not\
        \ better. For example, JavaScript does not support types at all.\n[^21_2]:\
        \ Class and type references are explained in the book *Advanced Kotlin*.\n\
        [^21_3]: Reified type arguments are explained in the book *Functional Kotlin*."
          - type: "single-answer"
            stepId: "generics-challenge-1"
            question: "Which keyword declares a read-only variable in Kotlin?"
            explanation: "Use val for a read-only reference; var declares a mutable one."
            repetable: true
            answers:
              - "var"
              - "val"
            correct: "val"
          - type: "single-answer"
            stepId: "generics-challenge-2"
            question: "Which expression is Kotlin's replacement for the traditional switch statement?"
            explanation: "Kotlin uses when as a powerful replacement for switch."
            repetable: true
            answers:
              - "when"
              - "switch"
              - "match"
            correct: "when"
          - type: "multiple-answer"
            stepId: "generics-challenge-3"
            question: "Which of these are Kotlin collection interfaces?"
            explanation: "List, Set, and Map are collection interfaces; Array is a class."
            repetable: true
            answers:
              - "List"
              - "Set"
              - "Map"
              - "Array"
            correct:
              - "List"
              - "Set"
              - "Map"
          - type: "exact-text"
            stepId: "generics-challenge-4"
            question: "What keyword starts a function declaration in Kotlin?"
            explanation: "Functions are declared with the fun keyword."
            repetable: true
            correct:
              - "fun"
          - type: "single-answer"
            stepId: "generics-challenge-5"
            question: "What is the default visibility of a top-level declaration in Kotlin?"
            explanation: "Top-level declarations are public by default."
            repetable: true
            answers:
              - "public"
              - "private"
              - "internal"
            correct: "public"
